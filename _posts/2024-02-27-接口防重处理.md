---
layout: post   	
catalog: true 	
tags:
    - 业务场景
---
# 1. 使用场景

在Web应用程序中，用户可能会重复提交表单，例如在点击提交按钮后仍连续多次点击、由于网络延迟造成用户误以为提交未成功而再次提交。这可能导致一些问题，例如重复的数据插入或重复的业务逻辑处理。接口防重处理的主要作用是在用户提交表单请求后，对请求进行拦截和处理，防止重复提交

# 2. 解决方案

**方案一**

从url里面取：【参数，url，用户】然后和过期时间一起放到redis，下次再来的时候会去redis里面去查询，如果已经过期，那么通过，并把请求放入redis，如果未过期，那么就不通过。如果在超时时间内进行了第二次请求且参数都一致，拦截器进行拦截抛出异常不进行真正的处理。思路其实和限流类似，只是这里多了对请求参数的处理，并且没有采用AOP而是用了拦截器去实现

**方案二**

生成唯一的key，key的组成为url+token+参数，意味着每一个用户的每一个请求都对应redis中的一个key，该key对应的值存空字符串即可（因为我们只需要key来保证唯一性，值不存东西也行）。首先，我们获取这个key，如果redis中没有这个key说明用户第一次请求，则不拦截请求并将key存进redis。如果redis中有key，说明在限制时间里（key没过期）用户再次进行了请求，则拦截返回错误信息

# 3. 实现

**可能遇到的问题**

在项目中经常出现多次读取HTTP请求体的情况，这时候可能就会报错，原因是读取HTTP请求体的操作，最终都要调用HttpServletRequest的getInputStream()方法和getReader()方法，而这两个方法总共只能被调用一次，第二次调用就会报错。

RepeatableFilter用RepeatedlyRequestWrapper 包装了HttpServletRequest。将HttpServletRequest的字节流的数据，保存到一个变量中，重写getInputStream()方法和getReader()方法，从变量中读取数据，返回给调用者。

**高阶操作**

自定义一个`@RepeatSubmit` 注解，只对加了该注解的请求路径实施请求防重处理
