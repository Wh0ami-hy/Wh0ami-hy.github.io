---
layout: post   	
catalog: true 	
tags:
    - Frame
---





# 1.网站类型

## 1.1.门户型

小说网站、漫画网站、听书网站、电影网站、新闻、论坛

## 1.2.电子商务

淘宝

## 1.3.B2B型

阿里1688

# 2.网站架构

https://www.cnblogs.com/jakey-hong/p/11216363.html

## 2.1.单体架构

所有的功能集成在一个项目工程中

## 2.2.分布式架构（垂直架构）

将一个单体系统按业务垂直拆分为若干系统，系统之间通过网络交互来完成用户的业务处理，每个系统可分布式部署

## 2.3.SOA架构

将不同业务功能按服务进行拆分，并通过这些服务之间定义良好的接口和协议联系起来

以服务的方式向各系统提供服务。各系统与服务之间采用webservice、rpc等方式进行通信

## 2.4.微服务架构

难度大

# 3.架构思维

在软件开发中，架构思维是指在整个软件开发过程中，以系统架构为核心，通过对系统的需求、功能、性能、可用性、可维护性等多个方面的综合考虑，从整体上设计出一个高效、可靠、可扩展、易维护的软件系统架构的能力和思维方式

架构思维主要涉及以下方面：

1. 系统架构设计：在软件开发前期，需要对系统的**需求、功能、性能**等进行分析和设计，从整体上规划出系统的架构设计方案。
2. 模块设计和划分：在系统架构确定后，需要对系统进行进一步的划分和设计，将整个系统**拆分为不同的模块，确定各个模块之间的关系和接口**。
3. 技术选型：在系统设计过程中，需要根据系统的需求和功能**选择合适的技术方案**，例如数据库、Web框架、中间件等。
4. 性能优化：在系统实现过程中，需要根据系统的性能需求，对系统进行**性能优化，例如通过缓存、负载均衡**、分布式架构等方式提升系统的性能。
5. 安全性设计：在系统设计过程中，需要考虑系统的安全性，包括**数据安全、用户身份验证**、安全审计等方面，从整体上规划出系统的安全设计方案。
6. 可扩展性设计：在系统设计过程中，需要考虑系统的可扩展性，包括**系统的可伸缩性、可复制性、可集群化**等方面，从整体上规划出系统的可扩展设计方案。
7. 可维护性设计：在系统设计过程中，需要考虑系统的可维护性，包括**代码结构的清晰性、注释的规范性、测试的全面性**等方面，从整体上规划出系统的可维护设计方案。
8. 用户体验设计：在系统设计过程中，需要考虑用户的使用体验，包括系统的**交互设计、页面布局、颜色搭配**等方面，从整体上规划出系统的用户体验设计方案。
9. 设计模式应用：在系统设计过程中，需要**运用设计模式**，例如MVC、DAO、工厂模式、策略模式等，从而提高系统的可扩展性和可维护性。
10. 面向对象设计：在系统设计过程中，需要**运用面向对象的设计原则**，例如单一职责原则、开闭原则、依赖倒置原则等，从而提高系统的可维护性和可扩展性。
11. 数据架构设计：在系统设计过程中，需要考虑系**统的数据结构和数据交互方式，包括数据库的设计、数据表的设计、数据传输方式**等方面，从整体上规划出系统的数据架构设计方案。
12. 业务逻辑设计：在系统设计过程中，需要考虑**系统的业务逻辑和业务流程**，包括各个业务模块之间的关系、业务流程的设计、交互方式等方面，从整体上规划出系统的业务逻辑设计方案。
13. 系统集成设计：在系统设计过程中，需要考虑系统与其他**系统之间的集成问题，包括数据传输方式、接口设计、协议兼容**等方面，从整体上规划出系统的集成设计方案。
14. 版本管理和发布设计：在系统设计过程中，需要考虑**系统的版本管理和发布方式，包括代码管理、版本控制、发布流程**等方面，从整体上规划出系统的版本管理和发布设计方案。

# 4.业务逻辑

业务逻辑是实现具体业务功能的代码部分，通常会包含以下几个方面：

1. 数据处理：包括**数据的输入、输出、存储、处理**等。这通常涉及到数据库的操作，如数据的增删改查，以及数据的格式化、校验等。
2. 业务流程：根据业务需求，将不同的功能模块组合成完整的业务流程，涉及到的代码通常是一些业务规则和流程控制语句。
3. 计算和算法：某些应用程序可能需要进行复杂的计算和算法处理，如金融应用程序中的复利计算、信用评估等。
4. 安全性和权限控制：应用程序中通常需要对**用户身份进行认证和授权**，以确保系统数据的安全性和可靠性。
5. 异常处理和日志记录：应用程序中可能会出现各种异常情况，例如网络故障或无效的用户输入。业务逻辑类可能包含这些**异常情况的处理逻辑**，并记录日志以帮助排除故障。

在编写应用程序的业务逻辑时，开发者应该遵循一些最佳实践，例如使用设计模式、编写可测试的代码、避免过度耦合等，以确保业务逻辑的高效性和可靠性。

# 5.基于Spring MVC的业务逻辑实现

业务逻辑通常由一个或多个Java类组成，这些类可能包括：

1. 数据访问类：用于从数据库或其他数据存储介质中读取和写入数据。
2. 服务类：用于执行业务逻辑，如计算、验证、授权等。
3. 控制器类：用于处理用户请求和交互，并将请求转发给相应的服务类。
4. 模型类：用于表示应用程序中使用的数据模型。
5. 工具类：用于提供常用的实用程序方法，如日期格式化、字符串处理、加密解密等。
6. 配置类：拓展功能

## 5.1.定义数据模型（Model）

数据模型通常是一个Java类，用于表示业务逻辑中的实体或数据结构。可以使用Java注解来定义数据模型的属性，例如`@Entity`、`@Column`等。

在定义数据模型时，需要考虑以下几个方面：

- 属性定义：属性定义通常包括属性名称、数据类型、默认值、长度等信息。
- 关联关系：如果数据模型之间存在关联关系，则需要定义关联属性和对应的关联关系注解，例如`@OneToMany`、`@ManyToOne`等。
- 数据校验：可以使用Java注解来对数据模型进行校验，例如`@NotNull`、`@Size`、`@Pattern`等。
- 序列化和反序列化：如果需要将数据模型转换为JSON或XML格式，可以使用Jackson或其他序列化库来进行转换。

```
可以引入Lombok，使用注解简化开发
	@Data
    @AllArgsConstructor
    @NoArgsConstructor
常规创建标准的实体类
	实现序列化接口
	私有化属性
	无参、有参构造
	getter、setter方法
	toString方法
```

## 5.2.业务逻辑处理器（Controller）

业务逻辑处理器通常是一个Java类，用于处理请求和生成响应。可以使用Java注解来定义业务逻辑处理器和处理器方法，例如`@Controller`、`@RequestMapping`等。

在定义业务逻辑处理器时，需要考虑以下几个方面：

- URL映射：可以使用`@RequestMapping`注解来定义URL映射关系，例如`@RequestMapping("/users")`表示将处理以`/users`开头的所有URL请求。
- 请求方法：可以使用`@RequestMapping`注解的`method`属性来定义支持的请求方法，例如`@RequestMapping(value = "/users", method = RequestMethod.GET)`表示只处理GET请求。
- 请求参数：可以使用`@RequestParam`注解来获取请求参数，例如`@RequestParam("name") String name`表示获取名为`name`的请求参数。
- 请求体：可以使用`@RequestBody`注解来获取请求体（JSON或XML格式的数据），例如`@RequestBody User user`表示将请求体转换为`User`对象。
- 响应类型：可以使用`@ResponseBody`注解来定义响应类型，例如`@ResponseBody List<User> getUsers()`表示返回JSON格式的`List<User>`对象。
- 异常处理：可以使用`@ExceptionHandler`注解来定义异常处理方法，例如`@ExceptionHandler(Exception.class) public void handleException(Exception e)`表示处理所有类型的异常。

```java
@Controller
@RequestMapping("/users")
public class UserController {
    @Autowired
    private UserService userService;
    @GetMapping("/{id}")
    
    @ResponseBody
public User getUserById(@PathVariable Long id) {
    return userService.getUserById(id);
}

@PostMapping
@ResponseStatus(HttpStatus.CREATED)
@ResponseBody
public User createUser(@RequestBody User user) {
    return userService.createUser(user);
}

@PutMapping("/{id}")
@ResponseBody
public User updateUser(@PathVariable Long id, @RequestBody User user) {
    return userService.updateUser(id, user);
}

@DeleteMapping("/{id}")
@ResponseStatus(HttpStatus.NO_CONTENT)
public void deleteUser(@PathVariable Long id) {
    userService.deleteUser(id);
}
```

在这个示例中，`@Controller`注解用于定义业务逻辑处理器，`@RequestMapping("/users")`注解表示所有的请求都需要以`/users`开头。

`@Autowired`注解用于注入`UserService`对象，`@GetMapping("/{id}")`注解表示处理GET请求并且URL中包含一个`id`参数。

`@ResponseBody`注解表示返回类型是一个JSON格式的对象，`@PostMapping`注解表示处理POST请求，`@ResponseStatus(HttpStatus.CREATED)`注解表示返回状态码为201，表示创建成功。

`@PutMapping("/{id}")`注解表示处理PUT请求并且URL中包含一个`id`参数，`@DeleteMapping("/{id}")`注解表示处理DELETE请求并且URL中包含一个`id`参数。

## 5.3.定义业务逻辑服务（Service）

业务逻辑服务通常是**一个Java接口和一个实现类，用于处理业务逻辑和调用数据访问层**。可以使用Java注解来定义业务逻辑服务，例如`@Service`、`@Transactional`等。

在定义业务逻辑服务时，需要考虑以下几个方面：

- 业务逻辑处理：业务逻辑服务需要处理具体的业务逻辑，例如查询用户、创建用户、更新用户、删除用户等。
- 事务管理：可以使用`@Transactional`注解来定义事务管理，例如`@Transactional(rollbackFor = Exception.class)`表示在发生异常时进行回滚操作。
- 数据访问层调用：可以使用`@Autowired`注解来注入数据访问层对象，例如`@Autowired private UserRepository userRepository`表示注入`UserRepository`对象。

```
实现service接口用到的注解
	@Service
	@Autowired 用来注入mapper
```

例如，以下是一个简单的业务逻辑服务定义示例：

```java
@Service
@Transactional
public class UserServiceImpl implements UserService {
    @Autowired
    private UserRepository userRepository;
    
    @Override
    public User getUserById(Long id) {
        return userRepository.findById(id).orElse(null);
    }
    
    @Override
    public User createUser(User user) {
        return userRepository.save(user);
    }
    
    @Override
    public User updateUser(Long id, User user) {
        User existingUser = userRepository.findById(id).orElse(null);
        if (existingUser != null) {
            existingUser.setName(user.getName());
            existingUser.setAge(user.getAge());
            return userRepository.save(existingUser);
        }
        return null;
    }
    
    @Override
    public void deleteUser(Long id) {
        userRepository.deleteById(id);
    }
}
```

## 5.4.定义数据访问层（DAO、Mapper）

数据访问层通常是**一个Java接口和一个实现类，用于访问数据库并执行CRUD操作**。可以使用Java注解来定义数据访问层，例如`@Repository`、`@Transactional`等。

在定义数据访问层时，需要考虑以下几个方面：

- 实体映射：需要将Java对象映射到数据库表中的行。
- 数据访问方法：需要定义数据访问方法，例如查询用户、创建用户、更新用户、删除用户等。可以使用Spring Data JPA提供的方法命名规则来定义数据访问方法，也可以使用`@Query`注解来定义自定义的数据访问方法。
- 事务管理：可以使用`@Transactional`注解来定义事务管理，例如`@Transactional(rollbackFor = Exception.class)`表示在发生异常时进行回滚操作。

```
定义mapper接口用到的注解
    @Mapper
    @Repository
```

## 5.5.配置数据源和事务管理器

```java
@Configuration
@EnableTransactionManagement
public class AppConfig {
    @Bean
    public DataSource dataSource() {
        // 配置数据源
        DriverManagerDataSource dataSource = new DriverManagerDataSource();
        dataSource.setDriverClassName("com.mysql.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql://localhost:3306/test");
        dataSource.setUsername("root");
        dataSource.setPassword("password");
        return dataSource;
    }
    
    @Bean
    public PlatformTransactionManager transactionManager() {
        // 配置事务管理器
        JpaTransactionManager transactionManager = new JpaTransactionManager();
        transactionManager.setEntityManagerFactory(entityManagerFactory().getObject());
        return transactionManager;
    }
    
    @Bean
    public LocalContainerEntityManagerFactoryBean entityManagerFactory() {
        // 配置实体管理器工厂
        LocalContainerEntityManagerFactoryBean entityManagerFactory = new LocalContainerEntityManagerFactoryBean();
        entityManagerFactory.setDataSource(dataSource());
        entityManagerFactory.setPackagesToScan("com.example.demo.entity");
        entityManagerFactory.setJpaVendorAdapter(new HibernateJpaVendorAdapter());
        entityManagerFactory.setJpaProperties(jpaProperties());
        return entityManagerFactory;
    }
    
    private Properties jpaProperties() {
        // 配置JPA属性
        Properties properties = new Properties();
        properties.setProperty("hibernate.dialect", "org.hibernate.dialect.MySQL5Dialect");
        properties.setProperty("hibernate.hbm2ddl.auto", "update");
        properties.setProperty("hibernate.show_sql", "true");
        return properties;
    }
}
```

@Configuration`注解用于定义配置类，`@EnableTransactionManagement用于启用Spring的事务管理功能。

`dataSource()`方法用于配置数据源，这里使用了一个基于JDBC的数据源`DriverManagerDataSource`，并设置了数据库连接信息。`transactionManager()`方法用于配置事务管理器，这里使用了一个基于JPA的事务管理器`JpaTransactionManager`，并设置了实体管理器工厂。

`entityManagerFactory()`方法用于配置实体管理器工厂，这里使用了一个基于JPA的实体管理器工厂`LocalContainerEntityManagerFactoryBean`，并设置了数据源、实体扫描包、JPA供应商适配器和JPA属性。`jpaProperties()`方法用于设置JPA属性，这里设置了数据库方言、DDL自动更新和SQL输出等。

## 5.6.编写业务逻辑代码

编写业务逻辑代码通常需要调用数据访问层来访问数据库，并处理业务逻辑。可以使用`@Autowired`注解来自动装配数据访问层。

```java
@Service
public class UserServiceImpl implements UserService {
    @Autowired
    private UserRepository userRepository;
    
    @Override
    public User getUserById(Long id) {
        return userRepository.findById(id).orElse(null);
    }
    
    @Override
    public User createUser(User user) {
        return userRepository.save(user);
    }
    
    @Override
    public User updateUser(User user) {
        return userRepository.save(user);
    }
    
    @Override
    public void deleteUserById(Long id) {
        userRepository.deleteById(id);
    }
}
```

在这个示例中，`@Service`注解用于定义业务逻辑层，`UserRepository`是数据访问层接口，使用`@Autowired`注解自动装配数据访问层。`getUserById()`方法用于查询用户信息，`createUser()`方法用于创建用户，`updateUser()`方法用于更新用户，`deleteUserById()`方法用于删除用户

## 5.7.编写控制器代码

控制器通常处理HTTP请求，并调用业务逻辑层来处理业务逻辑。可以使用`@Autowired`注解来自动装配业务逻辑层。

```java
@RestController
@RequestMapping("/users")
public class UserController {
    @Autowired
    private UserService userService;
    
    @GetMapping("/{id}")
    public User getUserById(@PathVariable Long id) {
        return userService.getUserById(id);
    }
    
    @PostMapping("/")
    public User createUser(@RequestBody User user) {
        return userService.createUser(user);
    }
    
    @PutMapping("/")
    public User updateUser(@RequestBody User user) {
        return userService.updateUser(user);
    }
    
    @DeleteMapping("/{id}")
    public void deleteUserById(@PathVariable Long id) {
        userService.deleteUserById(id);
    }
}
```

在这个示例中，`@RestController`注解用于定义控制器类，`@RequestMapping("/users")`注解用于指定URL映射。`userService`是业务逻辑层接口，使用`@Autowired`注解自动装配业务逻辑层。`getUserById()`方法用于处理GET请求，查询用户信息，`createUser()`方法用于处理POST请求，创建用户，`updateUser()`方法用于处理PUT请求，更新用户，`deleteUserById()`方法用于处理DELETE请求，删除用户

## 5.8.配置Web应用程序上下文

Web应用程序上下文是一个Web应用程序的核心配置文件，它通常包含了所有的配置信息，如控制器、拦截器、视图解析器等。

可以通过继承`WebMvcConfigurer`接口，并重写`addResourceHandlers()`、`addInterceptors()`、`addViewControllers()`和`configureDefaultServletHandling()`等方法来配置Web应用程序上下文。

```java
@Configuration
@EnableWebMvc
@ComponentScan(basePackages = "com.example.demo")
public class WebMvcConfig implements WebMvcConfigurer {
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/static/**").addResourceLocations("classpath:/static/");
    }
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new UserInterceptor()).addPathPatterns("/**").excludePathPatterns("/login");
    }
    
    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        registry.addViewController("/").setViewName("index");
    }
    
    @Override
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
        configurer.enable();
    }
}
```

在这个示例中，`@Configuration`注解用于定义配置类，`@EnableWebMvc`注解用于启用Spring MVC。`addResourceHandlers()`方法用于配置静态资源路径，这里配置了`/static/**`路径映射到`classpath:/static/`路径。`configureViewResolvers()`方法用于配置视图解析器，这里配置了JSP视图解析器，将`/WEB-INF/views/`路径映射到`.jsp`后缀。`addViewControllers()`方法用于配置视图控制器，这里配置了根路径映射到`index.jsp`视图。

## 5.9.编写视图模板

Spring MVC也支持视图模板技术，例如JSP、Thymeleaf、Freemarker等。可以根据具体的需求选择合适的视图模板。

## 5.10.部署和运行应用程序

完成以上步骤后，可以使用Maven来打包应用程序，然后部署到Tomcat等Java应用服务器上，并启动应用服务器来运行应用程序。

## 5.11.实现顺序

编写代码时，往往按照

entity->Controller->Service/ServiceImpl->Dao->Xml

这样的层次来编写业务模块，其他的还会涉及配置模块Config以及工具类Util

# 6.实现网站

先前端设计：页面布局，页面长什么样

设计数据库（难点）

后端设计数据接口，对接 json对象

前后端联通测试

# 7.基于Spring Boot的在线售票系统的架构

1. 数据库层：在线售票系统需要与数据库进行交互，因此需要考虑数据库的设计和管理。可以选择使用关系型数据库（如MySQL、Oracle等）或非关系型数据库（如MongoDB、Redis等），并根据实际业务需求设计数据表结构。
2. 业务层：在线售票系统需要实现用户注册、登录、查看车票信息、购买车票、支付等业务功能。因此需要规划系统的业务层，包括设计服务接口、实现业务逻辑、处理异常情况等。
3. Web层：在线售票系统需要提供Web界面供用户进行操作，因此需要规划系统的Web层。可以使用Spring MVC框架实现控制层，接收用户请求并调用业务层处理。可以选择使用HTML、CSS、JavaScript等前端技术实现Web界面。
4. 安全层：在线售票系统需要考虑安全性问题，包括用户信息的保护、支付信息的安全等。因此需要规划系统的安全层，采用HTTPS协议、SSL证书等技术进行安全保护，防止信息泄露、篡改等问题。
5. 缓存层：在线售票系统需要处理大量的数据请求，因此需要规划系统的缓存层。可以使用缓存技术（如Redis、Memcached等）来加速数据读取，提高系统响应速度。
6. 日志层：在线售票系统需要记录系统操作日志、异常日志等信息，以便进行系统监控和排错。因此需要规划系统的日志层，采用日志管理技术（如Log4j、Slf4j等）进行日志记录和管理。
7. 消息层：在线售票系统需要处理用户的消息通知、订单状态更新等问题，因此需要规划系统的消息层。可以使用消息队列（如RabbitMQ、Kafka等）进行消息传递和处理。
8. 部署层：在线售票系统需要部署在服务器上进行运行，因此需要规划系统的部署层。可以使用Docker等技术进行容器化部署，从而简化系统部署和管理。