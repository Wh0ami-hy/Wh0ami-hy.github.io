---
layout: post   	
catalog: true 	
tags:
    - MyBatis
---



# Mybatis简介

## MyBatis特性

MyBatis是对JDBC的封装

MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录

MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架

MyBatis支持的数据库类型包括：Oracle、MySQL、SQL Server、DB2

官网：https://mybatis.org/mybatis-3/zh

## 和其它持久化层技术对比

**JDBC**  

- SQL 夹杂在Java代码中耦合度高，导致硬编码内伤  
- 维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见  
- 代码冗长，开发效率低

**Hibernate 和 JPA**

- 内部自动生产的 SQL，不容易做特殊优化  
- 基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。  
- 反射操作太多，导致数据库性能下降

**MyBatis**

- 轻量级，性能出色  
- SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据  
- 开发效率稍逊于HIbernate，但是完全能够接受

# 搭建MyBatis

## 开发环境

IDE：idea 2021

构建工具：maven 3.5.4  

MySQL版本：MySQL 5.7  

MyBatis版本：MyBatis 3.5.7

## 创建maven工程

打包方式：jar

引入依赖

```xml
<dependencies>
	<!-- Mybatis核心 -->
	<dependency>
		<groupId>org.mybatis</groupId>
		<artifactId>mybatis</artifactId>
		<version>3.5.7</version>
	</dependency>
	<!-- junit测试 -->
	<dependency>
		<groupId>junit</groupId>
		<artifactId>junit</artifactId>
		<version>4.12</version>
		<scope>test</scope>
	</dependency>
	<!-- MySQL驱动 -->
	<dependency>
		<groupId>mysql</groupId>
		<artifactId>mysql-connector-java</artifactId>
		<version>5.1.3</version>
	</dependency>
    
    <!-- 为了实现使用注解代替实体Bean的getter and setter等..... -->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>1.18.24</version>
        <scope>provided</scope>
    </dependency>
</dependencies>
```

## 创建MyBatis的核心配置文件

>习惯上命名为`mybatis-config.xml`，这个文件名仅仅只是建议，并非强制要求。将来整合Spring之后，这个配置文件可以省略，操作时可以直接复制、粘贴（了解即可）
>核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息
>核心配置文件存放的位置是src/main/resources目录下

```xml
<?xml version="1.0" encoding="UTF-8" ?>  
<!DOCTYPE configuration  
PUBLIC "-//mybatis.org//DTD Config 3.0//EN"  
"http://mybatis.org/dtd/mybatis-3-config.dtd">  
<configuration>  
	<!--设置连接数据库的环境-->  
	<environments default="development">  
        <!--开发环境的配置-->
		<environment id="development">  
			<transactionManager type="JDBC"/>  
			<dataSource type="POOLED">  
				<property name="driver" value="com.mysql.cj.jdbc.Driver"/>  
				<property name="url" value="jdbc:mysql://localhost:3306/mybatis"/>  
				<property name="username" value="root"/>  
				<property name="password" value="123456"/>  
			</dataSource>  
		</environment>  
        <!--生产环境的配置-->
		<environment id="produce">  
			<transactionManager type="JDBC"/>  
			<dataSource type="POOLED">  
				<property name="driver" value="com.mysql.cj.jdbc.Driver"/>  
				<property name="url" value="jdbc:mysql://localhost:3306/mybatis"/>  
				<property name="username" value="root"/>  
				<property name="password" value="123456"/>  
			</dataSource>  
		</environment>  
	</environments>  
	<!--引入映射文件-->  
	<mappers>  
		<mapper resource="mappers/UserMapper.xml"/>  
	</mappers>  
</configuration>
```

## 创建mapper接口

>MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要提供实现类

```java
package com.offcn.mybatis.mapper;  
  
public interface UserMapper {  
	/**  
	* 添加用户信息  
	*/  
	int insertUser();  
}
```

## 创建MyBatis的映射文件

**相关概念**：ORM（Object Relationship Mapping）对象关系映射。  

- 对象：Java的实体类对象  
- 关系：关系型数据库  
- 映射：二者之间的对应关系

| Java概念 | 数据库概念 |
| -------- | ---------- |
| 类       | 表         |
| 属性     | 字段/列    |
| 对象     | 记录/行    |

**映射文件的命名规则**

- 表所对应的实体类的类名+Mapper.xml
- 例如：表user，映射的实体类为User，所对应的映射文件为UserMapper.xml 
- 因此一个映射文件对应一个实体类，对应一张表的操作
- MyBatis映射文件用于编写SQL，访问以及操作表中的数据
- MyBatis映射文件存放的位置目录必须和接口所在包一毛一样。  接口: com.qf.mapper.UserMapper.java ，目录: com/qf/mapper/UserMapper.xml

**MyBatis中可以面向接口操作数据，要保证两个一致**

- mapper接口的全类名和映射文件的命名空间（namespace）保持一致
- mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致

**配置xml模板参考**

```xml
<?xml version="1.0" encoding="UTF-8" ?>  
<!DOCTYPE mapper  
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">  

<mapper namespace="com.qf.mapper.UserMapper">
    <!--id表示接口当中定义的方法. resultType,表示数据库查询的结果.-->
    <select id="findAll" resultType="com.qf.entity.Student">
        select * from student;
    </select>
</mapper>
```

## 通过junit测试功能

- SqlSession：代表Java程序和数据库之间的会话。（HttpSession是Java程序和浏览器之间的会话）
- SqlSessionFactory：是生产SqlSession的工厂
- 工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个工厂”中，以后都使用这个工厂类来生产我们需要的对象

```java
public class UserMapperTest {
 @Test
    public void findAllTest() throws IOException {
        // 1. 加载mybatis-config.xml文件.
        InputStream is = Resources.getResourceAsStream("mybatis-config.xml");

        // 2. 创建SqlSessionFactoryBuilder对象.
        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();

        // 3. 通过sqlSessionFactoryBuilder, 创建SqlSessionFactory的对象.
        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);

        // 4. 创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交
        SqlSession sqlSession = sqlSessionFactory.openSession(true);

        // 5. 获取IUserMapper的对象，通过代理模式创建UserMapper接口的代理实现类对象
        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);

        // 6. 调用方法.
        List<Student> students = userMapper.findAll();

        // 7. 处理查询结果, 根据自己的来务来处理即可;
        students.stream().limit(10).forEach(System.out::println);

        // 8. 释放资源
        sqlSession.close();
        is.close();
    }
}
```

如果要自动提交事务，则在获取sqlSession对象时，使用`SqlSession sqlSession = sqlSessionFactory.openSession(true);`，传入一个Boolean类型的参数，值为true，这样就可以自动提交

否则，需要使用commit()手动提交

## 加入log4j日志功能

加入依赖

```xml
<!-- log4j日志 -->
<dependency>
<groupId>log4j</groupId>
<artifactId>log4j</artifactId>
<version>1.2.17</version>
</dependency>
```

在mybatis-config.xml中加入设置

```xml
<settings>
    <setting name="logImpl" value="LOG4J" />
</settings>
```

加入log4j的配置文件

- log4j的配置文件名为log4j.xml，存放的位置是src/main/resources目录下
- 日志的级别：FATAL(致命)>ERROR(错误)>WARN(警告)>INFO(信息)>DEBUG(调试) 从左到右打印的内容越来越详细

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd">
<log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/">
    <appender name="STDOUT" class="org.apache.log4j.ConsoleAppender">
        <param name="Encoding" value="UTF-8" />
        <layout class="org.apache.log4j.PatternLayout">
			<param name="ConversionPattern" value="%-5p %d{MM-dd HH:mm:ss,SSS} %m (%F:%L) \n" />
        </layout>
    </appender>
    <logger name="java.sql">
        <level value="debug" />
    </logger>
    <logger name="org.apache.ibatis">
        <level value="info" />
    </logger>
    <root>
        <level value="debug" />
        <appender-ref ref="STDOUT" />
    </root>
</log4j:configuration>
```

简单使用

```java
日志对象，参数为当前类的class
static Logger logger=Logger.getLogger(当前所在类.class);
日志级别
    info、debug、error
```



# 核心配置文件详解（重点）

>核心配置文件中的标签必须按照固定的顺序（有的标签可以不写，但顺序一定不能乱）：
>properties、settings、typeAliases、typeHandlers、objectFactory、objectWrapperFactory、reflectorFactory、plugins、environments、databaseIdProvider、mappers
>
>重点配置有：properties、settings、typeAliases、environments、mappers
>
>Mybatis默认的事务管理器就是JDBC。连接池：POOLED

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//MyBatis.org//DTD Config 3.0//EN"
        "http://MyBatis.org/dtd/MyBatis-3-config.dtd">
<configuration>
    <!--引入properties文件，此时就可以${属性名}的方式访问属性值-->
    <properties resource="jdbc.properties"></properties>
    <settings>
        <!--将表中字段的下划线自动转换为驼峰-->
        <setting name="mapUnderscoreToCamelCase" value="true"/>
        <!--开启延迟加载-->
        <setting name="lazyLoadingEnabled" value="true"/>
    </settings>
    <typeAliases>
        <package name="com.offcn.mybatis.bean"/>
    </typeAliases>
    <environments default="mysql_test">
        <environment id="mysql_test">
            <!--
            transactionManager：设置事务管理方式
            属性：
	            type：设置事务管理方式，type="JDBC|MANAGED"
	            type="JDBC"：设置当前环境的事务管理都必须手动处理
	            type="MANAGED"：设置事务被管理，例如spring中的AOP
            -->
            <transactionManager type="JDBC"/>
            <!--
            dataSource：设置数据源
            属性：
	            type：设置数据源的类型，type="POOLED|UNPOOLED|JNDI"
	            type="POOLED"：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建
            -->
            <dataSource type="POOLED">
                <!--设置驱动类的全类名-->
                <property name="driver" value="${jdbc.driver}"/>
                <!--设置连接数据库的连接地址-->
                <property name="url" value="${jdbc.url}"/>
                <!--设置连接数据库的用户名-->
                <property name="username" value="${jdbc.username}"/>
                <!--设置连接数据库的密码-->
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>
    </environments>
    <!--引入映射文件-->
    <mappers>
        <!-- <mapper resource="UserMapper.xml"/> -->
        <!--
        以包为单位，将包下所有的映射文件引入核心配置文件
        注意：
			1. 此方式必须保证mapper接口和mapper映射文件必须在相同的包下
			2. mapper接口要和mapper映射文件的名字一致
        -->
        <package name="com.offcn.mybatis.mapper"/>
    </mappers>
</configuration>
```

## 动态配置属性值

```xml
<!-- 
	引入db.properties文件，此时可用 ${属性名} 的方式访问属性值
-->
    <properties resource="jdbc.properties"></properties>
如
    <property name="driver" value="${jdbc.driver}"/>
```

## 设置多个数据库环境

```xml
<!-- 
		   environments：设置多个连接数据库的环境
            default：设置默认使用的环境的id
            environment：设置具体的连接数据库的环境信息
            id：设置环境的唯一标识
-->
如
<environments default="mysql_test">
        <environment id="mysql_test">
```

## 设置数据源

```xml
 <!--
            dataSource：设置数据源
	        type：设置数据源的类型，type="POOLED|UNPOOLED|JNDI"
	        type="POOLED"：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建
 -->
如
<dataSource type="POOLED">
    <!--设置驱动类的全类名-->
    <property name="driver" value="${jdbc.driver}"/>
    <!--设置连接数据库的连接地址-->
    <property name="url" value="${jdbc.url}"/>
    <!--设置连接数据库的用户名-->
    <property name="username" value="${jdbc.username}"/>
    <!--设置连接数据库的密码-->
    <property name="password" value="${jdbc.password}"/>
</dataSource>
```

## 类型别名

```xml
 <!--   
        typeAlias：给类起别名
        type：需要设置别名的类的全类名
        alias：设置的别名，且别名不区分大小写。若不设置此属性，该类型拥有默认的别名，即类名
-->
如
<typeAliases>
    <typeAlias alias="Author" type= "com.hy.Author"/>
</typeAliases>

<!--以包为单位，设置该包下所有的类都拥有默认的别名，即类名，且不区分大小写-->
如
<package name="com.hy.entity"/>
```

## 引入映射文件

```xml
<!-- 引入单个映射文件
	<mapper resource="UserMapper.xml"/> 
		或
	<mapper class="com.hy.UserMapper"/>  注解和xml可同时生效
-->
如
<mapper resource="UserMapper.xml"/> 

<!--
     以包为单位，将包下所有的映射文件引入核心配置文件
   注意：
   MyBatis映射文件存放的位置目录必须和接口所在包一毛一样
   mapper接口要和mapper映射文件的名字一致
   接口: com.qf.mapper.UserMapper.java 
   目录: com/qf/mapper/UserMapper.xml
-->
如：
<mappers>
    <package name="com.hy.mapper"/>
</mappers>
```

## 设置

```xml
<settings>
    <!--
	可以在查询表中数据时，自动将_类型的字段名转换为驼峰，例如：字段名user_name，此时字段名就会转换为userName
	-->
    <setting name="mapUnderscoreToCamelCase" value="true"/>
    <!--开启延迟加载-->
    <setting name="lazyLoadingEnabled" value="true"/>
</settings>
```

## 生命周期

生命周期和作用域，是至关重要的，因为错误的使用会导致非常严重的并发问题。

**SqlSessionFactoryBuilder**

**SqlSessionFactory**

**SqISession**

# MyBatis的CRUD

**查询**

```xml
<!--List<User> getUserList();-->
<select id="getUserList" resultType="com.offcn.mybatis.bean.User">
	select * from t_user
</select>
```

注意：

查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射关系  
```
resultType：自动映射，用于实体类的属性名和表中字段名一致的情况  
resultMap：自定义映射，用于一对多、多对一、字段名和属性名不一致的情况  
```

parameterType：需要传的参数的类型

**查询结果的映射**

如果查询出的数据只有一条，可以通过

1. 实体类对象接收
2. List集合接收
3. Map集合接收，结果`{password=123456, sex=男, id=1, age=23, username=admin}`

如果查询出的数据有多条，一定不能用实体类对象接收，会抛异常TooManyResultsException，可以通过

1. 实体类类型的LIst集合接收
2. Map类型的LIst集合接收
3. 在mapper接口的方法上添加@MapKey注解

## 模糊查询

**重点：ongl表达式，使用的#{}方式**

```
模糊查询,可以使用三种姿势:
concat函数拼接%
手动去传%%
${}, 慎用
如
select * from t_user where username like concat('%',#{mohu},'%') 
select * from t_user where username like '%${mohu}%'
select * from t_user where username like "%"#{mohu}"%"
```

## MyBatis获取参数值的两种方式（重点）

```
${}：静态sql，本质就是字符串拼接，有sql注入风险，不会自动添加单引号

#{}：预编译sql，本质就是占位符赋值，用？占位，会自动添加单引号
```

```xml
<!--User getUserByUsername(String username);-->
<select id="getUserByUsername" resultType="User">
	select * from t_user where username = #{username}
</select>
```

```xml
<!--User getUserByUsername(String username);-->
<select id="getUserByUsername" resultType="User">  
	select * from t_user where username = '${username}'  
</select>
```

## Mapper接口中方法的参数问题（重点）

**单个参数**

若mapper接口中的方法参数为单个时，可以使用`${}、#{}`获取参数的值，注意`${}`需要手动加单引号

**多个参数**

若mapper接口中的方法参数为多个时，此时MyBatis会自动将这些参数放在一个map集合中

```
以arg0,arg1...为键，以参数为值
或
以param1,param2...为键，以参数为值
```

可以使用`${}、#{}`访问map集合的键就可以获取相对应的值，注意`${}`需要手动加单引号

使用arg或者param都行，要注意的是，arg是从arg0开始的，param是从param1开始的

```xml
<!--User checkLogin(String username,String password);-->
<select id="checkLogin" resultType="User">  
	select * from t_user where username = #{arg0} and password = #{arg1}  
</select>
```

```xml
<!--User checkLogin(String username,String password);-->
<select id="checkLogin" resultType="User">
	select * from t_user where username = '${param1}' and password = '${param2}'
</select>
```

**map集合类型的参数（实际使用较多）**

若mapper接口中的方法需要的参数较多时，此时可以手动创建map集合，将这些数据封装在map中，可以使用`${}、#{}`访问map集合的键就可以获取相对应的值，注意`${}`需要手动加单引号

```xml
<!--定义的接口方法 checkLoginByMap(Map<String,Object> map);-->
<select id="checkLoginByMap" resultType="User" parameterType="map">
	select * from t_user where username = #{username} and password = #{password}
</select>
```

```java
@Test
public void checkLoginByMap() {
	SqlSession sqlSession = SqlSessionUtils.getSqlSession();
	ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class);
	Map<String,Object> map = new HashMap<>();
	map.put("usermane","admin");
	map.put("password","123456");
	User user = mapper.checkLoginByMap(map);
	System.out.println(user);
}
```

**实体类类型的参数**

若mapper接口中的方法参数为实体类对象，可以使用`${}、#{}`，通过访问实体类对象中的属性名获取属性值，注意`${}`需要手动加单引号

```xml
<!--int insertUser(User user);-->
<insert id="insertUser">
	insert into t_user values(null,#{username},#{password},#{age},#{sex},#{email})
</insert>
```

```java
@Test
public void insertUser() {
	SqlSession sqlSession = SqlSessionUtils.getSqlSession();
	ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class);
	User user = new User(null,"Tom","123456",12,"男","123@321.com");
	mapper.insertUser(user);
}
```

**使用@Param标识参数（重点）**

可以通过@Param注解标识mapper接口中的方法参数，此时会将这些参数放在map集合中，以@Param注解的value属性值为键，以参数为值

可以使用`${}、#{}`访问map集合的键就可以获取相对应的值，注意`${}`需要手动加单引号

```xml
<!--定义接口方法 CheckLoginByParam(@Param("name") String username, @Param("pwd") String password);-->
<!--如果当前参数不添加@Param('名称')，则mybatis默认是以arg0, args1.....或者param0,param1为参数-->
    <select id="CheckLoginByParam" resultType="User">
        select * from t_user where username = #{name} and password = #{pwd}
    </select>
```

```java
@Test
public void checkLoginByParam() {
	SqlSession sqlSession = SqlSessionUtils.getSqlSession();
	ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class);
	mapper.CheckLoginByParam("admin","123456");
}
```

## 总结

建议分成两种情况进行处理

```
1. 实体类类型的参数
2. 使用@Param标识参数
```

# resultMap处理数据库字段与实体类属性不匹配（重点）

```xml
<!-- resultMap 结果集映射
	 id：表示自定义映射的唯一标识，不能重复
	 type：查询的数据要映射的实体类的类型  
-->
<resultMap id="empResultMap" type="Emp">
    <!--column数据库中的字段，property实体类中的属性-->
	<result property="id" column="eid"></result>
	<result property="pwd" column="password"></result>
</resultMap>
<!--select标签中 resultMap属性的值为前面 resultMap标签的id的值-->
<select id="getAllEmp" resultMap="empResultMap">
	select * from t_emp;
</select>
```

若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_分割），实体类中的属性名符合Java的规则（使用驼峰）。此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系  

```xml
1. 可以通过为字段起别名的方式，保证和实体类中的属性名保持一致  
	<!--List<Emp> getAllEmp();-->
	<select id="getAllEmp" resultType="Emp">
		select eid,emp_name empName,age,sex,email from t_emp
	</select>
2. 引入设置
 <setting name="mapUnderscoreToCamelCase" value="true"/>
```

# 多对一映射处理

查询学生信息以及学生所对应的老师信息

思路：查询所有学生信息，再根据查出来的学生的tid，寻找对应老师

常规sql

```sql
select * from student as s,teacher as t where s.tid=t.id
```

学生实体

```java
public class Student {
    private String name;
    private int id;
    // 学生关联一个老师
    private Teacher teacher;
}
```

## 按查询嵌套处理

相当于MySQL中子查询

```xml
- association：处理多对一的映射关系
- property：需要处理多对一的映射关系的属性名
- javaType：该属性的类型
<select id="getStudent" resultMap="StudentTeacher">
	select * from student;
</select>
<resultMap id="StudentTeacher" type="Student">
	<result property="id" column="id"></result>
	<result property="name" column="name"></result>
    <!--单独处理：嵌套子查询-->
	<association property="teacher" column="tid" javaType="Teacher" select="getTeacherById"/>
</resultMap>
<select id="getTeacherById" resultType="Teacher">
	select * from teacher where id = #{tid}
</select>
```

## 按结果嵌套处理

相当于MySQL中联表查询

```xml
- association：处理多对一的映射关系
- property：需要处理多对一的映射关系的属性名
- javaType：该属性的类型
<select id="getStudent" resultMap="StudentTeacher">
    select s.id as sid,s.name as sname,t.id as tid,t.name as tname 
    from student as s,teacher as t 
    where s.tid=t.id;
</select>
<resultMap id="StudentTeacher" type="Student">
	<result property="id" column="sid"></result>
	<result property="name" column="sname"></result>
    <!--复杂属性，单独处理-->
	<association property="teacher" javaType="Teacher">
        <result property="id" column="tid"/>
        <result property="name" column="tname"/>
    </association>
</resultMap>
```

# 一对多映射处理

查询老师信息以及老师所对应的学生信息

思路：查询老师信息，再根据查出来的老师的id，寻找对应的学生

常规sql

```sql
select s.id as sid,s.name as sname,t.name as tname,t.id as tid 
from student as s,teacher as t
where s.tid = t.id and t.id = #{tid};
```

老师实体

```java
public class Teacher {
    private int id;
    private String name;
	// 一个老师关联多个学生
    private List<Student> students;
}
```

## 按查询嵌套处理

```xml
- collection：用来处理一对多的映射关系
- ofType：表示该属性对应的集合中存储的数据的类型
<select id="getTeacher" resultMap="TeacherStudent">
    select * from teacher where id=#{tid};
</select>
<resultMap id="TeacherStudent" type="Teacher">
    <result property="id" column="id"></result>
    <result property="name" column="name"></result>
    <!--单独处理：嵌套子查询-->
    <collection property="students" javaType="ArrayList" ofType="Student" select="getTeacherById" column="id">
    </collection>
</resultMap>
<select id="getTeacherById" resultType="Student">
    select * from student where tid=#{tid};
</select>
```

## 按结果嵌套处理

```xml
- collection：用来处理一对多的映射关系
- ofType：表示该属性对应的集合中存储的数据的类型
<select id="getTeacher" resultMap="TeacherStudent">
    select s.id as sid,s.name as sname,t.name as tname,t.id as tid
    from student as s,teacher as t
    where s.tid = t.id and t.id = #{tid};
</select>
<resultMap id="TeacherStudent" type="Teacher">
    <result property="id" column="id"></result>
    <result property="name" column="tname"></result>
    <!--复杂属性，单独处理-->
    <collection property="students" ofType="Student">
        <result property="id" column="sid"></result>
        <result property="name" column="sname"></result>
        <result property="tid" column="tid"></result>
    </collection>
</resultMap>
```



# 延迟加载

先思考一个问题，假设：在一对多中，我们有一个用户，他有100个账户。

　　问题1：在查询用户的时候，要不要把关联的账户查出来？

　　问题2：在查询账户的时候，要不要把关联的用户查出来？

　　解答：在查询用户的时候，用户下的账户信息应该是我们什么时候使用，什么时候去查询。

　　　　　在查询账户的时候，账户的所属用户信息应该是随着账户查询时一起查询出来。

　　**延迟加载**：在真正使用数据的时候才发起查询，不用的时候不查询关联的数据，延迟加载又叫按需查询（懒加载）

　　**立即加载**：不管用不用，只要一调用方法，马上发起查询

　　**使用场景**：在对应的四种表关系中，一对多、多对多通常情况下采用延迟加载，多对一、一对一通常情况下采用立即加载

lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载  

```xml
<settings>
	<!--开启延迟加载-->
	<setting name="lazyLoadingEnabled" value="true"/>
</settings>
```

此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。此时可通过association和collection中的fetchType属性设置当前的分步查询是否使用延迟加载，`fetchType="lazy(延迟加载)|eager(立即加载)"`

# 分页

## limit实现

```sql
List<User> getUserByLimit(Map<String,Integer> map);

select * from user limit #{startIndex},#{pageSize};
```

## 分页插件

pagehelper

**添加依赖**

```xml
<!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper -->
<dependency>
	<groupId>com.github.pagehelper</groupId>
	<artifactId>pagehelper</artifactId>
	<version>5.2.0</version>
</dependency>
```

**配置分页插件**

MyBatis的核心配置文件（mybatis-config.xml）中配置插件

```xml
<plugins>
	<!--设置分页插件-->
	<plugin interceptor="com.github.pagehelper.PageInterceptor"></plugin>
</plugins>
```

**开启分页功能**

在查询功能之前使用`PageHelper.startPage(int pageNum, int pageSize)`开启分页功能

- pageNum：当前页的页码  
- pageSize：每页显示的条数

注意：编写sql语句的时候不要在后面加入分号，因为sql语句后面要拼接limit分页语句

错误写法：select * from t_emp；limit 0, 3

正确写法：select * from t_emp limit 0, 3

```java
@Test
public void testPageHelper() throws IOException {
	InputStream is = Resources.getResourceAsStream("mybatis-config.xml");
	SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();
	SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);
	SqlSession sqlSession = sqlSessionFactory.openSession(true);
	EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
	//访问第一页，每页四条数据
	PageHelper.startPage(1,4);
	List<Emp> emps = mapper.selectByExample(null);
	emps.forEach(System.out::println);
}
```

**分页相关数据**

方法一：直接输出

```java
@Test
public void testPageHelper() throws IOException {
	InputStream is = Resources.getResourceAsStream("mybatis-config.xml");
	SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();
	SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);
	SqlSession sqlSession = sqlSessionFactory.openSession(true);
	EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
	//访问第一页，每页四条数据
	Page<Object> page = PageHelper.startPage(1, 4);
	List<Emp> emps = mapper.selectByExample(null);
	//在查询到List集合后，打印分页数据
	System.out.println(page);
}
```

方法二：使用PageInfo

在查询获取list集合之后，使用`PageInfo<T> pageInfo = new PageInfo<>(List<T> list, int navigatePages)`获取分页相关数据
- list：分页之后的数据  
- navigatePages：导航分页的页码数   

```java
@Test
public void testPageHelper() throws IOException {
	InputStream is = Resources.getResourceAsStream("mybatis-config.xml");
	SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();
	SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);
	SqlSession sqlSession = sqlSessionFactory.openSession(true);
	EmpMapper mapper = sqlSession.getMapper(EmpMapper.class);
	PageHelper.startPage(1, 4);
	List<Emp> emps = mapper.selectByExample(null);
	PageInfo<Emp> page = new PageInfo<>(emps,5);
	System.out.println(page);
}
```

常用数据：

- pageNum：当前页的页码  
- pageSize：每页显示的条数  
- size：当前页显示的真实条数  
- total：总记录数  
- pages：总页数  
- prePage：上一页的页码  
- nextPage：下一页的页码
- isFirstPage/isLastPage：是否为第一页/最后一页  
- hasPreviousPage/hasNextPage：是否存在上一页/下一页  
- navigatePages：导航分页的页码数  
- navigatepageNums：导航分页的页码，\[1,2,3,4,5]



# 使用注解CRUD

注解在接口上实现

```java
@Select("select * from user")
List<User> getUsers();
```

在mybatis-config.xml中绑定接口

```xml
<mappers>
    <mapper resource="com/hy/mapper/UserMapper.xml"/>
</mappers>
```

本质：反射机制

底层：动态代理

# Lombok的使用

可以实现使用注解代替实体Bean的getter and setter等，不推荐使用

安装 lombok插件 

添加依赖

```XML
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.24</version>
    <scope>provided</scope>
</dependency>
```

提供的注解

```
@Getter and @Setter
@ToString
@EqualsAndHashCode
@AllArgsConstructor
@RequiredArgsConstructor
@NoArgsConstructor
@Log4j
@Data
```

# 主键回填（重要）

在添加完数据之后，需要获取刚刚添加的数据 id

一般情况下，主键有两种生成方式：

1. 主键自增长
2. 自定义主键（一般可以使用UUID，或者类UUID）

如果是第二种，主键一般是在Java代码中生成，然后传入数据库执行插入操作，如果是第一个主键自增长，此时，Java 可能需要知道数据添加成功后的主键。

**JDBC的实现**

```java
// 构造PreparedStatement时添加一个参数：PreparedStatement.RETURN_GENERATED_KEYS
ps = con.prepareStatement("INSERT INTO person(username,password,money) VALUES(?,?,?)", PreparedStatement.RETURN_GENERATED_KEYS);
ps.setObject(1, person.getUsername());
int i = ps.executeUpdate();
// 在更新操作执行完成之后，调用 getGeneratedKeys ，然后又会获取到一个 ResultSet 对象，从这个游标集中就可以获取到刚刚插入数据的id。
rs = ps.getGeneratedKeys();
int id = -1;
if (rs.next()) {
    id = rs.getInt(1);
}
return id;
}
```

**MyBatis的实现**

推荐

```xml
<!--
在插入节点上添加 useGeneratedKeys 属性，同时设置接收回传主键的属性keyProperty。配置完成后，我们执行一个插入操作，插入时传入一个对象，插入完成后，这个对象的 id 就会被自动赋值，值就是刚刚插入成功的id。
-->
<insert id="insertBook" useGeneratedKeys="true" keyProperty="id">
    insert into book (name,author) values (#{name},#{author});
</insert>
```

**MySQL的实现**

利用MySQL自带的 `last_insert_id()`

```xml
<insert id="insertBook">
    <selectKey keyProperty="id" resultType="java.lang.Integer">
        SELECT LAST_INSERT_ID()
    </selectKey>
    insert into t_book (b_name,author) values (#{name},#{author});
</insert>
```

# 连接池替换

用Druid 替换MyBatis默认的连接池

引入Druid依赖，创建 Druid配置类，部署DataSource

# 动态SQL

根据不同的条件生成不同的SQL语句

如 实现查询功能，不给查询条件，则查询所有，给指定查询条件，则根据条件来查询，总之给不给条件都可以实现查询功能

## if

```xml
<!-- List<Blog> queryBlog(Map map) -->
<select id="queryBlogIF" parameterType="map" resultType="blog">
    select * from blog
    <where>
        <if test="title !=null">
            and title=#{title}
        </if>
        <if test="author !=null">
            and author=#{author}
        </if>
    </where>
</select>
```

## choose、when、otherwise

```xml
<!-- List<Blog> queryBlogChoose(Map map) -->
<select id="queryBlogChoose" parameterType="map" resultType="blog">
    select * from blog
    <where>
        <choose>
            <when test="title !=null">
                and title=#{title}
            </when>
            <when test="author !=null">
                and author=#{author}
            </when>
            <otherwise>
                and views = #{views}
            </otherwise>
        </choose>
    </where>
</select>
```

## trim、where、set

**where标签**

插入where子句，若子句的开头为 “AND” 或 “OR”，where 标签也会将它们去除

**set**

set标签会动态前置SET关键字，同时也会删掉无关的逗号

```xml
<!-- int updateBlog(Map map) -->
<update id="updateBlog" parameterType="map">
    update blog
    <set>
        <if test="title !=null">
            title = #{title},
        </if>
        <if test="author !=null">
            author = #{author},
        </if>
    </set>
    where id=#{id}
</update>
```

## SQL片段

使用 sql标签将SQL语句中用到的公共部分的SQL语句抽取出来

```xml
id：唯一标识一个sql标签
<sql id="if-title-author">
    <if test="title !=null">
        title = #{title},
    </if>
    <if test="author !=null">
        author = #{author},
    </if>
</sql>
```

使用 include标签引用

```xml
refid：对应sql片段的唯一标识
<include refid="if-title-author"></include>
```

## foreach

```xml
collection：集合名
item：集合中每个元素的命名
open：以什么开始
close：以什么结束
separator：以什么分割
<foreach collection="ids" item="id" open="and (" close=")" separator="or">
```

# 缓存（了解）

提高查询效率，将用户经常查询的数据放在缓存（内存）中

频繁读，少量写的数据适合放在缓存

频繁写，少量读的数据不适合放在缓存

MyBatis系统中默认定义了两级缓存：一级缓存和二级缓存

默认情况下，只有一级缓存开启（SqlSession级别的缓存， 也称为本地缓存）

二级缓存需要手动开启和配置（namespace级别的缓存，也称为全局缓存）

为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存

## 一级缓存

**缓存失效的情况**

查询不同的内容

增删改操作，可能会改变原来的数据，所以必定会刷新缓存

查询不同Mapper.xml

手动清理缓存 sqlSession.clearCache()

**小结**

一级缓存默认是开启的，只在一次SqISession中有效，也就是从拿到连接到关闭连接这个区间段

## 二级缓存

一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中

如果当前会话关闭了，这个会话对应的一级缓存就没了，但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中，当新的会话查询信息时，就可以从二级缓存中获取内容

**开启全局缓存**

在 mybatis-config.xml 核心配置文件中，显式开启 

```xml
<setting name="cacheEnabled" value="true"/>    
```

在相应的Mapper.xml中使用二级缓存

```xml
<cache
eviction="FIFO"
flushInterval=" 60000"
size="512"
readOnly= "true"/>
```

**小结**

所有的数据都会先放在一级缓存中

只有当会话提交，或者关闭的时候，才会提交到二级缓冲中

## 缓存原理 

缓存顺序
1.先看级缓存中有没有
2.再看一级缓存中有没有
3.查询数据库

## 自定义缓存Ehcache

Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存

引入依赖

```xml
<dependency>
    <groupId>org.mybatis.caches</groupId>
    <artifactId>mybatis-ehcache</artifactId>
    <version>1.1.0</version>
</dependency>
```

使用自定义cache

```xml
<cache type="org.mybatis.caches.ehcache.EhcacheCache"/>
```



























