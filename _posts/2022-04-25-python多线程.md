---
layout: post   	
catalog: true 	
tags:
    - python
---



# 进程

## 概念

资源分配的基本单位

一个运行起来的程序叫进程

程序开始执行时，会默认创建一个主进程

## 实现多进程

### 导入进程包

```python
import multiprocessing
```

### 创建进程对象

```python
进程对象 = multiprocessing.Process(参数)
```

| 参数名 | 说明                                                   |
| ------ | ------------------------------------------------------ |
| target | 执行的目标任务名，应该是一个函数名(函数名后不要加括号) |
| name   | 进程名，一般不用设置                                   |
| group  | 进程组，目前只能使用None                               |

### 启动进程

```
进程对象.start()
```

例

```python
import multiprocessing
import time

def sing():
    for i in range(3):
        print("singing")
        time.sleep(0.5)

def draw():
    for i in range(3):
        print("drawing")
        time.sleep(0.5)

if __name__ == '__main__':
    process1 = multiprocessing.Process(target=sing)
    process2 = multiprocessing.Process(target=draw)

    process1.start()
    process2.start()

    # sing()
    # draw()
```

### 执行带参数的任务

| 参数   | 说明                                               |
| ------ | -------------------------------------------------- |
| args   | 以元组的方式给执行任务传参，参数是按顺序进行对应的 |
| kwargs | 以字典的方式给执行任务传参，参数是按键名进行对应的 |

例

```python
import multiprocessing
import time

def sing(num):
    for i in range(num):
        print("singing")
        time.sleep(0.5)

def draw(num):
    for i in range(num):
        print("drawing")
        time.sleep(0.5)

if __name__ == '__main__':
    process1 = multiprocessing.Process(target=sing,args=(3,))	#使用元组进行传参
    
    process2 = multiprocessing.Process(target=draw,kwargs={"num":3})
    #使用字典进行传参

    process1.start()
    process2.start()

    # sing(3)
    # draw(3)
```



## 获取进程编号

### 获取当前进程编号

```python
os.getpid()
```



### 获取当前父进程编号

```python
os.getppid()
```

## 设置守护主进程

正常状态下，主进程会默认等待所有子进程执行结束再结束

如果希望主进程结束的同时结束所有子进程，就需要设置守护主进程

```python
进程名.daemon = True  #在启动进程前设置
```

例

```python
import multiprocessing

import time

def sing():

    for i in range(10):
        print("singing")
        time.sleep(0.5)


if __name__ == '__main__':
    process1 = multiprocessing.Process(target=sing)

    process1.daemon = True      #设置主进程守护

    process1.start()

    time.sleep(1)

    print("主进程结束")
```

## 阻塞进程

阻塞当前上下文环境的进程程，直到调用此方法的进程终止

```
进程对象.join()
```

## 结束进程

不管任务是否完成，立即停止工作进程

```
进程对象.terminate()
```

但是通过执行系统命令ps查看停止后的进程, 会发现, 直接调用terminate方法停止的进程变成了一个僵尸进程(defunct), 只能等待主程序退出, 这个僵尸进程才会消失.

通过在terminate后添加一次调用join方法等待进程真正结束, 就能避免出现僵尸进程:

```
进程对象.terminate()
进程对象.join()
```

## 实例

实现多进程文件拷贝器

```python
import multiprocessing

import os

def copy(file_name,source_dir,dest_dir):
    source_path = source_dir + '/' + file_name  #拼接源文件路径和
    dest_path = dest_dir + '/' + file_name  #拼接目标文件路径


    with open(source_path,'rb') as source_file:     #打开源文件和目标文件
        with open(dest_path,'wb') as dest_file:

            while True:
                data = source_file.read(1024)
                if data:
                    dest_file.write(data)
                else:
                    break


if __name__ == '__main__':

    source_dir = ''
    dest_dir = ''

    try:
        os.mkdir(dest_dir)     #创建目标文件夹
    except:
        print('目标文件夹已存在')

    file_list = os.listdir(source_dir)

    for file_name in file_list:

        process = multiprocessing.Process(target=copy,args=(file_name,source_dir,dest_dir))

        process.start()

```



# 线程

## 概念

执行程序的最小单元

进程是线程的容器

一个进程中最少有一个线程负责执行程序

它与同属一个进程的其他线程共享进程所拥有的全部资源

## 实现多线程

### 导入线程模块

```python
import threading
```

### 创建线程对象

```python
线程对象 = threading.Thread(target=任务名)
```

| 参数   | 说明                           |
| ------ | ------------------------------ |
| target | 执行的目标任务名，一般是函数名 |
| name   | 线程名                         |
| group  | 线程组，目前只能使用None       |



### 启动线程

```python
线程对象.start()
```



例

```python
import threading
import time
def sing():
    for i in range(5):
        print('sing')
        time.sleep(1)

def dance():
    for i in range(5):
        print('dance')
        time.sleep(1)

if __name__ == '__main__':
    # sing()
    # dance()
    sing_thread = threading.Thread(target=sing)
    dance_thread = threading.Thread(target=dance)
    
    sing_thread.start()
    dance_thread.start()
```

### 线程执行带参数的任务

| 参数   | 说明                                               |
| ------ | -------------------------------------------------- |
| args   | 以元组的方式给执行任务传参，参数是按顺序进行对应的 |
| kwargs | 以字典的方式给执行任务传参，参数是按键名进行对应的 |



## 设置守护线程

正常状态下，主线程会默认等待所有子线程执行结束再结束

如果希望主线程结束的同时结束所有子线程，就需要设置守护主线程

```python
线程对象 = threading.Thread(target= ,daemon=True)
```

或

```python
线程对象.setDaemon(True)
```

例

```python
import threading
import time
def sing():
    for i in range(5):
        print('sing')
        time.sleep(1)

if __name__ == '__main__':
    # sing()
    # dance()
    sing_thread = threading.Thread(target=sing)

    sing_thread.setDaemon(True)
    sing_thread.start()

    time.sleep(1)
    print("主线程结束")
```



## 线程阻塞

使用join方法，让主线程等待子线程执行



## 线程间的执行顺序

线程间的执行顺序是无序的，是由CPU调度决定的

```python
import threading
import time

def test():
    time.sleep(1)
    print(threading.current_thread())

if __name__ == '__main__':

    for i in range(5):
        th = threading.Thread(target=test)
        th.start()
```

## 互斥锁

当多个线程同时修改同一条数据时可能会出现脏数据，所以，出现了线程锁，即同一时刻允许一个线程执行操作。线程锁用于锁定资源，你可以定义多个锁, 像下面的代码, 当你需要独占某一资源时，任何一个锁都可以锁这个资源，就好比你用不同的锁都可以把相同的一个门锁住是一个道理。

由于线程之间是进行随机调度，如果有多个线程同时操作一个对象，如果没有很好地保护该对象，会造成程序结果的不可预期，我们也称此为“线程不安全”。

```python
from threading import Thread,Lock
import os,time
def work():
    global n
    lock.acquire()
    temp=n
    time.sleep(0.1)
    n=temp-1
    lock.release()
if __name__ == '__main__':
    lock=Lock()
    n=100
    l=[]
    for i in range(100):
        p=Thread(target=work)
        l.append(p)
        p.start()
    for p in l:
        p.join()
```

## 递归锁

用法和Lock类一模一样，但它支持嵌套，在多个锁没有释放的时候一般会使用RLcok类

```python
import threading
import time

def Func(lock):
    global gl_num
    lock.acquire()
    gl_num += 1
    time.sleep(1)
    print(gl_num)
    lock.release()

if __name__ == '__main__':
    gl_num = 0
    lock = threading.RLock()
    for i in range(10):
        t = threading.Thread(target=Func, args=(lock,))
        t.start()
```

## 信号量

BoundedSemaphore类。互斥锁同时只允许一个线程更改数据，而Semaphore是同时允许一定数量的线程更改数据 ，比如厕所有3个坑，那最多只允许3个人上厕所，后面的人只能等里面有人出来了才能再进去

```python
import threading
import time

def run(n, semaphore):
    semaphore.acquire()   #加锁
    time.sleep(1)
    print("run the thread:%s\n" % n)
    semaphore.release()     #释放

if __name__ == '__main__':
    num = 0
    semaphore = threading.BoundedSemaphore(5)  # 最多允许5个线程同时运行
    for i in range(22):
        t = threading.Thread(target=run, args=("t-%s" % i, semaphore))
        t.start()
    while threading.active_count() != 1:
        pass  # print threading.active_count()
    else:
        print('-----all threads done-----')
```

## 事件

Event类。python线程的事件用于主线程控制其他线程的执行，事件是一个简单的线程同步对象

主要提供以下几个方法

- clear 将flag设置为“False”
- set 将flag设置为“True”
- is_set 判断是否设置了flag
- wait 会一直监听flag，如果没有检测到flag就一直处于阻塞状态

事件处理的机制：全局定义了一个“Flag”，当flag值为“False”，那么event.wait()就会阻塞，当flag值为“True”，那么event.wait()便不再阻塞

```python
#利用Event类模拟红绿灯
import threading
import time

event = threading.Event()


def lighter():
    count = 0
    event.set()     #初始值为绿灯
    while True:
        if 5 < count <=10 :
            event.clear()  # 红灯，清除标志位
            print("\33[41;1mred light is on...\033[0m")
        elif count > 10:
            event.set()  # 绿灯，设置标志位
            count = 0
        else:
            print("\33[42;1mgreen light is on...\033[0m")

        time.sleep(1)
        count += 1

def car(name):
    while True:
        if event.is_set():      #判断是否设置了标志位
            print("[%s] running..."%name)
            time.sleep(1)
        else:
            print("[%s] sees red light,waiting..."%name)
            event.wait()
            print("[%s] green light is on,start going..."%name)

light = threading.Thread(target=lighter,)
light.start()

car = threading.Thread(target=car,args=("MINI",))
car.start()
```



## 实例

```python
import os
import threading
import time

def copy(file_name,source_dir,dest_dir):
    source_path = source_dir + '/' + file_name  #拼接源文件路径和
    dest_path = dest_dir + '/' + file_name  #拼接目标文件路径


    with open(source_path,'rb') as source_file:     #打开源文件和目标文件
        with open(dest_path,'wb') as dest_file:

            while True:
                data = source_file.read(1024)
                if data:
                    dest_file.write(data)
                else:
                    break

if __name__ == '__main__':
    source_dir = ''
    dest_dir = ''

    try:
        os.mkdir(dest_dir)  # 创建目标文件夹
    except:
        print('目标文件夹已存在')

    file_list = os.listdir(source_dir)

    for file_name in file_list:
        th = threading.Thread(target=copy, args=(file_name, source_dir, dest_dir))

        th.start()
```





## 销毁子进程

要做到主线程不结束，但是要强行结束子线程

使用ctypes强行杀掉线程

```python
import threading
import time
import inspect
import ctypes
 
def _async_raise(tid, exctype):
    """raises the exception, performs cleanup if needed"""
    tid = ctypes.c_long(tid)
    if not inspect.isclass(exctype):
        exctype = type(exctype)
    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, ctypes.py_object(exctype))
    if res == 0:
        raise ValueError("invalid thread id")
    elif res != 1:
        # """if it returns a number greater than one, you're in trouble,
        # and you should call it again with exc=NULL to revert the effect"""
        ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, None)
        raise SystemError("PyThreadState_SetAsyncExc failed")
 
def stop_thread(thread):
    _async_raise(thread.ident, SystemExit)
 
def print_time():
    while 2:
         print(111111111111)
         print(222222222222)
         print(333333333333)
         print(444444444444)
         print(555555555555)
         print(666666666666)
 
 
if __name__ == "__main__":
    t = threading.Thread(target=print_time)
    t.start()
 
    stop_thread(t)
    print("stoped")
    while 1:
    	pass

```



# 进程和线程对比

## 关系对比

* 线程是依附在进程里的
* 一个进程默认提供一条线程
* 进程可以创建多个线程

## 区别对比

* 创建进程的资源开销比创建线程大
* 进程是操作系统分配资源的基本单位，线程是CPU调度的基本单位

## 优缺点

### 进程

可以使用多核

资源开销大

### 线程

资源开销小

不能使用多核

# 数据传输

## 线程间

如果我们要多个线程累加同一个变量，对于thread来说，申明一个global变量，用thread.Lock的context包裹住三行就搞定了。

## 进程间

multiprocessing由于进程之间无法看到对方的数据，只能通过在主线程申明一个**Queue**或者用**Managers**方法。