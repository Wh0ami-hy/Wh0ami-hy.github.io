---
layout: post   	
catalog: true 	
tags:
    - Vue
---





# 1. 配置vue环境

需要先安装好node.js

## 1.1. 安装Vue

使用管理员cmd运行 `npm install vue -g`

## 1.2. 安装Vue-cli

Vue 构建工具，Vue CLI 使用了Webpack作为构建工具，Vue CLI = Vue + 一堆的js插件

使用管理员权限运行  `npm install vue-cli -g` 或者 `npm install -g @vue/cli` （安装的是最新版）

Vue.js 的版本和 Vue CLI 的版本是两个不同的概念，它们之间并没有直接的关系，使用 Vue CLI 来创建和管理项目。Vue CLI 会自动安装与当前项目兼容的 Vue.js 版本。如果您在使用 Vue CLI 创建项目时指定了要使用的 Vue.js 版本，那么 Vue CLI 会自动安装指定版本的 Vue.js

# 2. 用Vue-cli 构建Vue项目

创建项目文件夹，切换到该文件夹下，构建vue项目，使用管理员权限运行 `vue create vue01`

```
 (*) Babel
 ( ) TypeScript
 ( ) Progressive Web App (PWA) Support
 (*) Router
 (*) Vuex
 (*) CSS Pre-processors
 ( ) Linter / Formatter
 ( ) Unit Testing
 ( ) E2E Testing
```

若下载依赖速度慢可以`npm config set registry https://registry.npm.taobao.org
`
```
? Vue build standalone
? Install vue-router? Yes
? Use ESLint to lint your code? No
? Set up unit tests No
? Setup e2e tests with Nightwatch? No
? Should we run `npm install` for you after the project has been created? (recommended) npm
```

启动项目，使用管理员权限运行`npm run serve`

安装依赖，使用管理员权限运行 `npm install name`

**如何知道vue-cli创建的项目对应的webpack版本**

找到项目下 node_modules/webpack/package.json 文件里的version字段即可

## 2.1. 项目结构

以 vue-admin-template 为例

```
api 前端的所有请求
assets 主题、字体等静态资源
components 全局公用组件
icons  项目所有 svg icons
mock  项目mock 模拟数据
router 管理前端路由
App.vue 是根组件
main.js  相当于main方法，是整个项目的入口js
store 全局store管理
utils  全局公用方法
styles  全局样式
views 视图，存放各个页面的自定义组件
layout 布局
permission.js  权限管理，根据用户的不同权限可以实现动态路由
项目中 @指的是src目录
```

## 2.2. package.json

方便快捷的管理项目依赖的资源，避免资源间的版本冲突等问题

构建一个vue项目时，只需用package.json即可。执行 `npm install`，npm会自动从package.json中读取依赖，进行下载
## 2.3. Vue CLI 多种环境

.env.development：本地

.env.staging：测试环境

.env.production：正式环境

## 2.4. 版本问题

vue版本查看：`vue -V`

Vue CLI 4.5以下，对应的是Vue2

Vue CLI 4.5及以上，对应的是Vue3，当然，创建项目的时候可以选择Vue2

-   `^` 符号表示兼容的更新，例如 `^5.0.0` 表示可以安装 `5.x.x` 版本系列的最新版本，但不包括 `6.0.0` 或更高版本。
-   `~` 符号表示只安装修订版本的更新，例如 `~5.0.0` 表示可以安装 `5.0.x` 版本系列的最新版本，但不包括 `5.1.0` 或更高版本。
-   `>` 和 `<` 符号分别表示大于和小于某个特定版本，例如 `>4.0.0` 表示可以安装大于 `4.0.0` 的任何版本。
-   `>=` 和 `<=` 符号分别表示大于等于和小于等于某个特定版本，例如 `>=4.0.0` 表示可以安装大于等于 `4.0.0` 的任何版本，包括 `4.0.0` 本身。

# 3. Vue 语法

## 3.1. 创建 vue 实例

声明 vue 所控制的 DOM 区域

```html
    <div id="app">
        {{message}}
    </div>
```

## 3.2. 标签内容渲染

常规

```javascript
{{test}}
```

渲染HTML

```
v-html="test"
```

## 3.3. 标签属性渲染

```
v-blind:属性名="test"
```

## 3.4. 使用JavaScript表达式

```
{{表达式}}
```

## 3.5. 事件绑定

鼠标或键盘的事件绑定

```
<buton v-on:click="func">
或
<buton @click="func">
```

## 3.6. 条件渲染

是否渲染标签

```
v-if="" 
或
v-show=""
值为 true或false
```

## 3.7. v-else&v-else-if

效果同 if、else、else if

## 3.8. 列表渲染

渲染列表或数组形式的数据

```
<li v-for=""></li>
```

## 3.9. v-for中的key

```
<li v-for="" :key=""></li>
```

## 3.10. 数据绑定

双向绑定`v-model=""`：只能给表单类，也就是具有value属性的元素进行数据双向绑定。`vue <-> dom`

单向绑定`v-blind=""`：用来绑定数据和属性以及表达式，可以给任何属性赋值，数据只能从data流向页面。`vue->dom`。`v-bind`简写为 `:`，eg `v-bind:class` 可简写为 `:class`

# 4. Vue 组件

封装可重用的代码

## 4.1. 构成

Vue中组件的后缀名是`.vue`，共三部分

```vue
<template>
模板结构，包含HTML等
</template>

<script>
JavaScript代码
</script>

<style>
样式
</style>
```

## 4.2. 分类

**自定义组件**

**根组件（App.vue）**

组件之间可相互嵌套，自定义组件一般都在App.vue组件中调用

## 4.3. 组件间的传值

自定义组件之间：vue无相应方法

自定义组件与根组件（App.vue）之间：props

## 4.4. 组件的生命周期函数

创建时：created

渲染时：mounted

销毁时：components

## 4.5. 第三方组件-ElementUI

官网：https://element.eleme.cn/

npm安装

```
npm install element-ui
```

配置main.js

```
import ElementUI from 'element-ui'
import 'element-ui/lib/theme-chalk/index.css'
```


# 5. 模块化&组件化

模块化

```
import ...这就是模块化
```

组件化

```
封装的自定义的可重用代码
```

# 6. Axios

在实际项目开发中，前端页面所需要的数据往往需要从服务器端获取，这必然涉及与服务器的通信。

Axios是一个基于promise网络请求库，作用于node.js和浏览器中。

Axios在浏览器端使用XMLHttpRequests发送网络请求，并能自动完成JSON数据的转换。

```
https://www.axios-http.cn/
```

npm安装

```
npm install axios
```

配置main.js

```
//配置请求根路径
axios.defau1ts.baseURL = 'http://api.com:888'

//将axios 作为全局的自定义属性，每个组件可以在内部直接访问(Vue3)
app.config.g1obalProperties.$http = axios

//将axios作为全局的自定义属性，每个组件可以在内部直接访问(Vue2)，之后可用this.$http.get代替 axios.get
Vue.prototype.$http = axios
```

## 6.1. 跨域请求（重点）

### 6.1.1. 原因

前端：浏览器占用8080端口

```
http://localhost:8080/
```

后端：服务器占用888端口

```
http://localhost:888/
```

所以前端请求后端时，会触发同源策略，所以导致请求失败

### 6.1.2. CORS解决跨域请求

方法：在后端服务器实现CORS接口

CORS将请求分为：简单请求、非简单请求

**简单请求：**

满足以下所有条件，则为简单请求

- 请求方法为GET、HEAD、POST之一

- HTTP头部信息只包含了以下字段：Accept、Accept-Language、Content-Language、Content-Type（但仅限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain）

**处理方法：**

对于简单请求，CORS的策略是请求时在请求头中增加一个`Origin`字段

```
Host: localhost:8080
Origin: http://localhost :8081
Referer: http://localhost : 8081/index. html
```

服务器收到请求后，根据该字段判断是否允许该请求访问，如果允许，则在HTTP头信息中添加`Access-Control-Allow-Origin`字段

```
Access-Control -Allow-Origin: http://localhost:8081
Content-Length: 20
Content-Type: text/plain; charset=UTF-8
Date: Thu, 12 Jul 2018 12:51:14 GMT
```

**非简单请求：**

如果请求不满足简单请求，则为非简单请求

**处理方法：**

非简单请求会在正式请求之前，先发送一个预检请求，称为OPTIONS请求

OPTIONS请求方法的作用是：用来请求服务器告知其支持的 HTTP 方法和其他一些选项，如是否支持跨域请求、支持哪些请求头等。预检请求会先发送一个OPTIONS请求，服务器响应该请求后，浏览器才会发起正式请求

非简单请求会在请求头中添加一个名为 `Origin` 的字段，该字段表示源地址，即发起请求的页面或域名。当服务器响应时，如果允许该源地址的请求，则会在响应头中添加一个名为 `Access-Control-Allow-Origin` 的字段，该字段的值为该源地址，表示允许该源地址的请求

# 7. VueRouter

Vue路由vue-router是官方的路由插件，能够轻松的管理SPA项目（ Single Page Application，单页面应用）中组件的切换

Vue的单页面应用（仅在一个html页面上进行渲染）是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来 vue-router目前有3.x的版本和4.x的版本，vue-router 3.x只能结合vue2进行使用，vue-router 4.x只能结合vue3进行使用

使用管理员权限安装`npm install vue-router@3`

## 7.1. 声明路由链接和占位标签

在App.vue组件中，可以使用`<router-link>` 标签来声明路由链接，并使用`<router-view>` 标签来声明路由占位符

```html
<template>
  <div id="app">
    <router-link to="/mymusic">我的音乐</router-link>
    <router-link to="/friend">关注</router-link>
    <!--声明路由占位标签-->
    <router-view></router-view>
  </div>
</template>
```

## 7.2. 创建路由模块

创建router文件夹，在该文件夹中创建index.js路由模块，加入以下代码

```javascript
import VueRouter from 'vue-router'
import Vue from 'vue'
//导入组件
import Discover from '../components/Discover'
import Friend from '../components/Friend.vue'
import MyMusic from '../components/MyMusic.vue'

//将VueRouter设置为Vue的插件
Vue.use(VueRouter)

const router = new VueRouter({
//指定hash属性与组件的对应关系
	routes:[
		{path:'/',redirect:'/discover'},//重定向
		{ path:'/discover', component: Discover },
		{ path:'/friend', component: Friend },
		{ path:'/mymusic',component: MyMusic },
	]
})
export default router
```

## 7.3. 路由重定向

路由重定向指的是：用户在访问地址A的时候，强制用户跳转到地址C，从而展示特定的组件页面。

通过路由规则的redirect 属性，指定一个新的路由地址，可以很方便地设置路由的重定向

## 7.4. 嵌套路由

通过children属性，嵌套声明子路由

## 7.5. 动态路由

动态路由指的是：把Hash地址中可变的部分定义为参数项，从而提高路由规则的复用性。在vue-router中使用英文的冒号`:` 来定义路由的参数项。示例代码如下：

```
{ path: '/product/:id', component:Product }
```

通过动态路由匹配的方式渲染出来的组件中，可以使用`$route.params`对象访问到动态匹配的参数值，比如在商品详情组件的内部，根据id值，请求不同的商品数据。

```
获取商品id
<h3>商品{{$route.params.id}}</h3>
```

为了简化路由参数的获取形式，vue-router 允许在路由规则中开启props传参。示例代码如下：

```
{ path: '/product/:id', component: Product, props: true }
```

## 7.6. 导航

**实现页面跳转**

声明式导航：

```
<router-link to="...">商品2</router-link>
```

编程式导航：

```
router.push(...)
```

## 7.7. 路由守卫

路由守卫可以控制路由的访问权限。全局路由守卫会拦截每个路由规则，从而对每个路由进行访问权限的控制。

可以使用router.beforeEach注册一个全局前置守卫：

```javascript
router.beforeEach((to，from, next) => { 
if (to.path === '/main' && !isAuthenticated) {
next(' /1ogin')
else {
next()
})


/*
to:即将要进入的目标
from:当前导航正要离开的路由
在守卫方法中如果声明了next形参，则必须调用next()函数,否则不允许用户访问任何一个路由!
直接放行:next()
强制其停留在当前页面: next(false)
强制其跳转到登录页面: next('/login')
/*
```

# 8. Vuex

Vuex是一个专为Vue.js应用程序开发的状态管理库，集中式存储管理应用的所有组件的状态。

简单的说，Vuex用于管理分散在Vue各个组件中的数据。

安装：Vue2对应Vuex3，Vue3对应Vuex4

```
npm install vuex@3
```

每一个Vuex应用的核心都是一个store，与普通的全局对象不同的是，基于Vue数据与视图绑定的特点，当store中的状态发生变化时，与之绑定的视图也会被重新渲染。

store中的状态不允许被直接修改，改变store中的状态的唯一途径就是显式地提交，这可以让我们方便地跟踪每一个状态的变化。

在大型复杂应用中，如果无法有效地跟踪到状态的变化，将会对理解和维护代码带来极大的困扰。

Vuex中有5个重要的概念：State、 Getter、 Mutation、 Action、 Module。

![QQ截图20230109211354](F:\笔记\博客\文章图片\QQ截图20230109211354-1673317837671.png)

# 9. Mockjs

Mock.js是一款前端开发中拦截Ajax请求再生成随机数据响应的工具，可以用来模拟服务器响应

优点是非常简单方便，无侵入性，基本覆盖常用的接口数据类型。支持生成随机的文本、数字、布尔值、日期、邮箱、链接、图片、颜色等。

`npm install mockjs`

## 9.1. 基本使用

在项目中创建mock目录，新建index.js文件

```javascript
//引入mockjs
import Mock from 'mockjs'
//使用mockjs模拟数据
Mock.mock('/product/search', {
"ret":0,
"data":
{
"mtime": "@datetime",//随机生成日期时间
"score|1-800": 800,//随机生成1-800的数字
"rank|1-100": 100,//随机生成1-100的数字
"stars|1-5": 5,//随机生成1-5的数字
"nickname": "@cname" ,//随机生成中文名字
}
});
```

组件中调用mock.js中模拟的数据接口，这时返回的response就是mock.js中用Mock.mock( 'url' ,data) 中设置的data

```javascript
import axios from
axios
export default {
mounted:function () {
axios . get(" /product/search") . then(res => {
console.1og(res)
})
}

```

## 9.2. 核心方法

```
Mock.mock(rurl?, rtype?,template|function( options ) ) 
rurl，表示需要拦截的URL，可以是URL字符串或URL正则
rtype，表示需要拦截的Ajax请求类型。例如GET、POST、PUT、 DELETE 等。
template，表示数据模板，可以是对象或字符串
function，表示用于生成响应数据的函数。
```

设置延时请求到数据

```javascript
//延时400ms请求到数据
Mock . setup({
ti meout: 400
})
//延时200-600毫秒请求到数据
Mock . setup({
timeout:' 200-600'
})
```

# 10. 部署vue项目

## 10.1. 打包

打包应用时应读取生产环境下的配置 `.env.production`

```
npm run build:prod
```

## 10.2. 配置nginx

进入nginx/conf.d 目录，创建 vue.conf文件

```
server {
listen	80;
server_name locahost;
location / {
root /usr/app/dist;
index index.html;
	}
}
```









