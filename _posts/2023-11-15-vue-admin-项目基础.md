---
layout: post   	
catalog: true 	
tags:
    - Vue
---

# 1. Vuex

https://v3.vuex.vuejs.org/zh/

 Vue 3 匹配 Vuex 4 。Vue 2 匹配 Vuex 3 

`Vuex`是一个用于状态管理的官方库，它用于在应用程序中集中管理和共享状态。

## 1.1. store

它是一个包含应用程序状态的容器。`store`中的状态是响应式的，意味着当状态发生变化时，相关组件会自动更新。`store`允许你定义、获取和修改应用程序的状态。

## 1.2. state

`state`是存储在`store`中的数据。它代表应用程序的状态，在`Vuex`中是唯一的数据源。`state`通常是一个JavaScript对象，其中包含多个属性，每个属性代表一个状态值。你可以在组件中读取`state`的值，也可以通过提交`mutations`来修改`state`。

## 1.3. Mutation

Mutations用于修改状态。定义Mutations并在组件中提交（commit）Mutations来修改状态。确保通过Mutations修改状态是同步的

## 1.4. Action

使用Actions处理异步逻辑：例如从API获取数据。在Actions中定义异步操作，并在组件中分发（dispatch）Actions。Actions可以通过提交Mutations来间接修改状态

## 1.5. Getter

使用Getters获取状态：Getters用于从状态中派生出新的数据。你可以定义Getters来计算、过滤或组合状态，然后在组件中使用它们。Getters是响应式的，它们将自动更新，当依赖的状态发生变化时

## 1.6. 在 Vue 组件中获得 store 状态

通过在根实例中注册 `store` 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 `this.$store` 访问到

在`store/index.js`中

```javascript
import Vue from 'vue'
import Vuex from 'vuex'
import getters from './getters'
import app from './modules/app'
import settings from './modules/settings'
import user from './modules/user'

Vue.use(Vuex)

const store = new Vuex.Store({
  modules: {
    app,
    settings,
    user
  },
  getters
})

export default store
```

在`main.js`中

```javascript
import store from './store'
new Vue({
  el: '#app',
  router,
  store,
  render: h => h(App)
})
```

使用计算属性来访问状态

使用映射辅助函数来访问状态，例如`this.$store.state`，用于直接访问Vuex的状态

## 1.7. 更改 Vuex 的 store 中的状态

更改 Vuex 的 store 中的状态的唯一方法是提交 mutation

# 2. Vue Router

https://router.vuejs.org/zh/guide/



# 3. Vue CLI 

https://cli.vuejs.org/zh/guide/

基于 webpack 和 Vue.js 构建



构成

## 3.1. CLI

## 3.2. CLI 服务

## 3.3. CLI 插件



# 4. webpack

一个JavaScript应用程序的静态模块打包器。它主要用于处理模块之间的依赖关系，并将它们打包成适用于浏览器环境的静态资源

## 4.1. alias

`alias` 是 Webpack 的一个配置选项，用于创建模块的别名。通常用alias 指向src目录下，再使用相对路径找文件

```javascript
resolve: {
    alias: {
        '@': resolve('src')
    }
}

//在组件中使用
import stickTop from '@/components/stickTop'
```

# 5. 目录结构

```xml
├── build                      // 构建相关  
├── config                     // 配置相关
├── src                        // 源代码
│   ├── api                    // 所有请求
│   ├── assets                 // 主题 字体等静态资源
│   ├── components             // 全局公用组件
│   ├── directive              // 全局指令
│   ├── filtres                // 全局 filter
│   ├── icons                  // 项目所有 svg icons
│   ├── lang                   // 国际化 language
│   ├── mock                   // 项目mock 模拟数据
│   ├── router                 // 路由
│   ├── store                  // 全局 store管理
│   ├── styles                 // 全局样式
│   ├── utils                  // 全局公用方法
│   ├── vendor                 // 公用vendor
│   ├── views                   // view
│   ├── App.vue                // 入口页面
│   ├── main.js                // 入口 加载组件 初始化等
│   └── permission.js          // 权限管理
├── static                     // 第三方不打包资源
│   └── Tinymce                // 富文本
├── .babelrc                   // babel-loader 配置
├── eslintrc.js                // eslint 配置项
├── .gitignore                 // git 忽略项
├── favicon.ico                // favicon图标
├── index.html                 // html模板
└── package.json               // package.json
```

## 5.1. api 和 views

根据业务模块来划分 views，并且 将views 和 api 两个模块一一对应，从而方便维护

```xml
├── views              
│   ├── student // 文件夹，存放student业务相关的组件         
│   ├── teacher // 文件夹，存放teacher业务相关的组件         ├── api
│   ├── student.js    // js文件，编写和student业务相关的api
│   ├── teacher.js    // js文件，编写和teacher业务相关的api   
```

## 5.2. components

components 放置的都是全局公用的一些组件，如上传组件，富文本等等。一些页面级的组件建议还是放在各自views文件下

## 5.3. store

统一管理一些数据，如登录token，用户信息，或者是一些全局个人偏好设置等

# 6. router-view

```javascript
{path: 'create', component: PostCreate, name: '文章发布'}，
{path: 'edit', component: PostCreate, name: '文章编辑'}

```

不同页面使用的是同一个component，默认情况下当这几个页面间切换时并不会触发vue的created或者mounted钩子。可以简单的在 router-view上加上一个唯一的key，来保证路由切换时都会重新渲染触发钩子

```javascript
<router-view :key="key"></router-view>

computed: {
    key() {
        return this.$route.name !== undefined? this.$route.name + +new Date(): this.$route + +new Date()
    }
 }
```

# 7. 封装 axios

# 8. 多环境

vue-cli 默认只提供了`dev`和`prod`两种环境

# 9. 前后端交互

## 9.1. 跨域问题

用 `cors`来解决的，如果你司后端嫌麻烦不肯配置的话，dev环境也可以通过 `webpack-dev-server`的`proxy`来解决，开发环境用`nginx`反代理一下就好了，具体配置这里就不展开了。

