---
layout: post   	
catalog: true 	
tags:
    - Java
---





# 认识java

**JSE**

主要用于编写C/S项目和提供标准的JAVA类库，是所有基于Java语言开发的基础

**JME**

嵌入式开发，向手机里的软件、掌上电脑等等

**JEE**

用来构建大型网站和B/S系统 ，作为一个企业版本，主要是给出一个开发企业级应用架构的解决方案，同时给出了在这个架构中相关组件以供开发人员使用

**面向过程编程**

```
以算法为核心
自顶向下，要求一开始必须对问题有了解
将大问题转为小问题来求解
表现形式：用函数作为划分程序的基本单位
适合解决规模不大、变动较小的问题
```

**面向对象编程**

世界上的所有事物都可用静态属性和动态属性来描述。这就衍生出了，编程中的方法和属性

```java
//由下而上
//适合解决规模大、变动较大的问题
//求三角形周长
class Triangle{
    int a;
    int b;
    int c;
    int zhouchang(){ //不需要定义形参，因为zhoucahng函数和属性a、b、c是一个有机整体，它们都属于一个类，彼此可以直接访问
        return a+b+c；
    }
}
```

**classpath**

操作系统利用classpath变量来寻找当前后缀为class的字节码文件所存放的路径，并以最先找到的为准

从JDK1.6开始，不需要手动设置

**JAVA_HOME**

JAVA_HOME是一个约定，通常它指的是JDK的目录。如果需要JDK的话，大部分程序会默认去环境变量中取JAVA_HOME这个变量。

**JVM**

JVM是Java Virtual Machine的缩写。它是一种基于计算设备的规范，是一台虚拟机，即虚构的计算机。

JVM屏蔽了具体操作系统平台的信息（显然，就像是我们在电脑上开了个虚拟机一样），当然，JVM执行字节码时实际上还是要解释成具体操作平台的机器指令的。

通过JVM，Java实现了平台无关性，Java语言在不同平台运行时不需要重新编译，只需要在该平台上部署JVM就可以了。因而能实现一次编译多处运行。(就像是你的虚拟机也可以在任何安了VMWare的系统上运行)

**JRE**

JRE是Java Runtime Environment的缩写，也就是JVM的运行平台，联系平时用的虚拟机，大概可以理解成JRE=虚拟机平台+虚拟机本体(JVM)。类似于你电脑上的VMWare+适用于VMWare的Ubuntu虚拟机。这样我们也就明白了JVM到底是个什么

**JDK**

Java Develop Kit，Java的开发工具包，JDK本体也是Java程序，因此运行依赖于JRE，由于需要保持JDK的独立性与完整性，JDK的安装目录下通常也附有JRE。目前Oracle提供的Windows下的JDK安装工具会同时安装一个正常的JRE和隶属于JDK目录下的JRE

**Java命令**

```
javac　编译源文件生成字节码文件

java      运行字节码文件

javadoc   由源文件中的文档注释生成html文档文件

-d参数指定文档生成路径

javap   反编译显示类成员变量和成员函数首部

jar   把一些类的字节码文件压缩成一个jar文件
```

# Java基础

## 标准

```
区分大小写
强类型语言
文件名与类名(main()所在类)相同
一个Java文件中只能有一个public类
Java中字符和字符串都用Unicode编码表示
在Unicode编码中一个字符占两个字节
```

## Java文件命名

```
一个Java文件中只能有一个public类
如果文件中只有一个类，文件名必须与类名一致
如果文件中不止一个类，文件名必须与public类名一致
如果文件中不止一个类，而且没有public类，文件名可与任一类名一致
```

## 注释

```
注释一行
//
注释多行
/*  */
文档注释
/**
*
*
*/
```

## 关键字

关键字的字母全部小写 

## 标识符

包含：类名、变量名、常量名、方法名....

格式：以字母、下划线、`$`开始，后面可跟字母、下划线、`$`、数字

## 常量

| 常量类型   | 说明               | 举例                  |
| ---------- | ------------------ | --------------------- |
| 字符串常量 | 用双引号括起来     | "hello word"          |
| 整数常量   | 不带小数的数字     | 6                     |
| 小数常量   | 带小数的数字       | 6.6                   |
| 字符常量   | 用单引号括起来     | 'A'                   |
| 布尔常量   | 布尔值，表示真假   | 只有两个值true、false |
| 空常量     | 一个特殊的值，空值 | 值是null              |

### 整型常量

一个常量整数默认是int类型，如果数字过大，则必须在末尾加`L或l`否则会出错

```java
class AAA {
    public static void  main(String[] args) {
        long i = 13213261331;
        System.out.printf("%d",i);
    }

}
//结果：java: 过大的整数: 13213261331


class AAA {
    public static void  main(String[] args) {
        long i = 13213261331L;
        System.out.printf("%d",i);
    }

}

//成功运行

```

### 浮点常量

一个实数默认是double类型，如果希望一个实数是float类型，可以在数字后加`F或f`

将一个double类型数值赋给float类型变量，编译是会报错

```java
float x = 2.2;//错误
float x = 2.2f;//正确
```

### 空常量

空常量null不能直接输出

### 布尔常量

只有两个值：true和false，且它们不能对应于任何整数值

```java
if(3)  //if(3)不等价于if(true)
System.out.printf("123");
//是错误的
```

只能参与逻辑运算

`&&`、`||`、`==`、`!=`、`!

### 特殊字符

反斜线 `\\`、退格 `\b`、回车 `\r`、制表符 `\t`、换行 `\n`、单引号 `'`

## 数据类型

强类型语言，不同数据类型，数据大小不一样

### 基本数据类型

**数值型**

```
整数类型
byte 
占一个字节，数字大小为 -2^7——2^7-1
short
占两个字节，数字大小为 -2^15——2^15-1
int
占四个字节，数字大小为 -2^31———2^31-1
long
占八个字节，数字大小为 -2^63——2^63-1

浮点型
float
占用四个字节
double
占八个字节
```

**字符型**

```
char
占两个字节，数字大小为0——2^16-1，是Unicode编码
```

**布尔型**

```
boolean
占一个字节
```

### 引用数据类型

引用类型其实就是C语言的指针类型

#### 类

#### 接口

#### 数组

## 变量

程序运行过程中，值可以改变的量，实质是内存上的一块空间

格式

```java
数据类型 变量名 = 变量值
如
int a = 3;
```

注意

```
变量名不能重复

变量未赋值，不能使用

long类型的变量定义的时候，为防止整数过大，后面要加L

float类型的变量定义的时候，为防止类型不兼容，后面要加F
```

## 变量类型转换

### 自动转换

把小容量的类型转换为容量大的类型

```java
如
double a = 10;
```

### 强制转换

把大容量的类型转换为容量小的类型

```java
如
int a = (int)88.88;
```

注意

```
不能对boolean类型进行类型转换

把大容量的类型转换为容量小的类型时，容易缺失精度

整型、实型、字符型数据可混合运算，但要先转换为统一类型，转换从低级到高级（如：byte转int，因为byte占1字节，int占4字节，byte转int不丢失数据）
```



## 运算符

### 算术运算符

加`+` 、减`-`、乘`*`、除`/`

运算结果和运算对象的类型有关，若运算对象中有一个是浮点型，则结果也为浮点型，否则为整型

```java
public class AAA {
    public static void  main(String[] args){
        int a = 10;
        float b = 3;
        int c = 3;
        System.out.println(a/b); //结果为 3.3333333
        System.out.println(a/b); //结果为 3
    }

}
```

取余`%`

允许取余运算的被除数和除数是实数（这与c语言不同），所得的余数的正负只和被除数相同

```java
System.out.println(1%-0.3); //结果为0.10000000000000003
```

#### 字符的`+`操作

拿字符的ASCII码来进行计算

当算术表达式包含多个基本数据类型的时候，整个算数表达式的类型会自动进行提升

```
byte类型，short类型和char类型都被提升到int类型
整个表达式自动提升到表达式中最高等级操作数同样的类型
```

#### 字符串的`+`操作

当`+ `操作中出现字符串时，`+`表示字符串的连接

```java
"123" + "abc" 结果 "123abc"
```

当连续进行`+ `操作时，从左到右逐个执行(可以把非字符串转换成字符串)

```java
"x" + 32 + 1 结果 "x321"
    
32 + 1 + "x" 结果 "33x"

System.out.print('a' + 1); //结果为 98
System.out.print("" + 'a' + 1);  //结果为a1
//二者结果不一样
```



### 关系运算符

`>`、`>=`、`<`、`<=`、`!=`、`==`

### 逻辑运算符

```
逻辑否！

结果取反

逻辑与&

两边的表达式只要有一个是假的，整个式子就为假，两边都会执行

逻辑或|

两边的表达式只要有一个是真的，整个式子就为真，两边都会执行

逻辑异或^

两边相同时为false，两边不同时为true，两边都会执行
```

### 短路逻辑运算符

```
短路与&&

左边的表达式为假时，右边的表达式不执行

短路或||

左边的表达式为真时，右边的表达式不执行
```

### 赋值运算符

不推荐使用

`=`、`+=`、`*=`、`/=`、`%=`

扩展的赋值运算符，隐含了强制类型转换

### 自增自减运算符

不推荐使用

`++`、`--`

如果放在变量前，就先执行自增或自减，然后变量才参与其他操作

如果放在变量后，变量先参与其他操作，然后执行自增或自减

### 三元运算符

`关系表达式?表达式1:表达式2;`

```java
如：a > b ? a : b;

规则：
    首先计算表达式的值
    如果值为true，表达式1的值，为运算结果
    如果值为false，表达式2的值，为运算结果
```

### 位运算符

按位与`&`：把两个数的二进制位相与

``` 
1 & 1 = 1
1 & 0 = 0
0 & 0 = 0
0 & 1 = 0
```

按位或`|`：把两个数的二进制位相或

```
1 | 1 = 1
1 | 0 = 1
0 | 0 = 0
0 | 1 = 1
```

按位取反`~`：把一个数字的二进制位取反

```
~1 = 0
~0 = 1
```

按位异或`^`：把两个数的二进制位异或

```
1 ^ 1 = 0
1 ^ 0 = 1
0 ^ 1 = 1
0 ^ 0 = 0
```

右移`>>`：右移运算符，num >> 1，相当于num除以2。当为正数时，前面补0，为负数时，前面补1

无符号右移`>>> `：忽略符号位，空位都以0补齐

左移`<<`：左移运算符，num << 1，相当于num乘以2。无论正负数，后面补0

### instanceof

`对象 instanceof 类`

当左面的对象是右面的类创建的对象时，该结果 true，否则为false

```java
public class work {
    public static void main(String[] args) {

        A a = new A();
        System.out.println(a instanceof A); //结果为true
    }
}
```

## 流程控制

### 顺序

### 选择

### 循环

#### 增强for循环

```
简化数组和Collection集合的遍历
实现Iterable接口的类允许其对象成为增强型for语句的目标

for(元素类型 变量名 : 数组或Collection集合){
在此处使用变量即可，该变量就是元素
}
```

例

```java
class work{
    public static void main(String[] args) {

        List<String> c = new ArrayList<String>();
        c.add("hello");
        c.add("java");
        c.add("hello");

        for (String s:c){
            System.out.println(s);
        }
```

注意

```
continue，结束本次循环，开始下一次循环

break，停止循环

if、while、for中进行真假判断时，只能使用逻辑表达式
```



## 输入输出

### 输入

创建类对象

```java
Scanner sc = new Scanner(System.in);		//创建一个该类的对象
```

接收数据

```java
int b = sc.nextInt(); 
```

### 输出

`System.out.println()`

输出值的同时，输出换行

`System.out.printf()`

类似C语言的`printf`，可以进行格式化输出

```java
class  test{
    public  static  void  main(String[]  args)  {
        int  t=3;
        System.out.printf("%d",t);
    }
}
```

`System.out.print()`

print就是一般的标准输出，但是不换行

### 输入相关的方法

`nextByte()`方法用来读取用户输入的byte数据， `hasNextByte()`方法用来判断用户输入的数据类型是否为byte

这些方法执行时都会堵塞，等待输入回车确认

| 获取数据       | 判断数据          |
| -------------- | ----------------- |
| `nextByte()`   | `hasNextByte()`   |
| `nextDouble()` | `hasNextDouble()` |
| `nextFloat()`  | `hasNextFloat()`  |
| `nextInt()`    | `hasNextInt()`    |
| `nextLine()`   | `hasNextLine()`   |
| `nextLong`     | `hasNextLong()`   |
| `nextShort`    | hasNextShort()    |

```
next()不会吸取字符前/后的空格/Tab键，只吸取字符，开始吸取字符（字符前后不算）直到遇到空格/Tab键/回车截止吸取

nextLine()吸取字符前后的空格/Tab键，回车键截止
```

### 格式化输出

| 输出控制符       | 针对的数据类型                 |
| ---------------- | ------------------------------ |
| %d               | int，long int，short，byte     |
| %x，%X，%#x，%#X | int，long int                  |
| %c               | char                           |
| %f               | float，double                  |
| %m.nf            | 输出的数占m列，小数点后保留n位 |
| %s               | String                         |

注意

```
%x和%X的区别是显示十六进制数a-f的大小写

%x和%#x的区别是显示或不显示0x前缀

%njava中表示回行
```

## Random

产生一个随机数

创建对象

```java
Random r = new Random();
```

获取随机数

```java
int t = r.nextInt(10);		//在范围 0 - 9 之间获取一个随机数
```



## 数组

### 定义

```java
int [] boy;			//推荐
或
int boy[];
```

### 初始化

**动态初始化**

初始化时，只指定数组长度，具体值由系统分配

| 数据类型     | 数组默认值 |
| ------------ | ---------- |
| 整数         | 0          |
| 浮点数       | 0.0        |
| 布尔值       | false      |
| 字符         | 空         |
| 引用数据类型 | null       |

```Java
int [] boy = new int[3];
```

**静态初始化**

初始化时，只指定数组元素的具体值，无需指定数组的长度，由系统决定数组长度

```java
int [] boy = new int[]{1,2,3,4,5,6};
或
int [] boy = {1,2,3,4,5,6};
```

### 访问数组

使用索引访问数组中的元素，索引从0开始

### 内存分配

**栈内存**

存储局部变量，定义在方法中的变量

**堆内存**

存储new出来的内容

### 多个数组指向相同

两个数组指向同一个内存地址，改变其中任一个，另一个也改变

```java
int [] boy = new int[3];
int [] girl = boy;
```

### 相关方法

```java
数组名.length //输出数组的大小
```

### 常见问题

索引越界

空指针异常



## 方法

具有独立功能的代码块

### 定义

```java
public static 返回值类型 方法名(参数){
		//方法体
    return 数据;
}

如
    
public static void test(){
		...
         ...
}
```

### 方法调用

```java
方法名()
```

### 参数

形参、实参

### 方法重载

方法重载指同一个类中定义的多个方法间的关系

```java
多个方法在同一个类中
多个方法具有相同的方法名
多个方法的参数不同，类型不同或数量不同
只与参数列表有关，与返回值无关
    
import java.util.*;
class a{
    int jiafa(int c,int d){
        return c + d;
    }
    int jiafa(int c,int d,int e){
        return c + d + e;
    }
}
class test {
    public static void main(String[] args) {
        a A = new a();
        
        System.out.printf("%d\n",A.jiafa(1,2));
        System.out.printf("%d\n",A.jiafa(1,2,3));

    }
}
```

注意

```
方法不能嵌套定义
```



## Java类

### 三大特性

```
封装
继承
多态：操作多态、继承多态
```

### 类的构成

把一类事物的静态属性和动态可以执行的操作组合在一起所得到的这个概念就是类

```java
public class car{
    int high;
    int how_much;
    public void run(){
        System.out.println("开车了！！");
    }
}
```

**成员变量**

```
类中方法外的变量
位于堆内存
有默认的初始化值
伴随对象的产生和消亡
成员变量可以是Java允许的任何数据类型
```

**局部变量**

```
方法内或方法声明上
位于栈内存
没有默认的初始化值，必须先赋值，才能使用
伴随方法的产生和消亡
```

**方法**

静态方法、非静态方法

### 对象

```
类的实例化结果，是一个具体的个体

生命周期是短暂的
```

**对象的引用**

用类创建一个对象时，对象中就存放着引用，如果两个对象有相同的实体就有相同的引用

**对象的实体**

用类创建一个对象时，成员变量被分配内存空间，，这些内存空间就是对象的实体或变量

```java
// new A()，在堆中动态分配一块区域，被当作了A的对象

class A{
int j;
int i;
}
class test{
public static void main(String[] args){
    A aa = new A(); //new A()，在堆中动态分配一块区域，被当作了A的对象
    				//aa本身的内存是在栈中分配的
    				//堆中内存的地址赋给了aa
    				//aa指向堆中的内存，aa代表了堆中的内存
    aa.j;    	     //aa.i代表aa这个静态指针变量所指向的动态内存中的A对象
    aa.i;
	}
}
```

**对象的组合**

一个类把对象作为自己的成员变量，那么创建对象时，该对象中就会有其他对象

```java
//该例子中，b类将a类对象作为自己的成员变量
class a{
    int aa = 11;
}

class b{
    int bb = 45;
    a group = new a();		// a类对象
}

public class work {
    public static void main(String[] args){
        b li = new b();
        System.out.println(li.group.aa);
    }
}
```



### 类的访问控制

```
default(默认)
类名前不加修饰，访问权限和protected一样

public
外部访问和内部访问都可以

protected
外部访问和内部访问都可以

private
只能内部访问
```



```java
class A{
    private int i;
    public int j;
    protected int m;
    void b(){
        i = 4; 	//是正确的
    }
}
class test {
    public static void main(String[] args) {
        A a = new A();
        a.i = 4; 	//是错误的
        a.j = 3;
        a.m = 2;

    }
}
```

注意

```
在类的内部，所有成员可以互相访问，访问控制符是透明的。访问控制符是针对外部访问而言的

权限大小：私有、默认、保护、公有（权限由小到大）
```

**外部访问**

```
通过类名
通过类对象名
通过子类访问
```

### 类的构造方法

类在创建时，该方法自动调用，用来给所创建的对象一个初始状态

```
若不创建构造方法，则java会默认创建一个无参的构造方法

该方法名字必须与所在类的名字一样
该方法没有类型
一个类中可以有多个构造方法
构造方法可以有参也可以无参
```



```java
class a{
    int i;
    int j;
    a(){	//无参构造方法
        i = 3;
        j = 4;
    }
    a(int c,int d){	//有参构造方法
        i = c;
        j = d;
    }
}
class test {
    public static void main(String[] args) {
        a A = new a();
        System.out.println(A.i + " " + A.j);
        //a A = new a(66，55);
        //System.out.println(A.i + " " + A.j);
        
    }
}
```

### 一个标准的类

```
成员变量
使用private修饰

构造方法
提供一个无参构造方法
提供一个带多个参数的构造方法

成员方法
提供每一个成员变量对应的setXxx()、getXxx()
提供一个显示对象信息的show()

创建对象并为其成员变量赋值的两种方式
无参构造方法创建对象后使用setXxx()赋值
使用带参构造方法直接创建带有属性值的对象
```



```java
class Student{
    // 成员变量
    private String name;
    private int age;
    //无参构造方法
    public Student(){};
    //有参构造方法
    public Student(String name,int age){
        this.name = name;
        this.age = age;
    }

    //成员方法
    public void setName(String name){
        this.name = name;

    }
    public String getName(){
        return name;
    }

    public void setAge(int age){
        this.age = age;

    }
    public int getAge(){
        return age;
    }

    public void show(){
        System.out.println(name + "," + age);
    }

}
```



### this

代表所在类的对象引用，方法被哪个对象调用，this指的就是哪个对象。静态函数内部没有this指针

(静态方法是在类中使用staitc修饰的方法，在类定义的时候已经被装载和分配。而非静态方法是不加static关键字的方法，在类定义时没有占用内存，只有在类被实例化成对象时，对象调用该方法才被分配内存)

```java
class A{
    int x = 10;
    void num(int x){
        System.out.printf("%d\n",this.x);
        System.out.printf("%d\n",x);
    }

}

public class test{
    public static void main(String[] args){
        A a = new A();
        A b = new A();
        a.num(2);
        b.num(3);
    }
}
//结果
10
2
10
3
```

**用法**

```
this(参数列表)，访问本类构造方法(只能在构造方法中使用)
this.成员变量 ， 访问本类的成员变量
this.成员方法()，  访问本类成员方法
```

**注意**

当局部变量和成员变量同名的情况下必须使用this指定成员变量的变量名。如果二者名称不同，系统会自动隐含一个this，可以不写

```java
class A {
    int num = 0;

    public void normalNum(int num) {
        num = num;	//成员变量和局部变量重名
        System.out.println(num);
        System.out.println(this.num);
    }

}
public class test {
    public static void main(String[] args) {
        A a = new A();
        a.normalNum(10);
    }
}
//结果
10
0
```

### static

static是静态的意思

```
static声明了属性和方法是属于类本身的，不创建对象也可以直接访问(前提是非私有)
非静态方法可访问静态方法，而静态方法不能访问非静态
```



```java
class A{
    public static int i = 3;	//static声明了属性 i 是属于类本身的，不创建对象也可以直接访问

    public static void show(){	//static声明了方法是属于类本身的，不创建对象也可以直接访问
        System.out.printf("%d\n",i);
    }

}
public class test {
    public static void main(String[] args) {
        System.out.printf("%d",A.i);	//不用创建对象也可以访问类中的属性
        A.show();
    }
}
```

```java
class A{
    public static int i = 3;

    public static void b(){
        System.out.printf("%d\n",i);
        c();	//错误，静态方法b()不能访问非静态c()
    }
    void c(){
        b();	// 非静态方法可访问静态方法
    }
}
public class test {
    public static void main(String[] args) {

        A a = new A();
        a.c();
    }
}
```

```java
class A{
    public static int i = 3;
}
public class test {
    public static void main(String[] args) {
        A a = new A();
        A b = new A();

        System.out.printf("%d\n",a.i);
        System.out.printf("%d\n",b.i);
        System.out.printf("%d\n",A.i);
        
        a.i = 30;					//因为static声明的属性是属于类的，所以类a、对象A、B三者公用一个属性 i
        
        System.out.printf("%d\n",a.i);
        System.out.printf("%d\n",b.i);
        System.out.printf("%d\n",A.i);
    }
}

/*结果
3
3
3
30
30
30
30
*/
    
```

```java
class A{
    static int aa = 11;			// 声明静态
    static void abc(){			// 声明静态
        int aa = 34;
        System.out.println(aa + " " + this.aa); //此语句报错：无法从静态上下文中引用非静态 变量 this
        System.out.println(aa + " " + A.aa);   //应该使用这个语句
    }
}
public class work {
    public static void main(String[] args){
        A v = new A();
        v.abc();  //也可以使用 A.abc()
        
    }
}
```



## 封装的思想

将信息隐藏在类的内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的访问和操作成员变量private

如一个标准类的实现

提供每一个成员变量对应的`setXxx()`、`getXxx()`

提供一个显示对象信息的`show()`

## Java包

package语句作为Java源文件的第一条语句，指明该源文件定义的类所在的包

本质就是文件夹，对类进行分类管理

```java
package 包名;
```

```java
package sunrise;	//可以是合法标识符
package sun.com.cn;	//可以是若干标识符由`.`号分割
```

### 建包

**手动**

```
在src目录下创建com文件夹，在com下创建zy文件夹
将test.java编译后得到的class文件放到zy目录下
执行，java com.zy.test即可执行
```

**自动**

`javac -d . test.java`即可

### 导包

```
import 包名;
引入包中所有类，用import 包名.*;
引入包中某个类，用import 包名.类名;
```

### 权限

| 修饰符    | 同包同类 | 同一个类中，子类无关类 | 不同包的子类 | 不同包的无关类 |
| --------- | -------- | ---------------------- | ------------ | -------------- |
| private   | 可以     |                        |              |                |
| 默认      | 可以     | 可以                   |              |                |
| protected | 可以     | 可以                   | 可以         |                |
| public    | 可以     | 可以                   | 可以         | 可以           |



## JAR文件

```
使用Java运行环境拓展中的类，使用jar命令把一些类的字节码文件压缩成一个jar文件，将其放到JDK安装目录的jre\lib\ext中
```



## 基本数据类型的类包装

### 常用操作

用于基本数据类型与字符串之间的转换

| 数据类型 | 类包装    | 类的方法                                                     |
| -------- | --------- | :----------------------------------------------------------- |
| byte     | Byte      | Byte(byte num)、byteValue()                                  |
| int      | Integer   | public static Integer valueOf(int num)、public static Integer valueOf(String num) |
| short    | Short     | ...                                                          |
| long     | Long      | ...                                                          |
| float    | Float     | ...                                                          |
| double   | Double    | ...                                                          |
| char     | Character | ...                                                          |

```
Byte(byte num)，表示使用Byte类的构造方法，创建一个Byte类型的对象

byteValue()，该方法可返回该对象含有的byte类型的数据

其余short、long等...用法一致
```

### int和String转换

```java
int转String
返回int参数的字符串表示形式
public static String valueOf(int i)

String转int
将数字的字符串形式转为int类型，是Integer类中的方法
public static int parseInt(String s)
```

### Character类常用方法

```java
isDigit(char ch)//判断数字字符
isLetter(char ch)//判断字母字符
isLetterOrDigit(char ch)//判断数字字符或字母字符
isLowerCase(char ch)//判断小写字母字符   
isUpperCase(char ch)//判断大写字母字符    
toLowerCase(char ch)//判断小写形式    
toUpperCase(char ch)//判断大写字符    
isSpaceChar(char ch)//判断空格    
```

```java
//转小写
public class test{
    public static void main(String args[]){
        char[] a = {'a','b','c','D','E','F'};
        for(int i=0;i<a.length;i++){
            if(Character.isLowerCase(a[i])){
                a[i] = Character.toUpperCase(a[i]);
            }
            else if(Character.isUpperCase(a[i])){
                a[i] = Character.toLowerCase(a[i]);
            }
        }
        for(int i=0;i<a.length;i++){
            System.out.printf("%6c",a[i]);
        }
    }
}
```

## 对象数组

使用基本数据类型的类创建数组，数组中的每个元素是对象

### 声明

```java
A m1,m2,m3;
//等价于
A [] m = new A[3];
```

### 创建

```java
package Test;

class A{
    A(int a){
        System.out.printf("%d\n",a);
    }
}
public class work {
    public static void main(String[] args) {

        A [] m = new A[3];

        m[0] = new A(2);
        m[1] = new A(3);
        m[2] = new A(4);

        for (int i=0;i<=2;i++){
            System.out.println(m[i]);
        }
    }
}
//结果
/*
2
3
4
Test.A@61bbe9ba
Test.A@610455d6
Test.A@511d50c0
*/
```



## 继承

```
一个新类从已有的类那里获得已有的属性和方法
子类(派生类)、父类(基类)
```

### Object类

Object类是Java`java.lang`包下的核心类，是所有类的父类，创建一个类的时候如果没有明确的继承一个父类的话，那么它就是Object的子类

```java
class Person { }

class Person extends Object { }

//二者等价
```

### extends

```
子类名  extends 父类名
默认继承于Object，即 类名 extends Object
```



```java
class family{
    int math = 1;
    String name = "张三";
}

class A extends family{	//继承于父类family
    int high = 180;
}

public  class  test {
    public static void main(String[] args) {
        A a = new A();
        System.out.printf("%d,%s\n",a.math,a.name);		//访问的是父类中的成员变量
    }
}
```

### 变量访问的特点

在子类中访问一个变量，先在子类局部范围找，然后再到子类成员中找，最后到父类成员中找

```java
class family{
    int math = 1;
    int high = 170;
    String name = "张三";
}

class A extends family{	//继承于父类family
    int math = 2;
    String name = "赵四";
}
public  class work {
    public static void main(String[] args) {
        A a = new A();
        System.out.println(a.math  + a.name + a.high); //子类中找不到high变量，所以是父类中的high变量
    }
}
/*结果是
2赵四170
*/
```



### 构造方法的访问特点

```
子类不继承父类的构造方法

子类中的构造方法默认都会访问父类中的无参的构造方法。因为子类继承父类的数据，可能会使用父类的数据，所以在子类初始化前，一定先初始化父类

每个子类的构造方法的第一条默认语句都是super()，即父类的无参构造方法
```



### 成员方法的访问特点

通过子类对象访问一个方法，先在子类局部范围找，然后再到子类成员中找，最后到父类成员中找

```java
package Test;

class family{
    void mc(){
        System.out.println("这是父类");
    }
}

class A extends family{	//继承于父类family
    void mb(){
        System.out.println("这是子类");
    }
}
public  class work {
    public static void main(String[] args) {
        A a = new A();
        a.mc();
    }
}
/*
结果是
这是父类
*/
```



### 子类访问父类的方式

```
在子类内部访问父类成员
通过子类对象名访问父类成员
通过子类的类名访问父类成员
```

### super

代表父类对象引用

**用法**

子类使用super调用父类的构造方法或子类使用super调用被子类隐藏的成员变量和方法

```
super.成员变量，访问父类成员变量
super(参数)，访问父类的构造方法(只能在子类的构造方法里调用)
super.成员方法，访问父类成员方法
```

**注意**

```
子类无法直接继承父类的构造方法，只能通过super语句
如果在子类的构造方法中，显示的写出了super语句，必须保证，该语句是第一条语句，否则出错
```



```java
class family{
    public int i;
    public int j;
    family(int i,int j){
        this.i = i;
        this.j = j;
    }
}

class A extends family{
    public int c;
    A(int i,int j,int c){
        super(i,j);	//调用父类的构造方法
        //family(i,j);	//直接调用父类的构造方法是错的
        this.c = c;
    }
}
public  class  test {
    public static void main(String[] args) {
        A a = new A(1,2,3);
        System.out.printf("%d,%d\n",a.c,a.i);
    }
}
/*结果是
3,1
*/
```

### 成员变量隐藏

子类中定义的成员变量只要和父类中的成员变量同名(类型可以相同也可以不同)，则子类隐藏了父类的同名变量。

被隐藏的父类变量，在子类中可以使用`super`关键字引用

```java
class family{
    int math = 1;
    int high = 170;
}
class A extends family{	//继承于父类family
    String math = "2";		//隐藏了父类的 int math
    int high = 180;			// 隐藏了父类的 int high
    void show(){
        System.out.println(this.math + " " + this.high);    // 2 180
        System.out.println(super.math + " " + super.high);	//	1 170  通过super访问被隐藏的父类变量
    }
}
public  class work {
    public static void main(String[] args) {
        A a = new A();
        a.show();
    }
}
```



### 方法的重写

在子类中重新定义父类的方法

**条件**

```
在子类中重写父类的方法时，子类方法的权限不能低于父类
重写的方法，必须和被重写的方法具有相同的名称、参数列表、返回值类型
```

注意：父类的私有方法不能被重写

```java
class family{
    int math = 1;
    int high = 170;
    void pou(){
        System.out.println("这是被重写的方法");
    }
}
class A extends family{	//继承于父类family
    String math = "2";
    int high = 180;
    void pou(){		 //重写父类中的pou()方法
        System.out.println("这是重写的方法");
    }
}
public  class work {
    public static void main(String[] args) {
        A a = new A();
        a.pou();
    }
}
```



### 注意

```
Java只支持单继承(单继承就是一个类只能有一个父类)
Java可以有多重继承，即一个类可以继承某一个类的子类
父类的私有不能被子类继承，其余都可以，但私有的数据或函数，可以通过可继承的函数间接的去访问
```



```java
class family{
    private String name = "张三";
    private void mc(){
        System.out.println("这是父类");
    }
}

class A extends family{	//继承于父类family
    String name = "赵四";
}
public  class work {
    public static void main(String[] args) {
        A a = new A();
        a.mc();			//因为父类中的mc()方法是私有的，所以无法继承，无法访问
    }
}
```

## 多态

同一个对象，在不同时刻表现出来的不同形态，所以实例化对象的时候，对象的类型还是原来的类，如`Animal a = new Cat();`

如：父类是动物，子类是狗，可以说狗是狗，狗是动物，而不能将动物当作狗

### 条件

```
有继承/实现关系
有方法重写
有父类引用指向子类对象
```

### 成员访问

多态访问成员变量编译看父类，运行看父类。多态访问成员方法编译看父类，运行看子类。

因为成员方法有重写，而成员变量没有

```java
class  Animal{
    public int age = 40;
    public void eat(){
        System.out.println("动物吃东西");
    }
}
class  Cat  extends  Animal{
    public int age = 20;
    public int weight = 10;

    public void eat(){	//方法重写
        System.out.println("猫吃鱼");
    }
    public void play(){
        System.out.println("玩游戏");

    }

}
public  class  test  {
    public  static  void  main(String[]  args)  {
        Animal a = new Cat();	//多态
        System.out.println(a.age);  //成员变量
        System.out.println(a.weight);
        a.eat();    //成员方法运行看子类
        a.play();   //成员方法编译看父类

    }
}
```

## final

final关键字，最终的意思，可以修饰成员方法，成员变量、类

```
修饰方法
表明方法是最终方法，不能被重写

修饰变量
表明变量是常量，不能再次被赋值

修饰类
表明类是最终类，不能被继承

修饰局部变量
变量是基本类型。表示基本数据类型的数据值不能发送改变
变量是引用类型。表示引用类型的地址值不能发生改变，但是地址里面的内容可以发生改变
```



## 抽象类

抽象类是对事物的抽象

### 抽象方法

没有方法体的方法

```java
如
public void show();
```

### 抽象类

类中若有抽象方法，则类必须定义为抽象类

### 抽象类的特点

抽象类和抽象方法必须使用abstract修饰

```java
public abstract class 类名{}	//抽象类
public abstract void 方法名();	//抽象方法
```

抽象类中不一定有抽象方法，有抽象方法的一定是抽象类

抽象类不能实例化

抽象类实例化要参照多态的方式，通过子类对象实例化，这叫抽象类多态

抽象类的子类，要么重写抽象类中的方法，要么是抽象类

```java
//重写抽象类中的方法，通过子类对象实例化来实现抽象类实例化

public abstract class Animal{
    public abstract void eat();
    public void sleep(){
        System.out.println("睡觉");
    }
}
class Cat extends Animal{	
    public void eat(){	//重写抽象类中的方法
        System.out.println("吃鱼");
    }
}

class demo{
    public static void main(String[] args){
	//  Animal a = new Animal();  //抽象类不能实例化
        Animal a = new Cat();		//多态实现实例化
        a.eat();
    }
}
```

```java
//子类是抽象类
public abstract class Animal{
    public abstract void eat();
    public void sleep(){
        System.out.println("睡觉");
    }
}
abstract class Cat extends Animal{	//子类定义为抽象类
}

class demo{
    public static void main(String[] args){
    }
}

```



### 抽象类的成员特点

```
成员变量
常量或变量

构造方法
有构造方法但是不能实例化，作用是用于子类访问父类数据的初始化

成员方法
可以有抽象方法，限定子类必须完整某些动作
也可以有非抽象方法，提高代码的复用性
```



### 抽象类名作为形参和返回值

方法的形参是抽象类名，其实需要的是该抽象类的子类对象

方法的返回值是抽象类名，其实返回的是该抽象类的子类对象

## 接口

java接口是对行为的抽象

### 接口的特点

接口用interface修饰

```java
public interface 接口名{}
```

类实现接口用implements表示，通过类来实现接口

```Java
public class 类名 implements 接口名{}
```

接口不能实例化

```
通过实现类对象实例化，叫接口多态

多态的形式：具体类多态，抽象类多态，接口多态

多态的前提：有继承或实现关系，有方法重写，有父(类/接口)引用指向(子/实现)类对象
```

接口的实现类，要么重写接口中的所有抽象方法，要么是抽象类

```java
//重写接口中的抽象方法
public interface Jumpping {     //创建一个接口
    public abstract void jump();
}

class Cat implements Jumpping{    //用类实现一个接口
    public void jump() {    //重写接口中的抽象方法
        System.out.print("猫");
    }
}
class demo{
public static void main (String[] args){
    Jumpping j = new Cat();     //编译看左边，执行看右边
    j.jump();
    }
}
```

```java
public interface Jumpping {     //创建一个接口
    public abstract void jump();
}
abstract class Cat implements Jumpping{	//抽象类
}

class demo{
public static void main (String[] args){

    }
}
```

### 接口的成员特点

```
成员变量
只能是常量
默认修饰符是public static final

构造方法
接口没有构造方法，因为接口主要对行为进行抽象，没有具体的存在

成员方法
只能是抽象方法
默认修饰符是 public abstract
```



### 接口名作为形参和返回值

方法的形参是接口名，其实需要的是该接口的实现类对象

方法的返回值是接口名，其实返回的是该接口的实现类对象

## 类和接口的关系

```
类和类的关系
继承关系，只能单继承，但是可以多层继承

类和接口的关系
实现关系，可单实现，也可以多实现，还可以在继承一个类的同时实现多个接口

接口和接口的关系
继承关系，可以单继承，也可以多继承
```



## 抽象类和接口的区别

|            | 成员区别                                     |
| ---------- | -------------------------------------------- |
| 抽象类     | 变量、常量、有构造方法、抽象方法、非抽象方法 |
| 接口       | 常量、抽象方法                               |
|            | **关系区别**                                 |
| 类与类     | 继承、单继承                                 |
| 类与接口   | 实现、单实现、多实现                         |
| 接口与接口 | 继承、单继承、多继承                         |
|            | **设计理念区别**                             |
| 抽象类     | 对类抽象，包括属性、行为                     |
| 接口       | 对行为抽象，主要是行为                       |



## 内部类*

就是在一个类中定义一个类

### 格式

```java
public class 类名{
    修饰符 class 类名{
        
    }
}
```

### 访问特点

内部类可以直接访问外部类的成员，包括私有

外部类要访问内部类的成员，必须创建对象

### 成员内部类

在类的成员位置

```java
public class 类名{
    修饰符 class 类名{		//成员内部类
        
    }
}
```

在外界创建对象并访问

```
外部类名.内部类名 对象名 = 外部类对象.内部类对象
```

例

```java
class Outer{

    private int num = 10;

    public class Inner{
        public void show() {

            System.out.println(num);
        }
    }
}

public class test {
    public static void main(String[] args) {
        Outer.Inner a = new Outer().new Inner();
        a.show();
    }   
}
```



### 局部内部类

在类的局部位置

```java
public class 类名{
    修饰符 void 函数名(){
        修饰符 class 类名{		//局部内部类
            
        }
    }
}
```

局部内部类是在方法中定义的类，外界无法直接使用，需要在方法内部创建对象并使用该类可以直接访问外部类的成员，也可以访问方法内部的局部变量

```java
class Outer{

    private int num = 10;

    public void method(){
        int number = 20;
        class Inner{
            public void show(){
                System.out.println(num);		//
                System.out.println(number);		//
            }
        }
        Inner i = new Inner();
        i.show();
    }
}

public class test {
    public static void main(String[] args) {
        Outer a = new Outer();
        a.method();
    }
}
```





## 匿名内部类*

前提：存在一个类或接口，这里的类可以是具体的类，也可以是抽象类

本质：是一个继承了该类或实现了该接口的子类匿名对象

```java
new 类名或接口名(){
    重写方法;
}

如
    
new Inter(){
    public void show(){
        
    }
}
```

调用

```java
interface Inter {
    void show();
}

class Outer {
    public void method() {

        new Inter() {			// 实现了 Inter 接口
            @Override
            public void show() {
                System.out.println("调用匿名内部类");
            }
        }.show();		//因为相当于对象，所以直接调用方法
    }
}
public class test {
    public static void main(String[] args) {
        Outer i = new Outer();
        i.method();

    }
}
```

多次调用，因为本质是一个继承了该类或实现了该接口的子类匿名对象

所以可以

```Java
接口名 对象名 = 匿名内部类

如
    
         Inter i = new Inter() {
            @Override
            public void show() {
                System.out.println("调用匿名内部类");
            }
        }
```



## 异常类

### 异常体系

```
编译时异常(受检异常)
必须显示处理

运行时异常(非受检异常)
所有的RuntimeException类及其子类被称为运行时异常
无须显示处理，修改错误代码即可
```

### Throwable

**Error**

严重问题，不需要处理

**Exception**

```
RuntimeException
在编译期是不检测的，需要修改代码

非RuntimeException
编译器就必须处理，否则编译不能通过
```

### JVM的默认处理

程序出错后，JVM会默认处理

```
把异常名称，异常原因，异常出现的位置，输出到控制台
程序停止运行
```

### 异常处理

**try-catch语句**

程序从try中执行代码，出现异常，自动生成一个异常类对象，该异常对象将被提交给Java运行时的系统

当Java运行时系统接收到异常对象时，会到catch中去找匹配的异常类，找到后进行异常的处理

执行完毕后，程序还可以继续往下执行

```java
try{
    可能出现异常的程序
}
catch(异常类型   异常对象){		//指定可能出现的异常类型，必须是Throwable的子类

    异常处理的代码
}
```

**finally语句**

可省略

不管是否会出现异常，finally都会执行，通常用于进行资源清除、关闭打开的文件等最后进行的处理

```java
try{      //指定可能出现异常的Java语句范围
    java语句
}
catch(异常类型1   异常对象1){    //指定可能出现的异常类型，必须是Throwable的子类
    异常处理                               //异常处理
}
catch(异常类型2   异常对象2){
    异常处理
}
……
finally{                          //可省略
    //不管是否会出现异常，finally都会执行，通常用于进行资源清除、关闭打开的文件等最后进行的处理
}

```



**throw**

try-catch-finally是由java虚拟机抛出异常并用catch捕获异常进行处理。Java系统还提供了throw关键字，由程序本身主动抛出类异常对象，并对此异常进行处理

```java
throw 异常类对象 (必须为Throwable子类对象)
```

例

```java
public class work {
    public static void main(String[] args) {
        int a=5,b=0;
        try{
        	if(b==0)
        	    throw new ArithmeticException();		//
        	else
        	    System.out.println(a/b);
        }
        catch(ArithmeticException e){
        	System.out.println("除数不能为零！");
        	e.printStackTrace();   //显示异常信息
        }
    }
}
```

**throws**

写在可能出现异常的方法声明之后，throws可以列出多个可能出现的系统异常，用逗号分隔。声明该方法可能会出现异常

```java
throws 异常类名;
```

例子

```java
public class TestThrows{
	public static void main(String[] args){
		try{
			test();
		}
		catch(Exception e)
		{
			System.out.println(e.getMessage());	
		}		
	}
	static void test() throws ArithmeticException{		//
		System.out.println(6/0);
	}
}
```

**throw和throws区别**

| throws                                           | throw                              |
| ------------------------------------------------ | ---------------------------------- |
| 用在方法声明后面，跟的是异常类名                 | 用在方法体内，跟的是异常对象名     |
| 表示抛出异常，由该方法的调用者来处理             | 表示抛出异常，由方法体内的语句处理 |
| 表示出现异常的一种可能性，并不一定会发生这些异常 | 执行throw一定抛出了某种异常        |

注意

```
编译时异常必须进行处理，可用try-catch或throws，若使用throws，将来谁调用谁处理
运行时异常可以不处理，出问题后修改代码 
```

### Throwable的成员方法

| 方法名                        | 说明                            |
| ----------------------------- | ------------------------------- |
| public String getMessage()    | 返回此throwable的详细消息字符串 |
| public String toString()      | 返回此可抛出的简短描述          |
| public void printStackTrace() | 把异常的错误信息输出在控制台    |

```java
try{
      test(1,2,5);
      System.out.println("end");
    }catch( AnswerWrongException e){
        e.printStackTrace();
    }
```



### 自定义异常

自定义继承Exception的异常类，并规定哪些方法产生这样异常

使用自定义的异常类创建对象，并抛出所创建的异常对象

```Java
public class 异常类名 extends Exception{
    无参构造
    带参构造
}
```

例

```java
import java.util.Scanner;

class ScoreException extends Exception{
    public ScoreException(){}

    public ScoreException(String message){
        super(message);
    }
}


class Check {
    public void checkScore(int score) throws ScoreException{
        if(score<0 || score>100){
            //throw new ScoreException();
            throw new ScoreException("分数异常，分数超范围");

        }else {
            System.out.println("分数正常");
        }
    }
}

class ScanScore{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入分数");
        int score = sc.nextInt();

        Check t = new Check();
        try {
            t.checkScore(score);
        } catch (ScoreException e) {
            e.printStackTrace();
        }
    }
}
```

### 常见异常类

```
IOException：输入输出异常
ArithmeticException：数学异常
int a=12 / 0;  //抛出ArithmeticException
NullPointerException：空指针异常
Date d= null;
System.out.println(d.toString());  //NullPointerException
ArrayIndexOutOfBoundsException：下标越界异常
int[] array=new int[4];
array[7]=1;  //抛出ArrayIndexOutOfBoundsException
ClassCastException：类型转换异常:
Animal animal=new Dog();
Cat cat=(Animal)animal;
```

## 泛型

```
本质是将所操作的数据类型指定为一个参数
将类型由原来的具体的类型参数化，然后在使用、调用时传入具体的类型
这种参数可用在类、方法、接口中，分别被称为泛型类、泛型方法、泛型接口
```

### 格式

```
<类型> ：指定一种类型的格式，这里的类型可以看作是形参
<类型1，类型2> ：指定多种类型的格式，多种类型之间用逗号隔开，这里的类型可以看作是形参
将来具体调用的时候，给定的类型可以看作实参，并且实参的类型只能是引用数据类型
```

### 优点

把运行时期的问题提前到了编译期间

避免了强制类型转换

### 泛型类

```
修饰符 class 类名<类型>{}
如
public class Demo<T>{}
注意：
此处T可以随便写为任意标识，常见如T、E、K、V等形式的参数常用于表示泛型
```

例

```java

class Generic<T>{
    public void show(T t){
    }
}

public class test {
    public static void main(String[] args) {
        Generic<Integer> g1 = new Generic<Integer>();	//
        g1.show(2);
        Generic<String> g2 = new Generic<String>();		//
        g2.show("字符串");

    }
}
```

### 泛型方法

```
修饰符 <类型> 返回值类型 方法名(类型 变量名){}
如
public <T> void show(T t){}
```

例

```java

class Generic{
    public <T> void show(T t){		//
        System.out.println(t);
    }
}

public class test {
    public static void main(String[] args) {
        Generic g1 = new Generic();		//
        g1.show(2);
        Generic g2 = new Generic();		//
        g2.show("字符串");

    }
}
```



### 泛型接口

```java

interface Generic<T>{
    void show(T t);
}

class GenericImpl<T>implements Generic<T> {
    @Override
    public void show(T t){
        System.out.println(t);
    }
}

public class test {
    public static void main(String[] args) {
        Generic<String> g1 = new GenericImpl<String>();
        g1.show("字符串");
        Generic<Integer> g2 = new GenericImpl<Integer>();
        g2.show(20);

    }
}
```



### 类型通配符

类型通配符`<?>`

```
List<?>表示元素类型未知的List，它的元素可以匹配任何的类型
这种带通配符的List仅表示它是各种泛型List的父类，并不能把元素添加到其中
```

如果不希望`List<?>`是任何泛型List的父类，只希望它代表某一类泛型List的父类，可使用类型通配符的上限

```
类型通配符上限<?extends类型>
List<?extends Number>表示它的类型是Number或其子类型
```

通配符下限

```
类型通配符下限<?super 类型>
List<?super Number>它表示的类型是Number或其父类型
```

例

```java
import java.util.ArrayList;
import java.util.List;

class Demo{
    public static void main(String[] args) {
        //类型通配符<?>
        List<?> list1 = new ArrayList<Object>();
        List<?> list2 = new ArrayList<Number>();
        List<?> list3 = new ArrayList<Integer>();

        //通配符上限 <? extends 类型>
        //错误 List<? extends Number> list4 = new ArrayList<Object>();
        List<? extends Number> list5 = new ArrayList<Number>();
        List<? extends Number> list6 = new ArrayList<Integer>();

        //类型通配符下限 <? super 类型>
        List<? super Number> list7 = new ArrayList<Object>();
        List<? super Number> list8 = new ArrayList<Number>();
        //错误 List<? super Number> list9 = new ArrayList<Integer>();
    }
}
```



### 可变参数

函数中传参，可传多个参数

**格式**

在指定参数类型后加一个省略号`...`

一个方法中只能指定一个可变参数，而且它必须是方法的最后一个参数

```java
class Args {
    int sum(int ...a){      //可变参数
        return 0;
    }
}

class Demo{
    public static void main(String[] args) {

        Args a  = new Args();
        System.out.println(a.sum(1,2,3));
        System.out.println(a.sum(1));
    }
}
```

**可变参数的使用**

Arrays工具中的一个静态方法

```
public static <T>List<T> asList(T...a)
返回由指定数组支持的固定大小的列表
返回的集合不能做增删操作，可以做修改操作
```

List接口中的一个静态方法

```
public static <E>List<E> of(E...elements)
返回包含任意数量元素的不可变列表
返回的集合不能做增删改操作
```

Set接口中的一个静态方法

```
public static <E>Set<E> of(E...elements)
返回一个包含任意数量元素的不可变集合
返回的集合不能做增删操作，没有修改的方法
```


## String类

String类在java.lang包下，使用时不需要导包

String类代表字符串，Java程序中的所有双引号字符串，都是String类的对象

### 字符串的特点

```
字符串不可变，它们的值在创建后不能更改
字符串可被共享
字符串效果上相当于字符数组char[]，但底层原理是字节数组byte[]
```

### String构造方法

| 方法名                    | 说明                                 |
| ------------------------- | ------------------------------------ |
| public String()           | 创建一个空白字符串对象               |
| public String(char[] chs) | 根据字符数组的内容，来创建字符串对象 |
| public String(byte[] bys) | 根据字节数组的内容，来创建字符串对象 |
| String s = "abc"          | 直接赋值的方式创建字符串对象         |



```java
class Str{
    public static void main(String[] args) {

        String s1 = new String();
        System.out.println("s1:" + s1);

        char[] chs = {'a','b','c'};
        String s2 = new String(chs);
        System.out.println("s2:" + s2);

        byte[] bys = {97,98,99};    //a、b、c 在底层存储的值
        String s3 = new String(bys);
        System.out.println("s3:" + s3);

        String s4 = "abc";
        System.out.println("s4:" + s4);
    }
}
```



### String对象的特点

以new方法创建的字符串对象，每一次new都会申请一个内存空间，虽然内容相同，但是地址不同

```java
char[] chs = {'a','b','c'};
String s2 = new String(chs);
String s3 = new String(chs);
```

以`""`直接赋值的方式创建的字符串，只要字符串序列相同(顺序和大小写相同)，无论在程序中出现几次，它们都属于同一个String对象

```java
String s2 = "123";
String s3 = "123";
```



### 字符串的比较

使用`==`做比较

```
判断两个对象的引用是否一致

基本类型：比较的是数据值

引用类型：比较的是地址值
```



字符串是对象，比较内容需要使用`equals()`

检测两个对象是否相等，即两个对象的内容是否相等

```java
public boolean equals(Object anObject)
    
将此字符串与指定对象进行比较，参数直接传递一个字符串
```

例

```java
class Str{
    public static void main(String[] args) {


        char[] chs = {'a','b','c'};
        String s2 = new String(chs);


        String s4 = "abc";

        String s5 = "abc";


        System.out.println(s5 == s4);   //true
        System.out.println(s5.equals(s4));  //true

        System.out.println(s5 == s2);   //false
        System.out.println(s5.equals(s2));  //true


    }
}
```



### 字符串遍历

字符串的长度`字符串对象.length()`

```java
for(int i=0;i<s5.length();i++){
    System.out.println(s5.charAt(i));       
    //指定索引处的字符值
}
```

### 总结

| 方法名                                 | 说明                             |
| -------------------------------------- | -------------------------------- |
| public boolean equals(Object anObject) | 比较字符串的内容，严格区分大小写 |
| public char charAt(int index)          | 返回字符串指定索引处的值         |
| public int length()                    | 返回此字符串的长度               |



## StringBuilder类

对字符串进行拼接，每次拼接，都会构建一个新的String对象，浪费内存

使用StringBuilder类可以解决这个问题，即所有操作都是对同一个String对象进行的

### StringBuilder构造方法

| 方法名                           | 说明                                   |
| -------------------------------- | -------------------------------------- |
| public StringBuilder()           | 创建一个空白可变字符串                 |
| public StringBuilder(String str) | 根据字符串的内容，来创建可变字符串对象 |

```java
class Str{
    public static void main(String[] args) {

        String s5 = "abc";
        
        StringBuffer sb = new StringBuffer(s5);
        System.out.println("ss" + sb);
    }
}
```



### StringBuilder的添加和反转

| 方法名                                | 说明                     |
| ------------------------------------- | ------------------------ |
| public StringBuilder append(任意类型) | 添加数据，并返回对象本身 |
| public StringBuilder reverse()        | 返回相反的字符序列       |

添加

```java
class Str{
    public static void main(String[] args) {

        //String s5 = "abc";

        StringBuffer sb = new StringBuffer();
        StringBuffer sb1 = sb.append("123");
        System.out.println("sb" + ":" + sb);	//sb的内容和sb1的内容一样
        System.out.println("sb1" + ":" + sb1);
        System.out.println(sb==sb1);			//地址相同
    }
}

//结果是
sb:123
sb1:123
true
```



反转

```java
class Str{
    public static void main(String[] args) {

        //String s5 = "abc";

        StringBuffer sb = new StringBuffer();
        StringBuffer sb1 = sb.append("123");

        System.out.println("sb" + ":" + sb);
        System.out.println("sb1" + ":" + sb1);

        sb1.reverse();

        System.out.println("sb" + ":" + sb);
        System.out.println("sb1" + ":" + sb1);
    }
}

//结果为
sb:123
sb1:123
sb:321
sb1:321

```

### StringBuilder的插入和删除

| 方法名                               | 说明                         |
| ------------------------------------ | ---------------------------- |
| public insert((int offset, 任意类型) | 在指定索引offset处插入值i    |
| public delete(int start, int end)    | 移除此序列的子字符串中的字符 |

```java
public class work {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer();
        StringBuffer sb1 = sb.append("123456");
        sb1.insert(1,"abc");			// 1abc23456
        System.out.println(sb);
    }
}
```



### StringBuilder的替换

| 方法名                                         | 说明                                                   |
| ---------------------------------------------- | ------------------------------------------------------ |
| public replace(int start, int end, String str) | 使用给定 `String` 中的字符替换此序列的子字符串中的字符 |

```java
public class work {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer();
        StringBuffer sb1 = sb.append("123456");
        sb1.replace(1,3,"abc");			// 1abc456
        System.out.println(sb);
    }
}
```



### String和StringBuilder的转换

StringBuilder转为String

通过toString()就可以实现把StringBuilder转换为String

```java
public String toString()
```

例

```java
class Str{
    public static void main(String[] args) {

        StringBuffer sb = new StringBuffer();
        StringBuffer sb1 = sb.append("123");

        String s = sb.toString();	//实现转换
        System.out.println(s);
    }
}
```



String转为StringBuilder

通过构造方法实现把String转换为StringBuilder

```java
public StringBuilder(String s)
```

例

```java
class Str{
    public static void main(String[] args) {
        String s = "abc";
        StringBuilder sb = new StringBuilder(s);	//实现转换
        System.out.println(sb);
    }
}
```



## StringTokenizer类

将字符串分解成可被独立使用的单词

StringTokenizer一个对象称为字符串分析器

### 构造方法

| 方法名                                  | 说明                                                         |
| --------------------------------------- | ------------------------------------------------------------ |
| StringTokenizer(String s)               | 为字符串s构造一个分析器，使用默认的分隔符集合，即空格符（若干个空格被看做一个空格）、换行符、回车符、Tab符 |
| StringTokenizer(String s, String delim) | 为字符串s构造一个分析器，参数dilim中的字符被作为分隔符       |

### 方法

| 方法名                  | 说明                                                         |
| ----------------------- | ------------------------------------------------------------ |
| String nextToken()      | 查找下一个标记，并返回当前单词                               |
| int countTokens()       | 获得可以调用此 tokenizer 的 nextToken 方法的次数，即计数变量的值 |
| boolean hasMoreTokens() | 测试此 tokenizer 的字符串中是否还有更多的可用标记。只要计数的变量的值大于0，该方法就返回true，否则返回false |



## 正则表达式

正则表达式是含有一些具有特殊意义字符的字符串，也称作模式

### 元字符模式

元字符是正则表达式中特殊字符

用一对方括号括起若干个字符，代表方括号中的任何一个字符

| 字符     | 描述                          |
| -------- | ----------------------------- |
| `[abc]`  | 代表a、b、c中的任何一个       |
| `[^abc]` | 代表除了a、b、c以外的任何字符 |
|          |                               |
|          |                               |
|          |                               |
|          |                               |

代表单个字符的元字符

| 元字符 | 在正则表达式中的写法 | 意义                                           |
| ------ | -------------------- | ---------------------------------------------- |
| `.`    | `.`                  | 代表任何一个字符                               |
| `\d`   | `\\d`                | 代表0至9的任何一个数字                         |
| `\D`   | `\\D`                | 代表任何一个非数字字符                         |
| `\s`   | `\\s`                | 代表空格类字符，`\t`、`\n`、`\x0B`、`\f`、`\r` |
| `\S`   | `\\S`                | 代表非空格类字符                               |
| `\w`   | `\\w`                | 代表可用于标识符的字符                         |
| `\W`   | `\\W`                | 代表不能用于标识符的字符                       |

### 限定符模式

X代表元字符或普通字符

| 带限定符号的模式 | 意义           |
| ---------------- | -------------- |
| `X?`             | X出现0次或1次  |
| `X*`             | X出现0次或多次 |
| `X+`             | X出现1次或多次 |
| `X{n} `          | X恰好出现n次   |
| `X{n,}`          | X至少出现n次   |
| `X{n,m}`         | X出现n次至m次  |



## 正则表达式与字符串分解 

用指定的正则表达式regex做为分隔标记分解出原字符串中的单词，并将分解出的单词存放在字符串数组中

```java
public String[] split(String regex)
```

例

```java
public class work {

    public static void main(String[] args) {
        String str = "2009年9月9日";
        String digi[]=str.split("\\D+");			// 2009  9  9


        for (String s: digi) {
            System.out.println(s);
        }
    }
}
```



## 模式匹配

检索和指定模式匹配的字符串

模式匹配的类，这些类在`java.util.regex`包中

### 步骤

使用Pattern类的compile方法建立模式对象

```java
public static Pattern compile(String regex, int flags)
```

例

```java
p=Pattern.compile("\\d");
```

参数flags可以取下列有效值

```
Pattern .CASE_INSENSITIVE启用不区分大小写的匹配
Pattern.MULTILINE启用多行模式 
Pattern.DOTALL匹配任何字符，包括行结束符
Pattern.UNICODE_CASE不区分大小写的匹配 Unicode 
```

使用模式对象的matcher方法建立匹配对象

```java
String s1="0ad1ay2as";
p=Pattern.compile(""\\da");
m=p.matcher(s1);		//建立匹配对象
```

使用Matcher类对象的常用方法进行匹配

| 常用方法                   | 说明                                                         |
| -------------------------- | ------------------------------------------------------------ |
| public boolean lookingAt() | 从input开始位置的输入序列与该模式匹配                        |
| public boolean find()      | 寻找input和patter匹配的下一子序列。若返回true，m调用start()和end()方法可以得到该匹配模式子序列在input中的开始和结束位置 |
| public String group()      | 返回由以前匹配操作所匹配的输入子序列                         |
| public boolean matches()   | 判断input是否完全和patter匹配                                |

```java
class work {
    public static void main(String[] args) {
        String str = "2009年9月9日";
        Pattern p = Pattern.compile("\\d");
        Matcher m = p.matcher(str);
        boolean a =  m.find();
        System.out.println(a);		// true
    }
}
```



## 集合体系

一种存储空间可变的存储模型

### Collection(单列)

**List(可重复)**

```
ArrayList
底层用数组实现

LinkedList
底层用链表实现
```

**Set(不可重复)**

```
HashSet
底层数据结构是哈希表

TreeSet
```

### Map(双列)

HashMap

## Collection

是单列集合的顶层接口，它表示一组对象

### 创建Collection对象

多态的方式

具体的实现类ArrayList

```java
Collection<String> c = new ArrayList<String>();
```

### 方法

| 常用方法                   | 说明                             |
| -------------------------- | -------------------------------- |
| boolean add(E e)           | 添加元素                         |
| boolean remove(Object o)   | 移除指定元素                     |
| void clear()               | 清空集合中的元素                 |
| boolean contains(Object o) | 判断集合中是否存在指定的元素     |
| boolean isEmpty()          | 判断集合是否为空                 |
| int size()                 | 集合的长度，也是集合中元素的个数 |



### 遍历Collection

Iterator迭代器，集合专用的遍历方式

```
Iterator<E> iterator()返回此集合中元素的迭代器，通过集合的iterator()方法得到的
```



```java
Collection<String> c = new ArrayList<String>();
Iterator<String> it = c.iterator();
```

Iterator的常用方法

```
E next()  返回迭代中的下一个元素
boolean hasNext()  如果迭代时，还有元素未被迭代，则返回true
```



```java
class work{
    public static void main(String[] args) {

        Collection<String> c = new ArrayList<String>();
        c.add("hello");
        c.add("java");
        c.add("ja");
        
        Iterator<String> it = c.iterator();
        while (it.hasNext()){
            String s= it.next();
            System.out.println(s);
        }
    }
}
```



## List

有序集合，用户可以通过索引来增删改查元素

与Set集合不同，列表通常允许重复元素

### 创建List对象

```java
 List<String> c = new ArrayList<String>();
```

### 常用方法

Collection中的方法，List也可使用

| 特有方法                      | 说明 |
| ----------------------------- | ---- |
| void add(int index,E element) | 插入 |
| E remove(int index)           | 删除 |
| E set(int index,E element)    | 修改 |
| E get(int index)              | 查找 |

### 遍历

```java
class work{
    public static void main(String[] args) {

        List<String> c = new ArrayList<String>();
        c.add("hello");
        c.add("java");
        c.add("hello");

        for (int i = 0;i<c.size();i++ ){
            System.out.println(c.get(i));
        }
```

### 列表迭代器

ListIterator

```
通过List集合的listIterator()方法得到
允许向任一方向遍历、在迭代期间修改列表，并获取列表中迭代器的当前位置
```

方法

```
E next()  返回迭代中的下一个元素
boolean hasNext()  如果迭代时，还有元素未被迭代，则返回true
E previous() 返回列表中的上一个元素
boolean hasPrevious() 如果列表在反方向遍历时，还有元素未被迭代，则返回true
void add(E e)  插入元素
```

## LinkedList

### 创建

```java
LinkedList<String> LinkList = new LinkedList<String>();
```

### 特有功能

| 方法名                    | 说明                         |
| ------------------------- | ---------------------------- |
| public void addFirst(E e) | 在列表开头插入指定元素       |
| public void addLast(E e)  |                              |
| public E getFirst()       | 返回列表中的第一个元素       |
| public E getLast()        |                              |
| public E removeFirst()    | 从列表中删除并返回第一个元素 |
| public E removeLast()     |                              |



## ArrayList

集合，存储容量可变的存储模型

### `ArrayList<E>`

可调整大小的数组实现，使用时将E替换为集合中的数据类型即可

```java
ArrayList<String> array = new ArrayList<String>();
```



### 构造方法

| 方法                                 | 说明                       |
| ------------------------------------ | -------------------------- |
| public ArrayList()                   | 创建一个空集合对象         |
| public boolean add(E e)              | 将指定元素追加到集合的末尾 |
| public void add(int index,E element) | 在集合指定位置插入元素     |

 例

```java
public class test{
    public static void main(String[] args) {
        ArrayList<String> array = new ArrayList<String>();
        array.add("woaini");
        array.add("huake");
        array.add(1,"123");

        System.out.println(array);
    }
}
```

### 常用方法

| 方法名                            | 说明                                   |
| --------------------------------- | -------------------------------------- |
| public boolean remove(Object o)   | 删除指定元素，返回删除是否成功         |
| public E remove(int index)        | 删除指定索引处的元素，返回被删除的元素 |
| public E set(int index,E element) | 修改指定索引处的元素，返回被修改的元素 |
| public E get(int index)           | 返回指定索引处的元素                   |
| public int size()                 | 返回集合中元素的个数                   |

```java
public class test{
    public static void main(String[] args) {
        ArrayList<String> array = new ArrayList<String>();
        array.add("woaini");
        array.add("huake");
        array.add(1,"123");

        System.out.println(array);
        System.out.println(array.size());
        System.out.println(array.set(1,"test"));
        System.out.println(array.get(2));
        System.out.println(array.remove("123"));
        System.out.println(array.remove(0));
    }
}
```

### 例子

用集合存储学生对象并遍历

```java
class Student{
    // 成员变量
    private String name;
    private int age;
    //无参构造方法
    public Student(){};
    //有参构造方法
    public Student(String name,int age){
        this.name = name;
        this.age = age;
    }

    //成员方法
    public void setName(String name){
        this.name = name;
    }
    public String getName(){
        return name;
    }
    public void setAge(int age){
        this.age = age;
    }
    public int getAge(){
        return age;
    }
    public void show(){
        System.out.println(name + "," + age);
    }
}

public class test{
    public static void main(String[] args) {
        ArrayList<Student> array = new ArrayList<Student>();


        Student s1 = new Student("hou",12);
        Student s2 = new Student("den",13);
        Student s3 = new Student("zhao",14);
        array.add(s1);
        array.add(s2);
        array.add(s3);


        for(int i=0;i<array.size();i++){
            System.out.println(array.get(i));
        }
    }
}
```



## Set

方法和Collection一样

不包含重复元素

没有带索引的方法，所以不能使用for循环遍历，但可使用增强for遍历

```java
class work{
    public static void main(String[] args) {
        Set<String> ss = new HashSet<String>();
        ss.add("asd");
        ss.add("123");

        System.out.println(ss.size());
        for (String s:ss){
            System.out.println(s);
        }

    }
}
```



## 哈希值

JDK根据对象的地址或字符或数字计算出的int类型的数值

Object类的一个方法可获取哈希值

```java
public int hashCode()
```

同一对象多次调用hashCode()，返回的值相同

## HashSet

```
对集合的迭代顺序不作任何保证
没带索引的方法，不能使用for循环，只能使用增强for、迭代器进行遍历
没有重复元素
```

### 创建

```java
HashSet<String> hs = new HashSet<String>();
```

## TreeSet

元素根据构造方法排序

```
TreeSet() 根据元素的自然排序，进行排序

TreeSet(Comparator comparator) 根据指定的比较器进行排序
```

没有带索引的方法

没重复数据

### 创建

```java
TreeSet<String> ts = new TreeSet<String>();
```



### 自然排序Comparable

```
使用TreeSet集合存储自定义对象
无参构造方法使用的是自然排序，即让元素所属的类实现Comparable接口，重写compareTo(To)方法
重写方法时，需要按照排序条件的主次来写
```



```java
package Test;

import java.util.*;

class student implements Comparable<student> {
    private int age;
    private String name;
    student(){}
    student(String name,int age){
        this.age = age;
        this.name = name;
    }
    String getName(){
        return name;
    }
    int getAge(){
        return age;
    }
    public int compareTo(student s){		//按照年龄排序
        int num = this.age - s.age;
        return num;
    }
}

class work{
    public static void main(String[] args) {
     TreeSet<student> ts = new TreeSet<student>();


     student s1 = new student("xixi",50);
     student s2 = new student("zhao",12);
     student s3 = new student("dalao",60);

     ts.add(s1);
     ts.add(s2);
     ts.add(s3);

     for (student s:ts){
         System.out.println("name:" + s.getName() + "age:" + s.getAge());
        }
    }
}
```

### 比较器排序Comparable

```
使用TreeSet集合存储自定义对象
带参构造方法使用的是比较器排序，即让集合构造方法接收Comparable的实现类对象，重写compareTo(To1,To2)方法
重写方法时，需要按照排序条件的主次来写
```

## Map

```
Interface Map<K,V>  K为键的类型，V为值的类型
将键映射到值的对象
不包含重复的键，每个键最多可对应一个值
当键重复值，键的值会覆盖
```



### 创建

多态的方式

具体的实现类HashMap

```java
Map<String,String> map = new HashMap<String,String>();
```

### 方法

| 常用方法                            | 说明                             |
| ----------------------------------- | -------------------------------- |
| V put(K key,V value)                | 添加元素                         |
| V remove(Object key)                | 根据键删除键值元素               |
| void clear()                        | 移除所有键值对元素               |
| boolean containsKey(Object key)     | 判断集合是否包含指定的键         |
| boolean containsValue(Object value) | 判断集合是否包含指定的值         |
| boolean isEmpty()                   | 判断集合是否为空                 |
| int size()                          | 集合的长度，即集合中键值对的个数 |

```java
class work{
    public static void main(String[] args) {
        Map<String,String> map = new HashMap<String,String>();

        map.put("zhao","123");
        map.put("hou","456");
        System.out.println(map);     
    }
}
```

### 获取功能

| 方法名                           | 说明                   |
| -------------------------------- | ---------------------- |
| V get(Object key)                | 根据键获取值           |
| `Set<K> keySet()`                | 获取所有键的集合       |
| `Collection<V> values()`         | 获取所有集合           |
| `Set<Map.Entry<K,V>> entrySet()` | 获取所有键值对象的集合 |

### 遍历

先获取所有键的集合(使用keySet())，再遍历键的集合获取每个对应的值(使用增强for)

```java
class work{
    public static void main(String[] args) {

        Map<String,String> map = new HashMap<String,String>();

        map.put("zhao","123");
        map.put("hou","456");

        Set<String> keySet = map.keySet();
        for(String key: keySet){
            String value = map.get(key);
            System.out.println(key + "," + value);
        }
    }
}
```

获取所有键值对对象的集合(`Set<Map.Entry<K,V>> entrySet()`)，再遍历键值对对象的集合，得到每一个键值对对象(用增强for)`Map.Entry`，最后根据键值对对象获取键(getKey())和值(getValue())

```java
class work{
    public static void main(String[] args) {

        Map<String,String> map = new HashMap<String,String>();

        map.put("zhao","123");
        map.put("hou","456");

        Set<Map.Entry<String,String>> entrySet = map.entrySet();
        for(Map.Entry<String,String> m: entrySet){
            String key = m.getKey();
            String value = m.getValue();
            System.out.println(key + "," + value);
        }
    }
}
```

## Stack

栈是Vector的一个子类，它实现了一个标准的后进先出的栈

### 创建

```java
Stack<Integer> st = new Stack<Integer>();
```

### 方法

| 方法名                      | 说明                                             |
| :-------------------------- | :----------------------------------------------- |
| boolean empty()             | 测试堆栈是否为空                                 |
| Object peek( )              | 查看堆栈顶部的对象，但不从堆栈中移除它。         |
| Object pop( )               | 移除堆栈顶部的对象，并作为此函数的值返回该对象。 |
| Object push(Object element) | 把项压入堆栈顶部。                               |
| int search(Object element)  | 返回对象在堆栈中的位置，以 1 为基数。            |

## 常用实用类

### Date类

Date对象

| 方法名                                                    | 说明                                                         |
| --------------------------------------------------------- | ------------------------------------------------------------ |
| public Date()                                             | 获取本地当前时间                                             |
| public Date(long time)                                    | time表示相对1970年1月1日0点（GMT）的毫秒数                   |
| System类的静态方法 public static long currentTimeMillis() | 返回当前时间与 1970 年 1 月 1 日0点（GMT）之间的时间差（以毫秒为单位测量） |

```java
Date now=new Date(System.currentTimeMillis());
```

格式化时间

DateFormat的子类SimpleDateFormat来实现日期的格式化

用参数pattern指定的格式创建一个对象，该对象调用 format(Date  date)方法格式化时间对象date

```java
 public SimpleDateFormat(String pattern)
```

例

```java
Date nowTime=new Date();
System.out.println("现在的时间:"+nowTime);
SimpleDateFormat matter1=new SimpleDateFormat("yyyy-MM-dd");
System.out.println("现在的时间:"+matter1.format(nowTime));
```



### Calendar类

使用Calendar类的static方法创建对象

```java
public static Calendar getInstance() 
```

例

```java
Calendar  calendar= Calendar.getInstance();			//初始化一个日历对象
```

calendar对象调用方法设置时间

```java
final void setTime( Date date) 
void setTimeZone( TimeZone value) 
final void set(int year,int month,int date)
final void set(int year,int month,int date,int hour,int minute)
final void set(int year,int month, int date, int hour, int minute,int second)
```

calendar对象调用方法获取时间

| 方法名                        | 说明                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| public int get(int field)     | 返回给定的日历字段的值，如年份、月份、小时、星期等信息。参数field的有效值由Calendar的静态常量指定(YEAR、MONTH、DAY_OF_MONTH、DAY_OF_WEEK、DAY_OF_YEAR、HOUR、MINUTE、SECOND、WEEK_OF_MONTH)，特别注意：1表示周日，7周六，0表示一月 |
| public long getTimeInMillis() | 可以将时间表示为毫秒                                         |

```java
        Calendar calendar= Calendar.getInstance();
        System.out.println(calendar.get(Calendar.YEAR));
```



### Math类

### System类

| 方法名                                 | 说明                                       |
| -------------------------------------- | ------------------------------------------ |
| public static void exit(int status)    | 终止当前运行的Java虚拟机，非零表示异常终止 |
| public static long currentTimeMillis() | 返回当前时间，毫秒为单位                   |

```java
class work{
    public static void main(String[] args) {

        System.exit(0);		// 直接退出虚拟机
        System.out.println("123");	//该语句不执行
    }
}
```



### Object类

Object类是类层次结构的根，每个类都可以将Object作为超类，所有类直接或间接继承自该类

构造方法

```java
public Object()
```

| 方法名                            | 说明                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| public String toString()          | 建议重写该方法（按 Alt + insert，自动生成）                  |
| public boolean equals(Object obj) | 比较对象是否相等，默认比较地址，重写可比较内容（也可自动生成） |

```java
package Test;

import java.util.Scanner;
import java.util.Stack;


class test {
    private int age =12;
    private String name = "张";
    void setAge(int age){
        this.age = age;
    }
    void setName(String name){
        this.name = name;
    }
    // 按 Alt + insert

    @Override
    public String toString() {
        return "test{" +
                "age=" + age +
                ", name='" + name + '\'' +
                '}';
    }
}

class work{
    public static void main(String[] args) {

        test a = new test();
        System.out.println(a);      //Test.test@14ae5a5    //  重写后 test{age=12, name='张'}
        
      // 直接输出 a 会调用Object类中的toString方法，需要重写该方法才能得到我们想要的格式
    }
}
```

### Arrays类

包含用于操作数组的各种方法

| 方法名                                 | 说明                           |
| -------------------------------------- | ------------------------------ |
| public static String toString(int[] a) | 返回数组的内容的字符串表示形式 |
| public static void sort(int[] a)       | 按数字顺序排列数组             |

```java
class work{
    public static void main(String[] args) {

       int a [] = {4,5,2,3,1};
        System.out.println(Arrays.toString(a));		//[4, 5, 2, 3, 1]
        Arrays.sort(a);
        System.out.println(Arrays.toString(a));		//[1, 2, 3, 4, 5]
    }
}

```



## 线程&进程

**进程**

系统进行资源分配和调用的独立单位

每一个进程都有自己的内存空间和系统资源

**线程**

是进程中的单个顺序控制流，是一条执行路径

单线程：一个进程只有一条执行路径

多线程：一个进程有多条执行路径

### 多线程的实现

**方法一(继承Thread类)**

```
定义一个类MyThread继承Thread类

在MyThread类中重写run()方法
run()方法是用来封装被线程执行的代码

创建MyThread类的对象

启动线程
start()方法启动线程，然后由JVM调用此线程的run()方法
```



```java
class MyThread extends Thread {		//继承Thread类
    public void run() {
        for(int i = 0; i < 50; i++) {
            System.out.println(i);
        }
    }

}

public class test{

    public static void main(String[] args) {
        MyThread th1 = new MyThread();
        MyThread th2 = new MyThread();

        th1.start();
        th2.start();

        }
}
```



**方法二(实现Runnable接口)**

```
定义一个类MyRunnable实现Runnable接口
在MyRunnable类中重写run()方法
创建MyRunnable类的对象
创建Thread类的对象，把MyRunnable对象作为构造方法的参数
启动线程
```



```java
import javax.swing.text.rtf.RTFEditorKit;

class MyRunnable implements Runnable {

    public void run() {		//重写run方法
        for(int i = 0; i < 50; i++) {
            System.out.println(Thread.currentThread().getName() +":" + i);      //因为不是继承Thread类，所以没有getName()方法

        }
    }
}

public class test{

    public static void main(String[] args) {

        MyRunnable my = new MyRunnable();

        Thread t1 = new Thread(my,"a");        //把MyRunnable对象作为构造方法的参数
        Thread t2 = new Thread(my,"b");         //第二个参数，是线程的名字

        t1.start();
        t2.start();
        }
}
```



### 设置线程名称

通过带参构造方法设置线程名字

```java
class MyThread extends Thread {

    public MyThread(String name){
        super(name);	//访问父类的构造方法
    }
}
```

```java
class MyThread extends Thread {

    public MyThread(String name){
        super(name);
    }
    public void run() {
        for(int i = 0; i < 50; i++) {
            System.out.println(getName() +":" + i);
        }
    }
}

public class test{

    public static void main(String[] args) {
        MyThread th1 = new MyThread("a");	//通过访问父类的构造方法，设置线程名
        MyThread th2 = new MyThread("b");

        th1.start();
        th2.start();     
        }
}
```

将此线程的名称改为参数 name的值

```java
void setName(String name)
```

```java
class MyThread extends Thread {

    public void run() {
        for(int i = 0; i < 50; i++) {
            System.out.println(getName() +":" + i);

        }
    }

}

public class test{

    public static void main(String[] args) {
        MyThread th1 = new MyThread();
        MyThread th2 = new MyThread();

        th1.setName("a");	//setName()设置线程名
        th2.setName("b");

        th1.start();
        th2.start();
        }
}
```

### 获取线程名称

返回此线程的名称

```java
String getName()
```

```java

class MyThread extends Thread {

    public void run() {
        for(int i = 0; i < 50; i++) {
            System.out.println(getName() +":" + i);	//getName()获取线程名

        }
    }
}

public class test{

    public static void main(String[] args) {
        MyThread th1 = new MyThread();
        MyThread th2 = new MyThread();

        th1.setName("a");
        th2.setName("b");

        th1.start();
        th2.start();
        }
}
```

### 获取线程对象的引用

返回对当前正在执行的线程对象的引用

```java
public static Thread currentThread()
```

```java

class MyThread extends Thread {

    public void run() {
        for(int i = 0; i < 50; i++) {
            System.out.println(getName() +":" + i);

        }
    }
}

public class test{

    public static void main(String[] args) {
        MyThread th1 = new MyThread();
        MyThread th2 = new MyThread();

        th1.setName("a");
        th2.setName("b");

        th1.start();
        th2.start();
        System.out.println(Thread.currentThread().getName());	//Thread.currentThread()获取当前正在执行的线程对象的引用

        }
}
```



### Java的线程调度模式

Java使用的是抢占式调度模型

多线程程序的执行是有随机性的

### 设置和获取线程优先级

```java
public final int getPriority()
```

### 返回此线程的优先级

```java
public final void setPriority(int newPriority)
```

### 更改此线程的优先级

线程默认优先级是5，线程优先级的范围是1-10

```java
class MyThread extends Thread {

    public void run() {
        for(int i = 0; i < 50; i++) {
            System.out.println(getName() +":" + i);
        }
    }
}

public class test{

    public static void main(String[] args) {
        MyThread th1 = new MyThread();
        MyThread th2 = new MyThread();

        th1.setName("a");
        th2.setName("b");
        System.out.println(th1.getPriority());	//获取线程的优先级
        th1.setPriority(1);		//设置线程的优先级
        th2.setPriority(10);

        th1.start();
        th2.start();

        }
}
```



### 线程控制

| 方法名                         | 说明                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| static void sleep(long millis) | 使当前正在执行的线程停留，暂停指定毫秒数，同时让出CPU的使用权 |
| void join()                    | 等待这个线程死亡(线程阻塞)后，才能往后执行                   |
| void setDaemon(boolean on)     | 将此线程标记为守护线程，当运行的线程都是守护线程时(主线程运行结束)，Java虚拟机将退出 |



例 sleep

```java
class MyThread extends Thread {

    public void run() {
        for(int i = 0; i < 50; i++) {
            System.out.println(getName() +":" + i);
            try {
                Thread.sleep(1000);      //线程停留
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public class test{

    public static void main(String[] args) {
        MyThread th1 = new MyThread();
        MyThread th2 = new MyThread();

        th1.setName("a");
        th2.setName("b");

        th1.start();
        th2.start();


        }
}
```



例 join

```java
class MyThread extends Thread {

    public void run() {
        for(int i = 0; i < 50; i++) {
            System.out.println(getName() +":" + i);
        }
    }
}

public class test{

    public static void main(String[] args) {
        MyThread th1 = new MyThread();
        MyThread th2 = new MyThread();
        MyThread th3 = new MyThread();

        th1.setName("a");
        th2.setName("b");
        th3.setName("c");


        th1.start();
        try {
            th1.join();		//线程阻塞
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        th2.start();
        th3.start();


        }
}
```



例 setDaemon

```java
class MyThread extends Thread {

    public void run() {
        for(int i = 0; i < 50; i++) {
            System.out.println(getName() +":" + i);

        }
    }
}

public class test{

    public static void main(String[] args) {
        MyThread th1 = new MyThread();
        MyThread th2 = new MyThread();

        th1.setName("a");
        th2.setName("b");
        Thread.currentThread().setName("zhu");

        th1.setDaemon(true);	//设置守护线程
        th2.setDaemon(true);	//设置守护线程

        th1.start();
        th2.start();

        for(int j=0;j<10;j++){      //设为主线程
            System.out.println(Thread.currentThread().getName() + ":" + j);
        }

        }
}
```



### 线程的生命周期

创建、就绪、执行、阻塞、死亡

![](F:%5C%E7%AC%94%E8%AE%B0%5C%E5%8D%9A%E5%AE%A2%5C%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87%5C%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg)



### 线程同步

**数据安全问题**

```
是否多线程
是否有共享数据
是否有多条语句操作共享数据
```

解决：把多条语句操作共享数据的代码锁起来，让任意时刻只能有一个线程执行即可

**同步代码块**

锁多条语句操作共享数据的代码，可以实现同步代码块

```java
synchronized (任意对象)  //相当于给代码加了锁，任意对象可以看成一把锁
            多条语句操作共享数据的代码
        }
```

锁对象是任意对象

好处：解决了多线程的数据安全问题

弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的

**同步方法**

把synchronized关键字加到方法上

```java
修饰符 synchronized 返回值类型 方法名(方法参数){ }

//锁对象是 this
```

锁对象是 `this`

**同步静态方法**

```java
修饰符 static synchronized 返回值类型 方法名(方法参数){ }
```

锁对象是 `类名.class`

```java
//卖票案例

class SellTicket implements Runnable {
    private int tickets = 100;
    private Object obj = new Object();

    public void run() {
        while(true){
            synchronized (obj) {	//同步代码块
                if (tickets > 0) {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + " Selling ticket of" + ":" + tickets);
                    tickets--;
                }
            }
        }
    }
}


public class test{

    public static void main(String[] args) {
        SellTicket st = new SellTicket();

        Thread t1 = new Thread(st,"A");
        Thread t2 = new Thread(st,"B");
        Thread t3 = new Thread(st,"C");


        t1.start();
        t2.start();
        t3.start();

        }
}
```



### 线程安全的类

```
StringBuffer
线程安全，可变的字符序列
从JDK5开始，被StringBuilder代替，通常应该使用StringBuilder类，因为它支持所有相同的操作

Vector
该类改进了List接口，如果不需要线程安全的实现，建议使用ArrayList代替Vector

Hashtable
该类实现了一个哈希表，它将键映射到值，任何非null对象都可以用作键或值，如果不需要线程安全的实现，建议使用HashMap代替Hashtable
```

### Lock锁

提供了比synchronized方法和语句更广泛的锁定操作

Lock通常放在try-finall框架中执行

获得锁

```java
void lock()
```

释放锁

```java
void unlock()
```

Lock是接口不能直接实例化，需要采用它的实现类ReentrantLock来实例化

ReentrantLock的构造方法

```java
ReentrantLock() 		//来实例化一个Lock
```



```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class SellTicket implements Runnable {
    private int tickets = 100;
    private Lock lock = new ReentrantLock();	//实例化


    public void run() {
        while(true){
            try {
                lock.lock();	//获得锁
                if (tickets > 0) {
                    try {
                        Thread.sleep(100);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + " Selling ticket of" + ":" + tickets);
                    tickets--;
                }
            }finally {
                lock.unlock();		//释放锁
            }
        }
    }
}

public class test{

    public static void main(String[] args) {
        SellTicket st = new SellTicket();

        Thread t1 = new Thread(st,"A");
        Thread t2 = new Thread(st,"B");
        Thread t3 = new Thread(st,"C");


        t1.start();
        t2.start();
        t3.start();

        }
}
```



### 生产者消费者模型

经典的多线程协作模式，实际上包含了两类线程：生产者线程和消费者线程

为了解生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库

生产者生产数据之后放置在共享数据区中，并不需要关心消费者的行为

消费者只需要从共享数据区中获取数据，并不需要关心生产者的行为

**相关方法**

在Object类中

| 方法名           | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| void wait()      | 导致当前线程等待，直到另一个线程调用该对象的notify()方法或notifyAll()方法 |
| void notify()    | 唤醒正在等待对象监视器的单个线程                             |
| void notifyAll() | 唤醒正在等待对象监视器的所有线程                             |



```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

//创建奶箱对象，这是数据共享区域
//创建生产者对象，把奶箱对象作为构造方法参数传递
//创建消费者对象，把奶箱对象作为构造方法参数传递
//启动两个线程，分别把生产者对象、消费者对象作为构造方法参数传递


class Box{          //奶箱类
    private int milk;

    private boolean state = false;

    public synchronized void put(int milk){
        //如果有牛奶，修改奶箱状态
        if (state){
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        this.milk = milk;
        System.out.println("送奶工将第" + this.milk + "瓶奶放入奶箱");

        state = true;

        notifyAll();        //进程唤醒
    }
    public synchronized void get(){
        //如果没有牛奶，等待生产
        if(!state){
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("用户拿到第" + this.milk + "奶瓶");

        state = false;

        notifyAll();        //进程唤醒
    }
}

class Producer implements Runnable{     //生产者对象
    private Box b;
    public Producer(Box b){
        this.b = b;
    }

    public void run(){
        for(int i=1;i<=5;i++){
            b.put(i);
        }
    }

}

class Customer implements Runnable{
    private Box b;
    public Customer(Box b){
        this.b = b;
    }
    public void run(){
        while(true){
            b.get();
        }
    }
}


public class test{

    public static void main(String[] args) {
        Box b = new Box();

        Producer p = new Producer(b);

        Customer c = new Customer(b);

        Thread t1 = new Thread(p);
        Thread t2 = new Thread(c);

        t1.start();
        t2.start();

        }
}
```



## File类

### 构造方法

File是路径的抽象表示，它可以是存在的，也可以是不存在的

以下三种方法，效果一样，推荐用第一种

| 方法名                           | 说明                                                     |
| -------------------------------- | -------------------------------------------------------- |
| File(String pathname)            | 通过将给定的路径名字符串转为抽象路径名来创建新的File实例 |
| File(String parent,String child) | 从父路径名字符串和子路径名字符串创建新的File实例         |
| File(File parent,String child )  | 从父抽象路径名和子路径名字符串创建新的File实例           |

```java
import java.io.File;
public class test {

    public static void main(String[] args) {
        File f1 = new File("C:\\Users\\houyi\\Desktop\\XCTF");
    }
}
```



### 创建功能

| 方法名                         | 说明                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| public boolean createNewFile() | 当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件。若文件存在返回false |
| public boolean mkdir()         | 创建由此抽象路径名命名的目录。若目录存在返回false            |
| public boolean mkdirs()        | 创建由此抽象路径名命名的多级目录。若目录存在返回false        |

```java
import java.io.File;
import java.io.IOException;

public class test {

    public static void main(String[] args) throws IOException {
        File f1 = new File("C:\\Users\\houyi\\Desktop\\test.txt");  //创建文件

        File f2 = new File("C:\\Users\\houyi\\Desktop\\test");      //创建目录

        File f3 = new File("C:\\Users\\houyi\\Desktop\\test1\\123");    //创建多级目录

        f1.createNewFile();

        f2.mkdir();

        f3.mkdirs();

    }
}
```



### 删除功能

| 方法名                  | 说明                               |
| ----------------------- | ---------------------------------- |
| public boolean delete() | 删除由此抽象路径名表示的文件或目录 |

注意：

如果一个目录中有内容(子目录或文件)，则不能直接删除该目录，需要先删除目录中的内容，才能删除该目录

```java
import java.io.File;
import java.io.IOException;

public class test {

    public static void main(String[] args) throws IOException {
        File f1 = new File("C:\\Users\\houyi\\Desktop\\test\\test66.txt");  //创建文件

        File f2 = new File("C:\\Users\\houyi\\Desktop\\test");      //创建目录

        f2.mkdir();					

        f1.createNewFile();
        
        f1.delete();		//先删除目录下的文件
        f2.delete();		//最后才能删除目录
       
    }
}
```

### 判断和获取功能

| 方法名                          | 说明                                    |
| ------------------------------- | --------------------------------------- |
| public boolean isDirectory()    | 测试此抽象路径名表示的File是否为目录    |
| public boolean isFile()         | ...是否为文件                           |
| public boolean exists()         | ...是否存在                             |
| public String getAbsolutePath() | ...获取绝对路径                         |
| public String getPath()         | ...获取相对路径                         |
| public String getName()         | ...获取文件或目录的名称                 |
| public String[] list()          | ...获取目录中文件和目录的名称字符串数组 |
| public File[] listFiles()       | ...获取目录中文件和目录的File对象数组   |

```java
import java.io.File;
import java.io.IOException;

public class test {

    public static void main(String[] args) throws IOException {
        File f1 = new File("C:\\Users\\houyi\\Desktop\\test\\test66.txt");  //创建文件

        File f2 = new File("C:\\Users\\houyi\\Desktop\\test");      //创建目录
	
        f2.mkdir();		//创建目录

        f1.createNewFile();		// 创建文件
        
        System.out.println(f1.isDirectory());
        System.out.println(f1.exists());
        System.out.println(f1.isFile());
        System.out.println(f1.getAbsoluteFile());
        System.out.println(f1.getPath());
        System.out.println(f1.getName());

        String[] strArray = f2.list();      //返回一个字符串数组
        for(String str:strArray) {
            System.out.println(str);
        }
        
        File[] fileArray = f2.listFiles();		//返回一个File类
        for(File file : fileArray){
            System.out.println(file);
        }
    }
}
```

### 运行可执行文件

```java
Runtime类
        Runtime ec;
        ec = Runtime.getRuntime();

注意
不能实例化一个Runtime对象，应用程序也不能创建自己的 Runtime 类实例，但可以通过 getRuntime 方法获取当前Runtime运行时对象的引用。
```

| 方法                    | 说明                                   |
| ----------------------- | -------------------------------------- |
| ec.exec(String command) | 打开本地的一个可执行文件或执行一个操作 |

```java
import java.io.*;

public class test {

    public static void main(String[] args) throws IOException {
        Runtime ec;
        ec = Runtime.getRuntime();
        ec.exec("C:\\WINDOWS\\system32\\calc.exe");		//调用计算机
        
    }
}
```

### 目录遍历

```java

import java.io.*;



public class test {

    public static void getAllFilePath(File srcFile){		//函数
        File[] fileArray = srcFile.listFiles();

        if(fileArray != null){
            for(File file : fileArray){
                if(file.isDirectory()){
                    getAllFilePath(file);
                }
                else {
                    System.out.println(file.getAbsolutePath());
                }
            }
        }
    }


    public static void main(String[] args) throws IOException {
        File srcFile = new File("C:\\Users\\houyi\\Desktop\\XCTF");		//传入目录
        getAllFilePath(srcFile);

    }
}
```

## IO流

流的本质是数据传输。

常见的流：文件复制、文件上传、文件下载

### 分类

默认按数据类型来分类

**按数据流向**

输入流

输出流

**按数据类型**

字节流

字符流

### 使用

要读写的内容，可直接使用记事本打开，则使用字符流

否则使用字节流

## 字节流

### 字节流抽象基类

InputStream

这个抽象类是表示字节输入流的所有类的超类

OutputStream

这个抽象类是表示字节输出流的所有类的超类

子类名特点

子类名都是以其父类名作为子类名的后缀

### 写数据

创建字节输出流对象

```java
FileOutputStream fos = new FileOutputStream(String pathname)
    
/*说明

调用系统功能创建了文件
创建了字节输出流对象
让字节输出流对像指向创建好的文件
*/
```

写入数据

| 方法                                 | 说明                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| void write(int b)                    | 将指定的字节写入此文件输出流，一次写入一个字节               |
| void write(byte[] b)                 | 将多个字节从指定的字节数组写入此文件输出流，一次写入一个字节数组 |
| void write(byte[] b,int off,int len) | 将len字节从指定的字节数组开始，从偏移量off开始写入，一次写入一个字节数组的部分数据 |

```java
fos.write()			// 用write方法写入数据
```

关闭资源

```java
fos.close()			//关闭文件资源
```

获取字符串的字节数组

```java
String str = "abcdfsdf";
str.getBytes();
```

实现换行

```java
fos.write("\r\n".getBytes())	//Windows下
```

追加写入

```java
FileOutputStream fos = new FileOutputStream(String pathname,true)		//增加一个Boolean类型的参数
```



例子

```java

import java.io.*;
import java.nio.charset.StandardCharsets;


public class test {


    public static void main(String[] args) throws IOException {

        String str = "dtfwsdfasdfas";

        byte[] bys = {98,55,66,88,89};

        FileOutputStream fos = new FileOutputStream("C:\\Users\\houyi\\Desktop\\test\\1.txt",true);

        fos.write(bys);
        fos.write("\r\n".getBytes());
        fos.write(98);
        fos.close();
    }

}
```

### finally释放资源

被finally控制的语句一定会执行

```java
        try {
            fos.write(98);
        }catch (IOException e){
            e.printStackTrace();
        }finally {
            fos.close();
        }
```

### 读数据

创建字节输入流对象

```java
FileInputStream fos1 = new FileInputStream(String pathname);
```

读取数据

| 方法                | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| void read(byte b)   | 读取指定的字节，一次读取一个字节，如果文件读取到末尾，返回 -1，否则返回读取的字节的个数 |
| void read(byte[] b) | 读取指定的字节，放到一个字节数组中，如果文件读取到末尾，返回 -1，否则返回读取的字节的个数 |

```java

import java.io.*;
import java.nio.charset.StandardCharsets;


public class test {


    public static void main(String[] args) throws IOException {
        FileInputStream fos1 = new FileInputStream("C:\\Users\\houyi\\Desktop\\test\\1.txt");

        byte[] bys = new byte[1024];            //一般是1024及其整数倍
        int len;
        while ((len = fos1.read(bys)) != -1){
            System.out.print((new String(bys,0,len)));
        }

        fos1.close();
    }

}
```

关闭资源

```java
fos.close()
```



## 字符流

字符流 = 字节流 + 编码表

### 汉字的处理

因为汉字的存储是有编码的，GBK或UTF-8等，而GBK编码占2个字节，UTF-8编码占3个字节，所以直接使用字节流读取，会导致无法读取到完整的汉字。

在用字节流复制文本文件时，文本文件中有中文，那么是如何识别中文的？

```
汉字在存储时，无论何种编码方式，第一个字节都是负数，所以可以识别汉字
```

### 编码和解码

**编码**

```
byte[] getBytes() 使用平台默认的字符集将该String编码为一系列字节，结果存储到新的字节数组中

byte[] getByte(String charsetName) 使用指定的字符集将该String编码为一系列字节，结果存储到新的字节数组中

```

例

```java
public class test {


    public static void main(String[] args) throws IOException {

        String s = "中国";

        byte[] bys1 = s.getBytes("GBK");
        byte[] bys2 = s.getBytes("UTF-8");

        System.out.println(Arrays.toString(bys1));
        System.out.println(Arrays.toString(bys2));
    }

}
```

**解码**

```
String(byte[] bytes) 使用平台默认的字符集将字节数组解码为String
String(byte[] bytes,String charsetName) 使用指定的字符集将字节数组解码为String
```

例

```java
public class test {


    public static void main(String[] args) throws IOException {

        String s = "中国";

        byte[] bys1 = s.getBytes("GBK");
        byte[] bys2 = s.getBytes("UTF-8");

        System.out.println(Arrays.toString(bys1));
        System.out.println(Arrays.toString(bys2));

        String ss1 = new String(bys1,"GBK");
        System.out.println(ss1);

        String ss2 = new String(bys2,"UTF-8");
        System.out.println(ss2);

    }

}
```

### 字符流抽象基类

Reader

字符输入流的抽象类

Writer

字符输出流的抽象类

FileWriter是Writer的子类

FileReader是Reader的子类

InputStreamReader

读取字节，使用指定的编码将其解码为字符

```java
public class test {

    public static void main(String[] args) throws IOException {

        InputStreamReader isr = new InputStreamReader(new FileInputStream("C:\\Users\\houyi\\Desktop\\test\\2.txt"),"UTF-8");

        int ch;
        while((ch = isr.read()) != -1){
            System.out.print((char)ch);;
        }

        isr.close();
    }
}
```



OutputStreamWriter

使用指定的编码将写入的字符编码为字节

```java
public class test {


    public static void main(String[] args) throws IOException {

        String s = "中国";
        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("C:\\Users\\houyi\\Desktop\\test\\2.txt"),"UTF-8");

        osw.write("中国");

        osw.close();
        
    }

}
```

### 写数据

| 方法名                                  | 说明                                           |
| --------------------------------------- | ---------------------------------------------- |
| void write(int c)                       | 写一个字符                                     |
| void write(char[] cbuf)                 | 写入一个字符数组                               |
| void write(char[] cbuf,int off,int len) | 写入字符数组的一部分                           |
| void write(String str)                  | 写一个字符串                                   |
| void write(String str,int off,int len)  | 写一个字符串的一部分                           |
| void flush()                            | 刷新流的缓冲，写入一个字符，必须刷新，才能写入 |
| void close()                            | 关闭资源并刷新流                               |

例

```java
public class test {

    public static void main(String[] args) throws IOException {

        String s = "中国";
        char[] ch = {'a','d','c'};
        
        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("C:\\Users\\houyi\\Desktop\\test\\2.txt"));

        osw.write(98);
        osw.write(s);
        osw.write(ch);
        osw.flush();
        osw.close();
    }
}
```

### 读数据

| 方法名                | 说明                   |
| --------------------- | ---------------------- |
| int read()            | 一次读一个字符数据     |
| int read(char[] cbuf) | 一次读一个字符数组数据 |

例

```java
public class test {

    public static void main(String[] args) throws IOException {


        InputStreamReader isr = new InputStreamReader(new FileInputStream("C:\\Users\\houyi\\Desktop\\test\\2.txt"));
        int ch;

        char[] chs = new char[1024];
        int len;
        
       while((ch = isr.read()) != -1){		//
           System.out.print((char)ch);
        }

        while((len = isr.read(chs)) != -1){		//
            System.out.print(new String(chs,0,len));
        }
        isr.close();
    }
}
```



## 缓冲流

### 字节缓冲流

字节缓冲流仅仅提供缓冲区，真正的读写数据还得依靠基本的字节流对象操作

BufferedInputStream(OutputStream out)

创建一个内部缓冲区数组，当从流中读取或跳过字节时，内部缓冲区将根据需要从所包含的输入流中重新填充，一次很多字节

BufferedOutputStream(InputStream in)

程序可向底层输出流写入字节，不必为写入的每个字节导致底层系统的调用

例

```java
public class test {

    public static void main(String[] args) throws IOException {

        BufferedInputStream bos = new BufferedInputStream(new FileInputStream("C:\\Users\\houyi\\Desktop\\test\\2.txt"));

        int b;
        while ((b=bos.read()) != -1){
            System.out.print((char)b);
        }
    }
}
```



### 字符缓冲流

BufferedReader(Writer out)

从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可指定缓冲区大小，或使用默认大小，默认值足够大

BufferedWriter(Reader in)

将文本写入字符输出流，缓冲字符，以提供单个字符，数组和行的高效读取，可指定缓冲区大小，或使用默认大小，默认值足够大

例

```java
public class test {


    public static void main(String[] args) throws IOException {

        BufferedReader ss = new BufferedReader(new FileReader("C:\\Users\\houyi\\Desktop\\test\\2.txt"));

       int len;
       while((len = ss.read()) != -1){
           System.out.print((char)len);
       }
    }
}
```

字符缓冲流的特有功能

添加换行

```
BufferedWriter: void newLine() 
写一个行分隔符，行分隔符字符串由系统属性定义，如Windows中是\r\n，Linux是 \n
如
```

如

```java
class work {
    public static void main(String[] args) throws IOException {

        BufferedWriter   bw = new BufferedWriter(new FileWriter("C:\\Users\\houyi\\Desktop\\test\\1.txt"));

        for(int i = 0;i<10;i++){
            bw.write("hello" + i);
            bw.newLine();
        }
        bw.close();
    }
}
```



读取行字符

```
BufferedReader: public String readLine() 
读一行文字，结果包含行的内容的字符串，不包括任何终止字符(即不包含换行符)，如果流的结尾已经到达，则为null
```

如

```java
class work {
    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new FileReader("C:\\Users\\houyi\\Desktop\\test\\1.txt"));

        String line;
        while ((line = br.readLine()) != null) {
            System.out.println(line + "\n");
        }

        br.close();
    }
}
```



## IO流总结

字节流可以复制任意文件数据，有4种方式，一般采用字节缓冲流一次读写一个字节数组的方式

字符流只能复制文本数据，共5种方式，一般采用字符缓冲流的特有功能



## 特殊操作流

### 标准输入、输出流

是System类中的静态成员变量

对应于键盘输入或其他指定的输入源

```java
public static final InputStream in
    
    
如
class work {
    public static void main(String[] args) throws IOException {
        InputStream is = System.in;

        int by;
        while ((by=is.read())!=-1){
            System.out.print((char)by);
        }
    }
}
```

对应于显示输出或其他指定的输出源

```java
public static final PrintStream out
    
如
class work {
    public static void main(String[] args) throws IOException {
        PrintStream pr = System.out;
        pr.println();
        pr.print("abc");

    }

}

```



### 打印流

只负责输出数据，不读取数据

**字节打印流**

构造方法

```java
PrintStream ps = new PrintStream("路径");
```

使用继承父类的方法`write()`写数据，会转码。使用自己特有的方法`print() println()`写数据，不转码

```java
class work {
    public static void main(String[] args) throws IOException {
        PrintStream pr = new PrintStream("C:\\Users\\houyi\\Desktop\\test\\1.txt");
        pr.println(97);     //不转码
        pr.write(97);       //转码 为 a
        

    }
}
```



**字符打印流**

构造方法

| 方法名                                    | 说明                                                         |
| ----------------------------------------- | ------------------------------------------------------------ |
| PrintWriter(String filename)              | 使用指定的文件名创建一个新的PrintWriter，而不需要自动执行刷新 |
| PrintWriter(Writer out,boolean autoFlush) | 创建一个新的PrintWriter。out：字符输出流。autoFlush：一个布尔值，如果为真，则print、println或format方法将刷新输出缓冲区 |

第一个构造方法

```java
class work {
    public static void main(String[] args) throws IOException {
        PrintWriter pw = new PrintWriter("C:\\Users\\houyi\\Desktop\\test\\1.txt");

        pw.write("asd");
        pw.println("123")
        pw.flush();

    }
}
```

第二个构造方法

```java
class work {
    public static void main(String[] args) throws IOException {
        PrintWriter pw = new PrintWriter(new FileWriter("C:\\Users\\houyi\\Desktop\\test\\1.txt"),true);

        pw.write("asd");
        pw.println("123");

    }
}
```



### 对象序列化流

对象序列化：就是将对象保存到磁盘中,或者在网络中传输对象

这种机制就是使用一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据和对象中存储的属性等信息

字节序列写到文件之后，相当于文件中持久保存了一个对象的信息

反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化

**对象序列化流**： ObjectOutputStream

构造方法

```java
ObjectOutputStream(OutputStream out): 创建一 个写入指定的OutputStream的ObjectOutputStream
```

序列化对象的方法

```java
void writeObject(Object obj):将指定的对象写入ObjectOutputStream
```

注意

```
一个对象要想被序列化，该对象所属的类必须实现Serializable 接口

Serializable是一个标记接口，实现该接口，不需要重写任何方法

```

**对象反序列化流**：ObjectInputStream

## 其他

运行`.class`文件时，只需要写主类名，不需要写`.class`后缀

CMD运行java遇到编码问题

```
javac  -encoding  UTF-8  文件名.java
```

CMD运行java遇到`错误: 找不到或无法加载主类`的问题

```
往往是因为，java 源文件中带有包名
解决方法是在 cmd下运行时，构建和包对应的目录结构
如 
程序中 work.java 中有 package Test;
文件的目录结构为 F:\JavaWork\src\Test\work.java
那么在运行时，需要在 src 目录下 使用命令  java Test.work 找到程序的主类来运行
```




