---
layout: post   	
catalog: true 	
tags:
    - MySQL
---

# 1. 基本概念
## 1.1. 关系型数据库
## 1.2. SQL
## 1.3. MySQL

# 2. MySQL 基础架构

![MySQL基础架构](F:\笔记\博客\文章图片\MySQL基础架构.png)

简单来说 MySQL 主要分为 Server 层和存储引擎层：

-   **Server 层**：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，同时还有一个日志模块binlog，这个日志模块所有执行引擎都可以共用，redolog 只有 InnoDB 有
-   **存储引擎**： 主要负责数据的存储和读取，采用插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎。**现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5 版本开始就被当做默认存储引擎了**，可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。**存储引擎是基于表的，而不是数据库。**

## 2.1. Server 层基本组件

### 2.1.1. 连接器

连接器主要负责身份认证和权限相关的功能

当用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的。

### 2.1.2. 查询缓存（MySQL 8.0 版本后移除）

查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集，不推荐使用

连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。

MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。

### 2.1.3. 分析器

MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：

**第一步，词法分析**，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。

**第二步，语法分析**，主要就是判断你输入的 SQL 是否正确，是否符合 MySQL 的语法。

完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。

### 2.1.4. 优化器

优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。经过了优化器之后，这个语句具体该如何执行就已经定下来。

### 2.1.5. 执行器

当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果

## 2.2. 语句执行分析

-   **查询语句**的执行流程如下：权限校验（如果命中缓存）--->查询缓存--->分析器--->优化器--->权限校验--->执行器--->引擎
-   **更新语句**的执行流程如下：分析器---->权限校验---->执行器--->引擎---redo log（prepare 状态）--->binlog--->redo log（commit状态）

# 3. MySQL存储引擎

`show engines` 命令查看 MySQL 支持的所有存储引擎

MySQL 5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎

所有的存储引擎中只有 InnoDB 支持事务

## 3.1. MySQL 存储引擎架构

 **插件式架构**。可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。**存储引擎是基于表的，而不是数据库**

## 3.2. MyISAM 和 InnoDB 区别

**是否支持行级锁**

MyISAM 只有表级锁（table-level locking），而 InnoDB 支持行级锁（row-level locking）和表级锁，默认为行级锁。

也就说，MyISAM 一锁就是锁住了整张表，这在并发写的情况下性能比 InnoDB 差

**是否支持事务**

MyISAM 不提供事务支持。

InnoDB 提供事务支持，SQL 标准定义了四个隔离级别，具有提交（commit）和回滚（rollback）事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）

**是否支持外键**

MyISAM 不支持，而 InnoDB 支持。阿里的《Java 开发手册》明确规定禁止使用外键

外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可

**是否支持数据库异常崩溃后的安全恢复**

MyISAM 不支持，而 InnoDB 支持。

使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 `redo log` 。

**是否支持 MVCC**

MyISAM 不支持，而 InnoDB 支持。

MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。

**索引实现不一样**

虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。

InnoDB 引擎中，其数据文件本身就是索引文件。而 MyISAM，索引文件和数据文件是分离的。InnoDB 引擎中，表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。

**性能有差别**

InnoDB 的性能比 MyISAM 更强大，不管是在读写混合模式下还是只读模式下，随着 CPU 核数的增加，InnoDB 的读写能力呈线性增长。MyISAM 因为读写不能并发，它的处理能力跟核数没关系

**总结**

MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。请无脑使用 InnoDB

# 4. MySQL 锁

## 4.1. 行锁&表锁

MySQL中有两种锁：行锁和表锁。行锁是针对表中的某一行数据进行的锁定，而表锁是针对整个表进行的锁定。行锁和表锁都可以用于控制并发访问，以避免数据冲突和死锁

行锁可以使用以下语句进行设置：

```sql
SELECT ... FOR UPDATE;
```

在上面的语句中，SELECT语句用于查询数据，FOR UPDATE语句用于设置行锁。当一个事务获取了某一行的行锁后，其他事务就无法修改该行数据，直到该事务释放行锁为止。

表锁可以使用以下语句进行设置：

```sql
LOCK TABLES ...;
```

在上面的语句中，LOCK TABLES语句用于锁定表格。当一个事务获取了某个表的表锁后，其他事务就无法修改该表数据，直到该事务释放表锁为止

## 4.2. MVCC

# 5. MySQL 事务

MySQL InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）**。可以通过`SELECT @@tx_isolation;`命令来查看

SQL 标准定义了四个隔离级别：

-   **READ-UNCOMMITTED(读取未提交)** ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
-   **READ-COMMITTED(读取已提交)** ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
-   **REPEATABLE-READ(可重复读)** ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
-   **SERIALIZABLE(可串行化)** ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读




# 6. MySQL 索引（重点）

## 6.1. 索引介绍

**索引是一种用于快速查询和检索数据的数据结构**。索引，我们也称之为 index 或者 key

MySQL 的索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎的索引工作方式都不一样，甚至相同类型的索引，在不同的存储引擎中实现方案都不同

-   减少了服务器需要扫描的数据量。
-   索引可以帮助服务器避免排序和创建临时表。
-   索引将随机 IO 变为了顺序 IO

## 6.2. 索引的底层数据结构

常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 B+树作为索引结构

### 6.2.1. B树&B+树的异同

B 树的所有节点既存放键(key) 也存放 数据(data)

![b-tree](F:\笔记\博客\文章图片\b-tree.png)


B+树只有叶子节点存放 key 和 data，其他内节点只存放 key

B+Tree 非叶子节点只保存关键字的索引和指向下一个节点的指针

B+Tree 叶子节点的关键字从小到大按顺序排列

![b+tree](F:\笔记\博客\文章图片\b+tree.png)

### 6.2.2. 树高问题

在 InnoDB 存储引擎中，B+Tree 的高度一般为 2-4 层，这就可以满足 千万级的数据的存储，查找数据的时候，一次页的查找代表一次 IO，那我们通过主键索引查询的时候，其实最多只需要 2-4 次 IO 操作就可以了。



## 6.3. MyISAM&InnoDB 索引的区别

InnoDB 引擎中，其数据文件本身就是索引文件。而 MyISAM，索引文件和数据文件是分离的

MyISAM 引擎中，B+Tree 叶节点的 **data 域存放的是数据记录的地址**。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为**非聚簇索引（非聚集索引）**

InnoDB 引擎中，其数据文件本身就是索引文件。其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 **data 域保存了完整的数据记录**。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为**聚簇索引（聚集索引）**。其余的索引都作为 **辅助索引** ，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方

InnoDB 引擎中，在根据主索引搜索时，直接找到 key 所在的节点即可取出数据。如果不是主键索引，叶子节点存储的是主键+列值。最终还是要**回表**，也就是要通过主键再查找一次，即需要先取出主键的值，再走一遍主索引

因此，在设计表的时候，**不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂**

## 6.4. 索引的类型

**按照底层存储方式角度划分：**

-   聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。
-   非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引（辅助索引）就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引

**按照应用维度划分：**

-   主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个
-   普通索引：仅加速查询
-   唯一索引：加速查询 + 列值唯一（可以有 NULL）
-   覆盖索引：一个索引包含所有需要查询的字段的值
-   联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
-   全文索引：对文本的内容进行分词，进行搜索。目前只有 `CHAR`、`VARCHAR` ，`TEXT` 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替

## 6.5. 索引的使用场景

-   全值匹配。如果我们要搜索 username 为 ac 且 age 为 98 的用户，就可以直接使用索引精确定位到

-   最左匹配。

-   前缀匹配。如果我们搜索的关键字只是 username 字段的前半部分，那么很明显，也是可以使用索引的，例如搜索所有以 a 开始的 username。

-   范围匹配。如果我们的搜索条件是一个范围，很明显也可以使用到上述索引，例如搜索姓名介于 ab～cc 之间的用户，只需要先从索引树的根节点开始，先找到 ab，然后根据叶子节点之间的指针顺藤摸瓜，找到 cc 之后的第一个数据（不满足条件的第一个数据）结束。

-   前面全值匹配，后面范围匹配。

-   覆盖索引。有的时候，我们搜索的数据都在索引树中了，例如上图中的索引，我们想搜索 username 为 bw 的用户的 age，由于 age 就在索引树中，直接返回即可，这就是覆盖索引了。

## 6.6. 主键索引（重点）

数据表的主键列使用的就是主键索引

一张数据表有只能有一个主键，并且主键不能为 null，不能重复（即只能有一个字段被设为主键）

在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键

## 6.7. 二级索引

二级索引（Secondary Index）又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，**通过二级索引，可以定位主键的位置**

唯一索引，普通索引，前缀索引等索引属于二级索引

## 6.8. 自适应哈希索引

InnoDB 索引有一个特性叫做自适应哈希索引，整个过程是全自动的，不需要开发者配置。

当 InnoDB 监控到某些索引值被频繁的访问时，那么它就会在 B+Tree 索引之上，构建一个 Hash 索引，进而通过 Hash 查找来快速访问数据。

默认情况下，自适应哈希索引是开启的状态

## 6.9. 聚簇索引&非聚簇索引

### 6.9.1. 聚簇索引的优缺点

**优点** ：

-   **查询速度非常快** ：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。**相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作**。

**缺点** ：

-   **依赖于有序的数据** ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。
-   **更新代价大** ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的

### 6.9.2. 非聚簇索引的优缺点

**优点** ：

更新代价比聚簇索引要小 。非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点是不存放数据的

**缺点** ：

-   **依赖于有序的数据** ：跟聚簇索引一样，非聚簇索引也依赖于有序的数据
-   **可能会二次查询（回表）**：非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据

## 6.10. 覆盖索引&联合索引

### 6.10.1. 覆盖索引

覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询

如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表

### 6.10.2. 联合索引

使用表中的多个字段创建索引，就是 **联合索引**，也叫 **组合索引** 或 **复合索引**，它可以加速基于多个字段的联合查询操作

例如，在一个订单表中，如果需要根据“订单日期”和“订单状态”两个字段进行查询，那么可以在这两个字段上创建一个复合索引

需要注意的是，复合索引的字段顺序非常重要。例如，如果在上面的订单表中，复合索引的字段顺序是“订单状态”，“订单日期”，那么当查询操作执行时，数据库引擎就无法使用这个复合索引来加速查询，因为索引的第一个字段不是查询条件中的字段。因此，**在创建复合索引时，需要根据实际的查询需求和字段组合来选择合适的字段顺序**

**最左前缀匹配原则**

最左前缀匹配原则指的是，在使用联合索引时，MySQL 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 **`>`**、**`<`**）才会停止匹配。对于 **`>=`**、**`<=`**、**`BETWEEN`**、**`like`** 前缀匹配的范围查询，并不会停止匹配。所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据

## 6.11. 索引下推

**索引下推（Index Condition Pushdown）** 是 **MySQL 5.6** 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数

## 6.12. 正确使用索引的一些建议

### 6.12.1. 选择合适的字段创建索引

-   **不为 NULL 的字段** ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0、1、true、false 这样语义较为清晰的短值或短字符作为替代
-   **被频繁查询的字段** ：创建索引的字段应该是查询操作非常频繁的字段
-   **被作为条件查询的字段** ：被作为 WHERE 条件查询的字段，应该被考虑建立索引
-   **频繁需要排序的字段** ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间
-   **被经常频繁用于连接的字段** ：该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率
- **被频繁更新的字段**不建议使用索引

### 6.12.2. 限制每张表上的索引数量

索引并不是越多越好，建议单张表索引不超过 5 个

索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率

因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能

### 6.12.3. 尽可能的建立联合索引而不是单列索引

因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升

### 6.12.4. 注意避免冗余索引

如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的。在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引

### 6.12.5. 删除长期未使用的索引

删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗

MySQL 5.7 可以通过查询 `sys` 库的 `schema_unused_indexes` 视图来查询哪些索引从未被使用

### 6.12.6. 分析语句的执行计划

使用 `EXPLAIN` 命令来分析 SQL 的 **执行计划** ，这样就知道语句是否命中索引了。执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式

`EXPLAIN` 并不会真的去执行相关的语句，而是通过 **查询优化器** 对语句进行分析，找出最优的查询方案，并显示对应的信息

## 6.13. 索引失效

索引失效也是慢查询的主要原因之一，常见的导致索引失效的情况有下面这些：

-   使用 `SELECT *` 进行查询
-   创建了复合索引，但查询条件未遵守最左匹配原则
-   在索引列上进行计算、函数、类型转换等操作
-   以 `%` 开头的 LIKE 查询比如 `like '%abc'`
-   查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到
- 数据库表中的数据量过大，导致索引失效。当一张表中的数据量很大时，查询操作可能需要扫描大量的数据，这时索引就可能无法发挥作用。解决方法可以是增加索引、优化查询语句，或者对数据进行分区处理
- 使用了大量的JOIN操作，导致索引失效。当进行多表JOIN操作时，如果每个表都有自己的索引，那么数据库可能会选择错误的执行计划，导致索引失效。解决方法可以是增加联合索引、优化查询语句，或者对数据进行分区处理
-   发生隐式转换




# 7. MySQL 日志

-   MySQL 中常见的日志有哪些？
-   慢查询日志有什么用？
-   binlog 主要记录了什么？
-   redo log 如何保证事务的持久性？
-   页修改之后为什么不直接刷盘呢？
-   binlog 和 redolog 有什么区别？
-   undo log 如何保证事务的原子性？

---


MySQL 自带的日志模块是 **binlog（归档日志）** ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 **redo log（重做日志）**

**这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗?**

这是因为最开始 MySQL 并没有 InnoDB 引擎（InnoDB 引擎是其他公司以插件形式插入 MySQL 的），MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。

并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？

-   **先写 redo log 直接提交，然后写 binlog**，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 binlog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。
-   **先写 binlog，然后写 redo log**，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。

如果采用 redo log 两阶段提交的方式就不一样了，写完 binlog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binlog 也已经写完了，这个时候发生了异常重启会怎么样呢？ 这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：

-   判断 redo log 是否完整，如果判断是完整的，就立即提交。
-   如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。

这样就解决了数据一致性的问题


**参考文章**
http://blog.codinglabs.org/articles/theory-of-mysql-index.html

https://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&mid=2247503786&idx=1&sn=baccbb718b13b6ebaa3462a82c0d2a04&chksm=e9c09dcadeb714dc82268aa266aea9072c2bab6be2a2966f6ae430d0c59ec09f0a1ad5fcb47d&mpshare=1&scene=23&srcid=0412J74mODavwFMb5bknxV4T