---
layout:  post
catalog: true 
tags:
	- MySQL
---



## MySQL基础

### SQL语言

```
用来管理数据库中的数据

可以嵌套到其他语言中
```

**数据操作语言**

DML

```
UPDATE - 更新数据库表中的数据
DELETE - 从数据库表中删除数据
INSERT INTO - 向数据库表中插入数据
```

**数据定义语言**

DDL使我们有能力创建或删除表格。我们也可以定义索引（键），规定表之间的链接，以及施加表间的约束。

```
CREATE DATABASE - 创建新数据库

ALTER DATABASE - 修改数据库

CREATE TABLE - 创建新表

ALTER TABLE - 变更（改变）数据库表

DROP TABLE - 删除表

CREATE INDEX - 创建索引（搜索键）

DROP INDEX - 删除索引
```

**数据控制语言**

```
grant语句给用户增加权限

revoke语句收回用户权限

commit语句提交事务

rollback语句回滚事务
```

**数据查询语言**

DQL

```
SELECT - 从数据库表中获取数据
```

### 本地连接MySQL

启动mysql服务

```
net start mysql
```

停止mysql服务

```
net stop mysql
```

cmd下登录mysql

```
mysql -h 服务器地址  -u  用户名  -p
```

## 数据库操作

**注意**

```
关键字不区分大小写

注释符 #内容、/*内容*/、--空格内容

若库名、表名、字段名是一个特殊字符，则要用反引号包裹

每个SQL语句要以分号;结尾

字符串用单引号括起来

一个表设置一个主键

所有的创建和删除操作尽量加上判断，以免报错，如 if exists的判断
```

### 操作数据库

选择一个数据库

```
use 数据库名;
```

创建一个数据库

```sql
create database if not exists `数据库名`;
```

删除一个数据库

```sql
drop database if exists `数据库名`;
```

查询所有数据库名

```sql
show databases;
```

### 数据库的列类型

**数值**

```
int 标准整数 4字节
bigint 较大的数据
float 浮点数 4字节
double 浮点数
decimal 字符串形式的浮点数（金融计算一般用这个）
```

**字符串**

```
char 固定大小的字符串0-255
varchar 可变字符串0-65535
tinytext 微型文本 
text 文本串
```

**时间日期**

java.util.Date

```
date YYYY-MM-DD
time HH:mm:ss
datetime YYYY-MM-DD HH:mm:ss （最常用的时间格式）
timestamp 时间戳 1970.1.1到现在的毫秒数（也常用）
year 年份
```

**null**

```
没有值、未知
不要用null进行运算，结果为null
```

### 数据库的字段属性

Unsigned

```
无符号整数
```

zerofill

```
不足的位则用0填充
```

自增

```
自动在上一条记录的基础上＋1
通常用来设计唯一的主键，必须是整数类型
可自定义设计主键自增的起始值和步长
```

非空（NULL和NOT NULL）

```
设为not null，若不填值，则报错
设为null，若不填值，则默认为null
```

默认

```
设置默认值
```

### 数据库的字段

每个表都必须存在如下字段

id

```
主键
```

version

```
乐观锁
```

is_delete

```
伪删除
```

gmt_create

```
创建时间
```

gmt_updat

```
修改时间
```

### 操作数据表

直接使用`数据库.表名`来指定某数据库中的某个表

```sql
如 select * from mysql.user;
```

查所有数据表

```
show tables;
```

查表中字段

```sql
show columns from 表名
或
show create table 表名;
或
describe 表名;
```

创建数据表

```sql
-- 每张表中都要有一个主键，通常为id
CREATE TABLE [IF NOT EXISTS] `表名` (
`字段名` 列类型 [属性] [索引] [注释]，
`字段名` 列类型 [属性] [索引] [注释]，
`字段名` 列类型 [属性] [索引] [注释],
primary key(`id`)
) [表类型] [字符集设置] [注释];

如：
CREATE TABLE IF NOT EXISTS `student` (
`id` INT(4) NOT NULL AUTO_INCREMENT COMMENT '学号',
`name` VARCHAR(30) NOT NULL DEFAULT '匿名' COMMENT '姓名',
`pwd` VARCHAR (20) NOT NULL DEFAULT '123456' COMMENT '密码',
`sex` VARCHAR(2) NOT NULL DEFAULT '女' COMMENT '性别',
PRIMARY KEY(`id`)
) ENGINE=INNODB DEFAULT CHARSET=utf8;
```

修改表名

```
alter table 旧表名 rename as 新表名;
```

修改表的字段名

```
alter table 表名 change  旧字段名 新字段名 列属性;
```

修改表的字段的数据类型

```
alter table 表名 modify 字段名 数据类型;
```

添加表的字段

```
alter table 表名 add 新字段名 列属性;
```

删除表的字段

```
alter table 表名 drop 字段名;
```

删除数据表

```
drop table if exists 表名;
```

### 数据表的类型

|              | MyISAM | InnoDB      |
| ------------ | ------ | ----------- |
| 事务支持     | 不支持 | 支持        |
| 数据行锁定   | 不支持 | 支持        |
| 外键约束     | 不支持 | 支持        |
| 全文索引     | 支持   | 不支持      |
| 表空间的大小 | 较小   | 较大，约2倍 |

**数据表在物理空间的位置**

所有的数据库文件都存在data目录下，一个文件夹就对应一个数据库

MySQL引擎在物理文件上的区别

```
InnoDB在数据库表中只有一个 *.frm文件，以及上级目录下的ibdata1文件

MYISAM对应文件 *.frm表结构的定义文件 、*.MYD数据文件(data)
*.MYI索引文件(index)

```

**设置数据库表的字符集编码**

不设置的话，会是mysql默认的字符集编码 （不支持中文！）

```
在建表时设置（建议）
CHARSET=utf8
或
在my.ini中配置默认的编码
character-set-server=utf8
```

## MySQL数据管理

### 外键

学生表的gradeid 字段要去引用年级表的 gradeid

方法一

建表时添加约束

```
定义外键key
给这个外键添加约束(执行引用)
references 引用
```

方法二

先建表，之后再添加约束

```sql
ALTER TABLE 表 ADD CONSTRAINT 约束名 FOREIGN KEY(作为外键的列) REFERENCES 那个表(那个字段)
```

以上的操作都是物理外键，数据库级别的外键，不建议使用! (数据库插入和删除都会麻烦、异常)

推荐方式：想使用外键通过程序去实现

### DML

**insert**

添加数据

```
insert into 表名(字段名1,字段名2..) values(值1,值2,..);

-- 可以同时插入多条数据，VALUES后面的值使用逗号隔开即可values(),().....
```

**update**

修改数据

```
update 表名
SET 字段名1=值1,字段名2=值2, ..
where id=1 

-- 利用where控制要更新的范围
-- value,是一个具体的值，也可以是一个变量
-- 条件，筛选的条件如果没有指定，则会修改所有的列
```

**delete**

删除数据

```
delete from 表名 where id=1;
-- 条件，筛选的条件如果没有指定，则会删除所有的列
```

**truncate**

清空表

```
truncate table 表名;
```

delete和truncate区别

```
相同点:都能删除数据，都不会删除表结构
不同:
TRUNCATE 重新设置自增列计数器会归零
TRUNCATE 不会影响事务
```

delete删除的问题，重启数据库，现象：

```
InnoDB 自增列会重1开始 (存在内存当中的，断电即失)
MyISAM继续从上一个自增量开始(存在文件中的，不会丢失)
```

## DQL查询数据

**通配符**

```
*  匹配任意一个或多个字符
_  匹配任意一个字符
%  匹配任意一个字符串
```

注：若匹配的字符串中有 `%`和`_ `则需要转义  `+&`或`+_`

**逻辑运算符**

| 运算符     | 语法            | 描述                             |
| ---------- | --------------- | -------------------------------- |
| and  、&&  | a and b 、a&&b  | 逻辑与，两个都为真，结果为真     |
| or 、 \|\| | a or b 、a\|\|b | 逻辑或，其中一个为真，则结果为真 |
| not 、!    | not a、 !a      | 逻辑非，真为假，假为真           |

### 单表查询

查询所有字段

```
select * from 表名
```

查询指定字段

```
select 字段名1,字段名2 from 表名
```

where 等值查询

```
select 字段名1,字段名2 from 表名 where id=1;
```

distinct 去重查询

```
select distinct 字段名 from 表名;
```

别名

```
AS 给结果起一个名字、可以给字段起别名、也可以给表起别名
例
select 字段名1 as newname from 表名;
```

select `表达式` from 表;  其中表达式的内容可以是

```
文本值，列，Null,函数，计算表达式，系统变量...
例
查询当前数据库版本
select version();

查看数据库文件存放的目录
select @@datadir;

查询MySQL服务的安装路径
select @@basedir;

全部学生成绩+1
select studentResult + 1 AS '成绩+1' from result;
```

### 模糊查询

| 运算符      | 语法              | 描述                               |
| ----------- | ----------------- | ---------------------------------- |
| is null     | a is null         | 如果操作符为null，结果为真         |
| is not null | a is not null     | 如果操作符不为null，结果为真       |
| between     | a between b and c | 若a在b和c之间，则结果为真          |
| like        | a like b          | SQL匹配，如果a匹配b，则结果为真    |
| in          | a in (b,c,d)      | 假设a在其中的某一个值中， 结果为真 |

```
例 select studentResult from result where name in (a,b,c);
```

### 联表查询

join on 连接查询

两张表中的字段名冲突时，用`表名.字段名`的方法解决

| 操作       | 描述                                       |
| ---------- | ------------------------------------------ |
| inner join | 如果表中至少有一个匹配，就返回行           |
| left join  | 会从左表中返回所有的值，即使右表中没有匹配 |
| right join | 会从右表中返回所有的值，即使左表中没有匹配 |

```
思路：
1.分析需求，分析查询的字段来自哪些表， student、 result、 subject (连接查询)
2.确定使用哪种连接查询?7种
3.确定交叉点(这两个表中哪个数据是相同的)
4.判断的条件:学生表的中 studentNo =成绩表studentNo

当要查的表较多时：
1.要查询哪些数据
2.从那几个表中查FROM表XXXJoin连接的表on交叉条件
3.假设存在一种多张表查询，慢慢来，先查询两张表然后再慢慢增加
```

```
例
SELECT s.`studentNo`, `studentName` , `SubjectName`,`StudentResult`
FROM student as s
RIGHT JOIN result as r
ON r.`studentNo` = s.`studentNo`
```



![联表查询](F:\笔记\博客\文章图片\联表查询.png)



**自连接**

自己的表和自己的表连接，核心：一张表拆为两张一样的表即可。通过别名来将一张表视为两张表

```
例
SELECT a.`categoryName` AS '父栏目',b.`categoryName` AS '子栏目'
FROM `category` AS a,`category` AS b
where a.`categoryId` = b.`pid`;
```

### 分页和排序

**排序**

order by

```
order by result asc 升序
order by result desc 降序
```

**分页**

缓解数据库压力

```
limit(查询起始下标,pageSize)  
即 limit((n-1)*pageSize,pageSize)
-- n 是当前页数，pageSize是页面大小
```

### 子查询

在where语句中嵌套一个子查询语句

```
select studentNo from student where Name = (select studentID from result where grade=80) 
```

### 分组查询

group by

```

```

### 联合查询

`UNION` 操作符用于合并两个或多个`SELECT `语句的结果集

**注意**：UNION 内部的SELECT 语句必须拥有相同数量的列。且第一个 SELECT 语句中被使用的字段名称也被用于结果的字段名称。列也必须拥有相似的数据类型。同时，每条SELECT 语句中的列的顺序必须相同。

```
例
select version() union select id from users;

version()的查询结果是int型，且只有一列，所以 union 之后的那个select查询结果也必须只有一列，而且数据类型也需要类似 int
```

### select完整语法

```sql
select [all | distinct]
from tablename1 [as newname]
[left | right | inner join tablename2] -- 联表查询
[where] -- 条件查询
[group by] -- 指定结果按照哪几个字段来分组
[having] -- 过滤分组的记录必须满足的次要条件
[order by] -- 指定查询记录按一个或多个条件排序
[limit] -- 指定查询的记录从哪条至哪条

以上先后顺序不能改变
[]括号代表可选的, { }括号代表必选得
```



## MySQL常见函数

### 数学运算

```sql
SELECT ABS (-8) --绝对值
SELECT CEILING(9.4) --向上取整
SELECT FLOOR(9.4) -- 向下取整
SELECT RAND() -- 返回一个0~1之间的随机数
SELECT SIGN(10) --判断一个数的符号，0-0，负数返回-1，正数返回1
```

### 字符串函数

`concat(str1,str2 … … )` 没有分隔符的连接字符串

```
例
select concat(id,'-',name) from users;
则结果为 id-name 的拼接
```

如果连接串中存在NULL，则返回结果为NULL

```
例
select concat(id,NULL,name) from users;
则结果为 NULL
```

`concat_ws(separator,str1,str2… … )`该函数第一个参数是其他参数的分隔符，分隔符在连接字符串之间加入。分隔符可以是一个字符串，也可以是其它参数。

```
例
select concat_ws('-',id,name,password) from users;
则结果为 id - name - password 的拼接
```

分隔符为NULL，则返回结果为NULL

如果参数中存在NULL，则会被忽略

`group_concat(str1,str2… … )`将多行查询的结果以逗号为分隔符连接成为一行结果

使用场景：在注入时，由于回显位的问题，`concat() `不能一次性将多行内容展示出来，需要使用 `limit `控制挨个去显示，这时使用 `group_concat()`，可将多行内容在一行显示。

```
例
select group_concat(id,name,password) from users;
所有结果显示在一行
```

截取字符串函数

`left()`

从左开始截取字符串 `left(str,length)` ，`str`要截取的字符串 `length`要截取的长度

`right()`

从右开始截取字符

`substring(str,pos,length)`

`str`被截取字段 `pos`从第几位开始截取 `length`截取长度

`substring_index(str,delim,count)`

按关键字截取字符串 

`str`被截取字段 `delim`关键字 `count`关键字出现的次数

### 时间和日期

```sql
SELECT CURRENT DATE() --获取当前日期
SELECT CURDATE() --获取当前日期
SELECT NOW()--获取当前的时间
SELECT LOCALTIME() --本地时间
SELECT SYSDATE() --系统时间
SELECT YEAR(NOW())
SELECT MONTH(NOW())
SELECT DAY(NOW())
SELECT HOUR(NOW())
SELECT MINUTE(NOW())
SELECT SECOND(NOW())

```

### 系统

```sql
SELECT SYSTEM_USER()
SELECT USER()
SELECT VERSION()
```

### 聚合函数

| 函数名称 | 描述                           |
| -------- | ------------------------------ |
| COUNT()  | 统计查询到的记录的条数         |
| SUM()    | 求出表中某个字段所有值的总和   |
| AVG()    | 求出表中某个字段所有值的平均值 |
| MIN()    | 最小值                         |
| MAX()    | 最大值                         |

```sql
SELECT COUNT(字段名) FROM 表名
SELECT AVG(字段名) FROM 表名;
SELECT SUM(字段名) FROM 表名;
```

### MD5

md5()

如何校验：将用户传递进来的密码，进行md5加密，然后比对加密后的值

## 事务

事务是一个原子操作。是一个最小执行单元。可以甶一个或多个SQL语句组成

### 事物的四个特性（ACID）

**原子性**（Atomicity）

这些SQL语句要么都执行成功，要么都执行失败

**一致性**（Consistency）

事务完成后，符合逻辑运算，即数据总量不变

**隔离性**（Isolation）

针对多个用户同时操作，主要是排除其他事务对本次事务的影响

**持久性**（Durability）

事务没有提交，恢复到原状
事务已经提交，持久化到数据库

**隔离所导致的一些问题**

脏读

```
指一个事务读取了另外一个事务未提交的数据
```

不可重复读

```
在一个事务内读取表中的某一行数据， 多次读取结果不同
```

虚读

```
是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致
```

### 处理事务

MySQL默认开启事务自动提交

```
set autocommit = 0 关闭
set autocommit = 1 开启
```

手动处理事务

```sql
-- 关闭自动提交
SET autocommit = 0  
-- 事务开启
START TRANSACTION -- 标记一个事务的开始，从这个之后的sql都在同一个事务内
-- 提交:持久化(成功!)
COMMIT
-- 回滚:回到的原来的样子(失败!)
ROLLBACK
--事务结束
SET autocommit = 1 -- 开启自动提交
```

## 索引

索引(Index) 是帮助MySQL高效获取数据的数据结构

### 索引的分类

**主键索引（primary key）**

```
唯一的标识，主键不可重复，只能有一个列作为主键
```

**唯一索引（unique key）**

```
避免重复的列出现，唯一索引可以重复,多个列都可以标识为唯一索引
```

**常规索引（index）**

```
默认的，index、key 关键字来设置
```

**全文索引（fulltext）**

```
fulltext
```

### 索引的使用

```sql
在创建表的时候给字段增加索引
或
创建完毕后，增加索引

-- 显示所有的索引信息
SHOW INDEX FROM student
-- 增加一个索引 列名(索引名) 
ALTER TABLE `student` ADD UNIQUE `classes`(`classes`);
或
-- CREATE INDEX 索引名on表(字段)
CREATE INDEX id_ app_ user_ name ON app_ user(`name`) ;
-- EXPLAIN 分析sql执行的状况
EXPLAIN SELECT * FROM student; -- 非全文索引
EXPLAIN SELECT * FROM student WHERE MATCH(studentName) AGAINST('刘'); 
```

### 测试索引

创建100万条数据

### 索引原则

```
索引不是越多越好
不要对经常变动的数据加索引
小数据量的表不需要加索引
索引一般加在常用来查询的字段上!
```

### 索引的数据结构

```
http://blog.codinglabs.org/articles/theory-of-mysql-index.html
```

## 数据库用户管理

### MySQL权限级别

权限存储在 mysql库 的user、db、tables_priv、columns_priv、procs_priv这几个系统表中，待MySQL实例启动后就加载到内存中

```
全局——可以管理整个MySQL
库——可以管理指定的数据库
表——可以管理指定数据库的指定表
字段——可以管理指定数据库的指定表的指定字段
```

### 操作用户

用户表

```
mysql.user
```

数据库用户名的含义

```
root@127.0.0.1
用户root的访问权限为127.0.0.1，表示root用户只支持本地访问
```

开启数据库外连

使某个数据库用户支持除本地IP外的外部IP连接

```
GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'password' WITH GRANT OPTION;

password是root用户的密码；代码中的 % 表示任何IP地址，如果你的IP地址固定，可以把 % 换成你的IP地址，不换也行
```

刷新权限

每次更新权限后记得刷新权限

```
FLUSH PRIVILEGES;
```

查询当前数据库用户

```
select user();
```

查看当前用户权限

```
show grants for '用户名'@'主机地址';
```

查看所有用户（用户名、给谁授权）

```
select user,host from mysql.user; 
或 
select * from mysql.user;
```

添加用户

```
create user 用户名@'主机地址' identified by '密码';
```

创建用户同时授权

```
grant all privileges on mq.* to 用户名@主机名 identified by '密码';
```

设置与更改用户密码

```
SET PASSWORD FOR '用户名'@'主机名' = PASSWORD('新密码');
```

删除用户

```
drop user 用户名@'主机地址';
```

给用户授权

```
grant 权限 on 数据库名.表名 to 用户名@'主机名' （在这里加上 WITH GRANT OPTION，可以使他有赋权能力即root用户的权限）
```

撤销权限

```
revoke 权限 on 数据库名.表名 from '用户名'@'主机名';
```

切换用户

注意：不同用户的主机得是一样的，否则无法切换

```
使用命令 -u 用户名 -p 
```

## MySQL备份

导出

```
mysqldump -u 用户名 -p 数据库名 表1 表2 表3 > 导出的文件.sql
```

将`.sql`文件导入数据库

```
source  D:\ceshi.sql
```

## 规范设计数据库

以个人博客为例

### 需求分析

```
用户表（登录、注册、用户信息）
分类表（类别名、创建该类的用户）
文章表（作者、创建时间、标题、点击量、分类、内容）
评论表（评论时间、评论者、所属文章、评论内容、回复评论者）
友链表（链接、网站名称）
```

### E-R图

明确实体间的关系

```
user 写 blog
user 创建分类 category
友链接links
评论 user - user -blog
```

### 三大范式

**第一范式(1NF)** 

要求数据库表的每一列都是不可分割的原子数据项

```
例
姓名 	学校信息 	年龄
张三  本科 大三    20

其中学校信息需 拆为 学历、年级，以确保满足第一范式
```

**第二范式(2NF)** 

满足第一范式

每张表只描述一件事情

**第三范式(3NF)** 

满足第一范式和第二范式

第三范式需要确保数据表中的每一列数据都和主键直接相关， 而不能间接相关

注意：

实际生产中，关联查询的表不得超过三张表，因为要考虑实际性能

## 预编译

### 即时 SQL

一条 SQL 在 DB 接收到最终执行完毕返回，大致的过程如下

```
词法和语义解析

优化 SQL 语句，制定执行计划

执行并返回结果
```

如上，一条 SQL 直接是走流程处理，一次编译，单次运行，此类普通语句被称作 Immediate Statements （即时 SQL）

### 预处理 SQL

**介绍**

绝大多数情况下，某需求某一条 SQL 语句可能会被反复调用执行，或者每次执行的时候只有个别的值不同（比如 select 的 where 子句值不同，update 的 set 子句值不同，insert 的 values 值不同）。如果每次都需要经过上面的词法语义解析、语句优化、制定执行计划等，则效率就明显不行了。
所谓**预编译语句就是将此类 SQL 语句中的值用占位符替代**，可以视为将 SQL 语句模板化或者说参数化，一般称这类语句叫Prepared Statements。

预编译语句的优势在于归纳为：一次编译、多次运行，省去了解析优化等过程

此外**预编译语句能防止 SQL 注入**

**语法**

 prepare、execute、deallocate 统称为 PREPARE STATEMENT

```
# 定义预处理语句
PREPARE stmt_name FROM preparable_stmt;
# 执行预处理语句
EXECUTE stmt_name [USING @var_name , @var_name ...];
# 删除(释放)定义
{DEALLOCATE | DROP} PREPARE stmt_name;
```

```mysql
如
#利用字符串定义预处理 SQL (直角三角形计算)
mysql> PREPARE stmt1 FROM 'SELECT SQRT(POW(?,2) + POW(?,2)) AS hypotenuse';
Query OK, 0 rows affected (0.00 sec)
Statement prepared

mysql> SET @a = 3;
Query OK, 0 rows affected (0.00 sec)

mysql> SET @b = 4;                                                   
Query OK, 0 rows affected (0.00 sec)

mysql> EXECUTE stmt1 USING @a, @b;
+------------+
| hypotenuse |
+------------+
|          5 |
+------------+
1 row in set (0.00 sec)

mysql> DEALLOCATE PREPARE stmt1;                                     
Query OK, 0 rows affected (0.00 sec)
```

```mysql
如
#计算一个数加2的值
PREPARE stmt1 FROM 'SELECT (?+2) AS name';
SET @a = 3;
EXECUTE stmt1 USING @a;
DEALLOCATE PREPARE stmt1;
```

![](F:%5C%E7%AC%94%E8%AE%B0%5C%E5%8D%9A%E5%AE%A2%5C%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87%5C%E9%A2%84%E7%BC%96%E8%AF%91.jpg)



**解决limit无法传参问题**

对于 LIMIT 子句中的值，必须是常量，不得使用变量，也就是说不能使用：`SELECT * FROM TABLE LIMIT @skip, @numrows;` 如此，就可以是用 PREPARE 语句解决此问题

```mysql
mysql> SET @skip = 100; SET @numrows = 3;
Query OK, 0 rows affected (0.00 sec)

Query OK, 0 rows affected (0.00 sec)

mysql> SELECT * FROM t1 LIMIT @skip, @numrows;
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '@skip, @numrows' at line 1

mysql> PREPARE stmt3 FROM "SELECT * FROM t1 LIMIT ?, ?";
Query OK, 0 rows affected (0.00 sec)
Statement prepared

mysql> EXECUTE stmt3 USING @skip, @numrows;
+-----+--------+
| a   | filler |
+-----+--------+
| 100 | filler |
| 101 | filler |
| 102 | filler |
+-----+--------+
3 rows in set (0.00 sec)

mysql> DEALLOCATE PREPARE stmt3;
Query OK, 0 rows affected (0.00 sec)
```



**预处理 SQL 使用注意点**

* `stmt_name` 作为` preparable_stmt `的接收者，唯一标识，不区分大小写。
* `preparable_stmt` 语句中的 `? `是个占位符，所代表的是一个字符串，不需要将 `?` 用引号包含起来。
* 定义一个已存在的 `stmt_name` ，原有的将被立即释放，类似于变量的重新赋值。
* `PREPARE stmt_name` 的作用域是`session`级
* 预处理编译 SQL 是占用资源的，所以在使用后注意及时使用 DEALLOCATE PREPARE 释放资源，这是一个好习惯。

