---
layout: post   	
catalog: true 	
tags:
    - python
---



# 1. 进程

资源分配的基本单位

进程是正在运行的程序的实例
## 1.1. fork()

在 Unix/Linux 系统中`fork` 函数被用于创建进程。这个函数很特殊，对于普通的函数，调用一次，返回一次，但是调用 `fork` 一次，它返回两次。事实上，`fork` 函数创建了新的进程，我们把它称为子进程，子进程几乎是当前进程（即父进程）的一个拷贝：它会复制父进程的代码段，堆栈段和数据段。

对于父进程，`fork` 函数返回了子进程的进程号 pid。对于子进程，`fork` 函数则返回 `0`，这也是 `fork` 函数返回两次的原因，根据返回值，我们可以判断进程是父进程还是子进程。

```python
import os
pid = os.fork()
if pid < 0:
    print 'Fail to create process'
elif pid == 0:
    print 'I am child process (%s) and my parent is (%s).' % (os.getpid(), os.getppid())
else:
    print 'I (%s) just created a child process (%s).' % (os.getpid(), pid)
```
虽然子进程复制了父进程的代码段和数据段等，但是一旦子进程开始运行，子进程和父进程就是相互独立的，它们之间不再共享任何数据
## 1.2. 多进程

需要注意的是multiprocessing 在 Windows 和 Linux 平台的不一致性：一样的代码在 Windows 和 Linux 下运行的结果可能不同。因为 Windows 的进程模型和 Linux 不一样，Windows 下没有 fork

### 1.2.1. 创建进程对象

```python
from multiprocessing import Process
p = Process(参数)
```

| 参数名 | 说明                                                   |
| ------ | ------------------------------------------------------ |
| target | 执行的目标任务名，应该是一个函数名(函数名后不要加括号) |
| name   | 进程名，一般不用设置                                   |
| group  | 进程组，目前只能使用None                               |

### 1.2.2. 启动进程

```
进程对象.start()
```

例

```python
import multiprocessing
import time

def sing():
    for i in range(3):
        print("singing")
        time.sleep(0.5)

def draw():
    for i in range(3):
        print("drawing")
        time.sleep(0.5)

if __name__ == '__main__':
    process1 = multiprocessing.Process(target=sing)
    process2 = multiprocessing.Process(target=draw)

    process1.start()
    process2.start()

    # sing()
    # draw()
```

### 1.2.3. 执行带参数的任务

| 参数   | 说明                                               |
| ------ | -------------------------------------------------- |
| args   | 以元组的方式给执行任务传参，参数是按顺序进行对应的 |
| kwargs | 以字典的方式给执行任务传参，参数是按键名进行对应的 |

例

```python
import multiprocessing
import time

def sing(num):
    for i in range(num):
        print("singing")
        time.sleep(0.5)

def draw(num):
    for i in range(num):
        print("drawing")
        time.sleep(0.5)

if __name__ == '__main__':
    process1 = multiprocessing.Process(target=sing,args=(3,))	#使用元组进行传参
    
    process2 = multiprocessing.Process(target=draw,kwargs={"num":3})
    #使用字典进行传参

    process1.start()
    process2.start()

    # sing(3)
    # draw(3)
```

### 1.2.4. 获取当前进程编号

```python
os.getpid()
```

### 1.2.5. 获取当前父进程编号

```python
os.getppid()
```

## 1.3. 设置守护主进程

正常状态下，主进程会默认等待所有子进程执行结束再结束

如果希望主进程结束的同时结束所有子进程，就需要设置守护主进程

```python
进程名.daemon = True  #在启动进程前设置
```

例

```python
import multiprocessing

import time

def sing():

    for i in range(10):
        print("singing")
        time.sleep(0.5)


if __name__ == '__main__':
    process1 = multiprocessing.Process(target=sing)

    process1.daemon = True      #设置主进程守护

    process1.start()

    time.sleep(1)

    print("主进程结束")
```

## 1.4. 阻塞进程

join 方法，该方法用于阻塞子进程以外的所有进程（这里指父进程），当子进程执行完毕后，父进程才会继续执行，它通常用于进程间的同步

## 1.5. 结束进程

不管任务是否完成，立即停止工作进程

```
进程对象.terminate()
```

但是通过执行系统命令ps查看停止后的进程, 会发现, 直接调用terminate方法停止的进程变成了一个僵尸进程(defunct), 只能等待主程序退出, 这个僵尸进程才会消失.

通过在terminate后添加一次调用join方法等待进程真正结束, 就能避免出现僵尸进程:

```
进程对象.terminate()
进程对象.join()
```



## 1.6. 进程池

```python
import os, time  
from multiprocessing import Pool  
def foo(x):  
    print('Run task %s (pid:%s)...' % (x, os.getpid()))  
    time.sleep(2)  
    print('Task %s result is: %s' % (x, x * x))  
  
  
if __name__ == '__main__':  
    print('Parent process %s.' % os.getpid())  
    p = Pool(4)         # 设置进程数  
    for i in range(5):  
        p.apply_async(foo, args=(i,))    # 设置每个进程要执行的函数和参数  
    print('Waiting for all subprocesses done...')  
    p.close()  
    p.join()  
    print('All subprocesses done.')
```

Pool 用于生成进程池，对 Pool 对象调用 apply_async 方法可以使每个进程异步执行任务，也就说不用等上一个任务执行完才执行下一个任务，close 方法用于关闭进程池，确保没有新的进程加入，join 方法会等待所有子进程执行完毕

## 1.7. 进程间通信

由于每个进程都有各自的内存空间，数据栈等，所以只能使用进程间通讯（Inter-Process Communication, IPC），而不能直接共享信息

Python 的 multiprocessing 模块封装了底层的实现机制，让我们可以通过Queue很容易地实现进程间的通信

```python
import time  
from multiprocessing import Process, Queue  
# 向队列中写入数据  
def write_task(q):  
    try:  
        n = 1  
        while n < 5:  
            print("write, %d" % n)  
            q.put(n)  
            time.sleep(1)  
            n += 1  
    except BaseException:  
        print("write_task error")  
    finally:  
        print("write_task end")  
  
  
# 从队列读取数据  
def read_task(q):  
    try:  
        n = 1  
        while n < 5:  
            print("read, %d" % q.get())  
            time.sleep(1)  
            n += 1  
    except BaseException:  
        print("read_task error")  
    finally:  
        print("read_task end")  
  
  
if __name__ == "__main__":  
    q = Queue()  # 父进程创建Queue，并传给各个子进程  
    pw = Process(target=write_task, args=(q,))  
    pr = Process(target=read_task, args=(q,))  
    pw.start()   # 启动子进程 pw，写入  
    pr.start()   # 启动子进程 pr，读取  
    pw.join()    # 等待 pw 结束  
    pr.join()    # 等待 pr 结束  
    print("DONE")
```


## 1.8. 实现多进程文件拷贝器

```python
import multiprocessing

import os

def copy(file_name,source_dir,dest_dir):
    source_path = source_dir + '/' + file_name  #拼接源文件路径和
    dest_path = dest_dir + '/' + file_name  #拼接目标文件路径


    with open(source_path,'rb') as source_file:     #打开源文件和目标文件
        with open(dest_path,'wb') as dest_file:

            while True:
                data = source_file.read(1024)
                if data:
                    dest_file.write(data)
                else:
                    break


if __name__ == '__main__':

    source_dir = ''
    dest_dir = ''

    try:
        os.mkdir(dest_dir)     #创建目标文件夹
    except:
        print('目标文件夹已存在')

    file_list = os.listdir(source_dir)

    for file_name in file_list:

        process = multiprocessing.Process(target=copy,args=(file_name,source_dir,dest_dir))

        process.start()

```
# 2. 线程

执行程序的最小单元

进程是线程的容器

一个进程中最少有一个线程负责执行程序

它与同属一个进程的其他线程共享进程所拥有的全部资源

## 2.1. 实现多线程

### 2.1.1. 导入线程模块

```python
import threading
```

### 2.1.2. 创建线程对象

```python
线程对象 = threading.Thread(target=任务名)
```

| 参数   | 说明                           |
| ------ | ------------------------------ |
| target | 执行的目标任务名，一般是函数名 |
| name   | 线程名                         |
| group  | 线程组，目前只能使用None       |

### 2.1.3. 启动线程

```python
线程对象.start()
```

例

```python
import threading
import time
def sing():
    for i in range(5):
        print('sing')
        time.sleep(1)

def dance():
    for i in range(5):
        print('dance')
        time.sleep(1)

if __name__ == '__main__':
    # sing()
    # dance()
    sing_thread = threading.Thread(target=sing)
    dance_thread = threading.Thread(target=dance)
    
    sing_thread.start()
    dance_thread.start()
```

### 2.1.4. 线程执行带参数的任务

| 参数   | 说明                                               |
| ------ | -------------------------------------------------- |
| args   | 以元组的方式给执行任务传参，参数是按顺序进行对应的 |
| kwargs | 以字典的方式给执行任务传参，参数是按键名进行对应的 |

## 2.2. 设置守护线程

正常状态下，主线程会默认等待所有子线程执行结束再结束

如果希望主线程结束的同时结束所有子线程，就需要设置守护主线程

```python
线程对象 = threading.Thread(target= ,daemon=True)
```

或

```python
线程对象.setDaemon(True)
```

例

```python
import threading
import time
def sing():
    for i in range(5):
        print('sing')
        time.sleep(1)

if __name__ == '__main__':
    # sing()
    # dance()
    sing_thread = threading.Thread(target=sing)

    sing_thread.setDaemon(True)
    sing_thread.start()

    time.sleep(1)
    print("主线程结束")
```



## 2.3. 线程阻塞

使用join方法，让主线程等待子线程执行

线程间的执行顺序是无序的，是由CPU调度决定的，是随机的

```python
import threading
import time

def test():
    time.sleep(1)
    print(threading.current_thread())

if __name__ == '__main__':

    for i in range(5):
        th = threading.Thread(target=test)
        th.start()
```

## 2.4. 互斥锁

当多个线程同时修改同一条数据时可能会出现脏数据，所以，出现了线程锁，即同一时刻允许一个线程执行操作。线程锁用于锁定资源，你可以定义多个锁, 像下面的代码, 当你需要独占某一资源时，任何一个锁都可以锁这个资源，就好比你用不同的锁都可以把相同的一个门锁住是一个道理。

由于线程之间是进行随机调度，如果有多个线程同时操作一个对象，如果没有很好地保护该对象，会造成程序结果的不可预期，我们也称此为“线程不安全”。

```python
from threading import Thread,Lock
import os,time
def work():
    global n
    lock.acquire()
    temp=n
    time.sleep(0.1)
    n=temp-1
    lock.release()
if __name__ == '__main__':
    lock=Lock()
    n=100
    l=[]
    for i in range(100):
        p=Thread(target=work)
        l.append(p)
        p.start()
    for p in l:
        p.join()
```

## 2.5. 递归锁

用法和Lock类一模一样，但它支持嵌套，在多个锁没有释放的时候一般会使用RLcok类

```python
import threading
import time

def Func(lock):
    global gl_num
    lock.acquire()
    gl_num += 1
    time.sleep(1)
    print(gl_num)
    lock.release()

if __name__ == '__main__':
    gl_num = 0
    lock = threading.RLock()
    for i in range(10):
        t = threading.Thread(target=Func, args=(lock,))
        t.start()
```

## 2.6. 信号量

BoundedSemaphore类。互斥锁同时只允许一个线程更改数据，而Semaphore是同时允许一定数量的线程更改数据 ，比如厕所有3个坑，那最多只允许3个人上厕所，后面的人只能等里面有人出来了才能再进去

```python
import threading
import time

def run(n, semaphore):
    semaphore.acquire()   #加锁
    time.sleep(1)
    print("run the thread:%s\n" % n)
    semaphore.release()     #释放

if __name__ == '__main__':
    num = 0
    semaphore = threading.BoundedSemaphore(5)  # 最多允许5个线程同时运行
    for i in range(22):
        t = threading.Thread(target=run, args=("t-%s" % i, semaphore))
        t.start()
    while threading.active_count() != 1:
        pass  # print threading.active_count()
    else:
        print('-----all threads done-----')
```

## 2.7. 事件

Event类。python线程的事件用于主线程控制其他线程的执行，事件是一个简单的线程同步对象

主要提供以下几个方法

- clear 将flag设置为“False”
- set 将flag设置为“True”
- is_set 判断是否设置了flag
- wait 会一直监听flag，如果没有检测到flag就一直处于阻塞状态

事件处理的机制：全局定义了一个“Flag”，当flag值为“False”，那么event.wait()就会阻塞，当flag值为“True”，那么event.wait()便不再阻塞

```python
#利用Event类模拟红绿灯
import threading
import time

event = threading.Event()


def lighter():
    count = 0
    event.set()     #初始值为绿灯
    while True:
        if 5 < count <=10 :
            event.clear()  # 红灯，清除标志位
            print("\33[41;1mred light is on...\033[0m")
        elif count > 10:
            event.set()  # 绿灯，设置标志位
            count = 0
        else:
            print("\33[42;1mgreen light is on...\033[0m")

        time.sleep(1)
        count += 1

def car(name):
    while True:
        if event.is_set():      #判断是否设置了标志位
            print("[%s] running..."%name)
            time.sleep(1)
        else:
            print("[%s] sees red light,waiting..."%name)
            event.wait()
            print("[%s] green light is on,start going..."%name)

light = threading.Thread(target=lighter,)
light.start()

car = threading.Thread(target=car,args=("MINI",))
car.start()
```

## 2.8. 实例

```python
import os
import threading
import time

def copy(file_name,source_dir,dest_dir):
    source_path = source_dir + '/' + file_name  #拼接源文件路径和
    dest_path = dest_dir + '/' + file_name  #拼接目标文件路径


    with open(source_path,'rb') as source_file:     #打开源文件和目标文件
        with open(dest_path,'wb') as dest_file:

            while True:
                data = source_file.read(1024)
                if data:
                    dest_file.write(data)
                else:
                    break

if __name__ == '__main__':
    source_dir = ''
    dest_dir = ''

    try:
        os.mkdir(dest_dir)  # 创建目标文件夹
    except:
        print('目标文件夹已存在')

    file_list = os.listdir(source_dir)

    for file_name in file_list:
        th = threading.Thread(target=copy, args=(file_name, source_dir, dest_dir))

        th.start()
```

## 2.9. 销毁子线程（重要）

要做到主线程不结束，但是要强行结束子线程

**方法一：使用ctypes强行杀掉线程**

```python
import threading
import time
import inspect
import ctypes


def _async_raise(tid, exctype):
    """raises the exception, performs cleanup if needed"""
    tid = ctypes.c_long(tid)
    if not inspect.isclass(exctype):
        exctype = type(exctype)
    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, ctypes.py_object(exctype))
    if res == 0:
        raise ValueError("invalid thread id")
    elif res != 1:
        # """if it returns a number greater than one, you're in trouble,
        # and you should call it again with exc=NULL to revert the effect"""
        ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, None)
        raise SystemError("PyThreadState_SetAsyncExc failed")


def stop_thread(thread):
    _async_raise(thread.ident, SystemExit)


def test_thread():
    i = 0
    while True:
        print(i+1)
        time.sleep(2)


if __name__ == "__main__":
    t = threading.Thread(target=test_thread)
    t.start()
    stop_thread(t)
```

**方法二：使用全局变量控制退出条件**

```python
import threading
import time

# 全局变量，用于控制子线程退出
stop_flag = False

# 子线程的执行函数
def child_thread():
    print("子线程开始执行")
    while not stop_flag:
        print("子线程正在运行")
        time.sleep(1)

    print("子线程退出")

# 创建子线程并启动
thread = threading.Thread(target=child_thread)
thread.start()

# 在主线程中等待一段时间
time.sleep(5)

# 修改全局变量，通知子线程退出
stop_flag = True

# 等待子线程结束
thread.join()

print("主线程结束")
```


## 2.10. ThreadLocal

## 2.11. 协程


# 3. 数据通信

一般情况可选的方式：少量数据可用全局变量的方式，大量数据使用消息队列

## 3.1. 线程间

如果我们要多个线程累加同一个变量，对于thread来说，申明一个global变量，用thread.Lock的context包裹住三行就搞定了。
