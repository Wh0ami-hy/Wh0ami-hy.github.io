---
layout: post   	
catalog: true 	
tags:
    - Web
---





# 1. 前言

## 1.1. Cookie

 Cookie是一种在用户计算机上存储数据的技术，可以用于保存用户身份验证信息。Web应用可以将用户身份验证信息保存在Cookie中，然后在用户下次访问时从Cookie中读取这些信息。随着Web应用的不断发展，Cookie技术也得到了不断升级，例如HttpOnly、Secure、SameSite等。

## 1.2. Session

Session是一种在服务器端存储数据的技术，用于保存用户身份验证信息。Web应用可以在用户登录时为其创建一个Session，当用户访问其他页面时，服务器根据由Cookie携带的`session_id`从对应的Session中读取用户身份验证信息。Session技术的优点是可以避免用户身份验证信息被窃取，但是它需要占用服务器端的资源。

## 1.3. Token

Token是一种短暂的、可撤销的凭证，用于验证用户身份。Web应用可以在用户登录时为其创建一个Token，并在每次请求中将Token传递给服务器，服务器端可以通过验证Token的合法性来验证用户身份。Token技术的优点是可以避免服务器端存储用户身份验证信息，从而减轻服务器端的负担。

可以把Token 放在Cookie里面自动发送，但是这样不能跨域。更好的做法是放在HTTP请求的头信息Authorization字段里面，单独发送

# 2. 用户认证技术的发展

## 2.1. 基于HTTP的基本认证

最初的Web认证方案是基于HTTP的基本认证，即**在HTTP头部中添加用户名和密码**。这种方式简单易用，但是密码会以明文形式传输，存在安全问题。

## 2.2. 基于表单的认证

随着Web应用的不断发展，基于HTTP的基本认证已经无法满足安全需求，基于表单的认证逐渐成为主流。基于表单的认证是**通过Web表单收集用户名和密码**，然后通过加密算法加密后发送到服务器进行验证，并在服务器端保持会话状态。

## 2.3. 单点登录（SSO）认证

随着Web应用的不断增加，用户需要在多个应用之间进行切换，单点登录（SSO）认证方案应运而生。单点登录是一种基于中心认证服务器的认证方式，用户只需要在认证服务器上登录一次，就可以访问所有受信任的应用。

## 2.4. OAuth认证

OAuth是一种授权机制，允许用户授权第三方应用访问其资源。OAuth的目标是为用户提供更加安全、灵活和易用的授权机制，同时保护用户的隐私和安全。

## 2.5. 基于生物特征的认证

随着生物技术的发展，基于生物特征的认证逐渐成为一种趋势。生物特征认证是指通过人体生物特征进行身份验证，例如指纹、虹膜、声纹等。


# 3. Session和cookie的特征

**产生**

session和cookie都是由服务器生成的，都是用来存储特定的值（键值对应）

**SessionID**

SessionID会以类似于cookie的方式返回给客户端。SessionID是服务器用来识别、操作存储session值的对象的。在服务器端，session的存储方式有文件方式、数据库方式，sessionID就是用来识别这个文件的（文件名相关)、识别数据库的某一条记录。sessionID并不是session值。

**生命周期**

客户端（浏览器）在发送请求的时候，会自动将存活、可用的cookie封装在请求头中和请求一起发送

Cookie的生命周期由过期时间和持久性两个因素决定。过期时间是指Cookie在用户计算机上保留的时间，持久性是指Cookie是否在浏览器关闭后仍然保留。如果没有指定过期时间和持久性，则Cookie的生命周期默认为会话级别，即在用户关闭浏览器时自动删除。

Session的生命周期由服务器端的会话管理器控制，一般情况下，Session会在用户登录时创建，并在用户注销或超时后销毁。

**作用域**

cookie和session都是有其作用域的

Cookie的作用域由域名、路径和协议三个因素决定。只有在Cookie的作用域内才能被浏览器发送到服务器。

Session的作用域仅限于服务器端，客户端无法直接访问Session。Web应用可以通过在Cookie中保存Session ID的方式来跨请求管理Session。

**session比cookie安全**

* cooke是存储在客户端的，是可见的，是可以改变的。

- session是存储在服务器端的，是不可见的，是不可改变的。

# 4. Token的由来

假设登录请求打到了 A 机器，A 机器生成了 session 并在 cookie 里添加 sessionId 返回给了浏览器，那么问题来了：下次添加购物车时如果请求打到了 B 或者 C，由于 session 是在 A 机器生成的，此时的 B,C 是找不到 session 的，那么就会发生无法添加购物车的错误，就得重新登录了，此时请问该怎么办。主要有以下三种方式

## 4.1. session 复制

A 生成 session 后复制到 B, C，这样每台机器都有一份 session，无论添加购物车的请求打到哪台机器，由于 session 都能找到

## 4.2. session 粘连

让每个客户端请求只打到固定的一台机器上，比如浏览器登录请求打到 A 机器后，后续所有的添加购物车请求也都打到 A 机器上

## 4.3. session 共享

目前各大公司普遍采用的方案，将 session 保存在 redis，memcached 等中间件中，请求到来时，各个机器去这些中间件取一下 session

首先请求方输入自己的用户名，密码，然后 server 据此生成 token，客户端拿到 token 后会保存到本地（以cookie的形式或 local storage），之后向 server 请求时在请求头带上此 token 即可。

token 只存储在浏览器中，服务端却没有存储，这样的话我随便搞个 token 传给 server 也行？

```
答：server 会有一套校验机制，校验这个 token 是否合法。
```

怎么不像 session 那样根据 sessionId 找到 userid 呢，这样的话怎么知道是哪个用户？

```
答：token 本身携带 uid 信息
```

如何校验 token 呢？

```
答：我们可以借鉴 HTTPS 的签名机制来校验
```

token 主要由三部分组成

```
header：指定了签名算法

payload：可以指定用户 id，过期时间等非敏感数据

Signature: 签名，server 根据 header 知道它该用哪种签名算法，再用密钥根据此签名算法对 head + payload 生成签名，这样一个 token 就生成了。
```

当 server 收到浏览器传过来的 token 时，它会首先取出 token 中的 header + payload，根据密钥生成签名，然后再与 token 中的签名比对，如果成功则说明签名是合法的，即 token 是合法的。而且你会发现 payload 中存有我们的 userId，所以拿到 token 后直接在 payload 中就可获取 userid，避免了像 session 那样要从 redis 去取的开销

你会发现这种方式确实很妙，只要 server 保证密钥不泄露，那么生成的 token 就是安全的，因为如果伪造 token 的话在签名验证环节是无法通过的，就此即可判定 token 非法。

不过需要注意的是，token 一旦由 server 生成，它就是有效的，直到过期，无法让 token 失效，除非在 server 为 token 设立一个黑名单，在校验 token 前先过一遍此黑名单，如果在黑名单里则此  token 失效，但一旦这样做的话，那就意味着黑名单就必须保存在 server，这又回到了 session 的模式，那直接用 session 不香吗。所以一般的做法是当客户端登出要让 token 失效时，直接在本地移除 token 即可，下次登录重新生成 token 就好。

另外需要注意的是 token 一般是放在 header 的 Authorization 自定义头里，不是放在 Cookie 里的，这主要是为了解决跨域不能共享 Cookie 的问题


## 4.4. Cookie 的局限性

**Cookie 跨站是不能共享的**，难以实现多应用（多系统）的单点登录（SSO）

**所谓单点登录，是指在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。**

但如果用 token 来实现 SSO 会非常简单

只要在 header 中的 authorize 字段（或其他自定义）加上 token 即可完成所有跨域站点的认证。

在移动端原生请求是没有 cookie 之说的，而 sessionid 依赖于 cookie，sessionid 就不能用 cookie 来传了，如果用 token 的话，由于它是随着 header 的 authoriize 传过来的，也就不存在此问题，换句话说token 天生支持移动平台，可扩展性好

综上所述，token 具有存储实现简单，扩展性好这些特点

## 4.5. token 缺点

* token 太长了

token 是 header, payload 编码后的样式，所以一般要比 sessionId 长很多，很有可能超出 cookie 的大小限制（cookie 一般有大小限制的，如 4kb）

* 不安全

token 是存在浏览器的，它太长放在 cookie 里可能导致 cookie 超限，那就只好放在 local storage 里，这样会造成安全隐患，因为 local storage 这类的本地存储是可以被 JS 直接读取的，另外由上文也提到，token 一旦生成无法让其失效，必须等到其过期才行，这样的话如果服务端检测到了一个安全威胁，也无法使相关的 token 失效。

**所以 token 更适合一次性的命令认证，设置一个比较短的有效期**

# 5. CSRF 攻击

攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过（cookie 里带来 sessionId 等身份认证的信息），所以被访问的网站会认为是真正的用户操作而去运行

```
比如用户登录了某银行网站（假设为 http://www.examplebank.com/，并且转账地址为 http://www.examplebank.com/withdraw?amount=1000&transferTo=PayeeName），登录后 cookie 里会包含登录用户的 sessionid，攻击者可以在另一个网站上放置如下代码
<img src="http://www.examplebank.com/withdraw?account=Alice&amount=1000&for=Badman">
```

那么如果正常的用户误点了上面这张图片，**由于相同域名的请求会自动带上 cookie**，而 cookie 里带有正常登录用户的 sessionid，类似上面这样的转账操作在 server 就会成功，会造成极大的安全风险

**CSRF 攻击的根本原因在于对于同样域名的每个请求来说，它的 cookie 都会被自动带上，这个是浏览器的机制决定的**