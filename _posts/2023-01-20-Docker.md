---
layout: post   	
catalog: true 	
tags:
    - Docker
---





# 1. Docker 是什么

对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器

Docker允许开发中将应用、依赖、函数库、配置一起打包，形成可移植镜像

Docker镜像中包含完整运行环境， 包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行

传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程。而**容器内的应用进程直接运行于宿主的内核**，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便

# 2. 为什么要用 Docker

- 更高效的利用系统资源
- 更快速的启动时间
- 一致的运行环境。开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。
- 持续交付和部署。一次创建或配置，可以在任意地方正常运行。使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合持续部署系统进行自动部署。而且使用Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件。
- 更轻松的迁移。Docker 确保了执行环境的一致性
- 更轻松的维护和扩展。`Docker` 使用的分层存储以及镜像的技术，使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。[官网镜像库](https://hub.docker.com/search/?type=image&image_filter=official&q=)



# 3. Docker 基本组成

镜像、容器、仓库 这三个概念，涵盖了 Docker 的整个生命周期

## 3.1. 镜像

Docker 镜像 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 **不包含任何动态数据**，其内容在构建之后也不会被改变

### 3.1.1. 分层存储（重点）

Docker 镜像构建时，会一层一层地构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。

比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。

分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像

## 3.2. 容器

镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等

**容器的实质是进程**，但与直接在宿主执行的进程不同，容器进程运行于属于**自己的独立的命名空间**（ the same namespace for a set of resources and processes, but those namespaces refer to distinct resources. Resources may exist in multiple spaces）

Docker 不是虚拟机，**容器中的应用都应该以前台执行**，而不是像虚拟机、物理机里面那样，用 `systemd` 去启动后台服务，**容器内没有后台服务的概念**。

对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西

### 3.2.1. 容器存储层

每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，一个为容器运行时读、写而准备的存储层

容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡

Docker **最佳实践**的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。**所有的文件写入操作，都应该使用数据卷、或者绑定宿主目录**，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。

## 3.3. 仓库

镜像构建完成后，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。

一个 Docker Registry 中可以包含多个仓库。每个仓库可以包含多个标签（Tag）。每个标签对应一个镜像。

通常，一个仓库包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过`<仓库名>:<标签>`的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以latest 作为默认标签。

### 3.3.1. 公开 Docker Registry

一般这类公开服务允许用户免费上传、下载公开的镜像

最常使用的 Registry 公开服务是官方的 [Docker Hub](https://hub.docker.com/)，这也是默认的 Registry，并拥有大量的高质量的 [官方镜像](https://hub.docker.com/search?q=&type=image&image_filter=official)。除此以外，还有 Red Hat 的 [Quay.io](https://quay.io/repository/)；Google 的 [Google Container Registry](https://cloud.google.com/container-registry/)，[Kubernetes](https://kubernetes.io/) 的镜像使用的就是这个服务；代码托管平台 [GitHub](https://github.com) 推出的 [ghcr.io](https://docs.github.com/cn/packages/working-with-a-github-packages-registry/working-with-the-container-registry)

### 3.3.2. 私有 Docker Registry

用户还可以在本地搭建私有 Docker Registry

# 4. 安装Docker

## 4.1. 使用官方脚本自动安装（推荐）
```shell
curl -fsSL get.docker.com -o get-docker.sh
sudo sh get-docker.sh --mirror Aliyun
```

## 4.2. 启动

```shell
sudo systemctl enable docker
sudo systemctl start docker
```

## 4.3. 建立 docker 用户组

默认情况下，docker命令会使用 [Unix socket](https://en.wikipedia.org/wiki/Unix_domain_socket) 与 Docker 引擎通讯。而只有root用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 `root` 用户。因此，更好地做法是**将需要使用 docker 的用户加入 docker 用户组**

建立docker组

```shell
sudo groupadd docker
```

将当前用户加入 docker 组

```shell
sudo usermod -aG docker $USER
```

## 4.4. 测试 Docker 是否安装正确

```shell
docker run --rm hello-world
```

## 4.5. 镜像加速

查看是否在 `docker.service` 文件中配置过镜像地址

```shell
systemctl cat docker | grep '\-\-registry\-mirror'
```

如果该命令有输出，那么请执行 `$ systemctl cat docker` 查看 `ExecStart=` 出现的位置，修改对应的文件内容去掉 `--registry-mirror` 参数及其值，并按接下来的步骤进行配置。

如果以上命令没有任何输出，那么就可以在 `/etc/docker/daemon.json` 中写入如下内容（如果文件不存在请新建该文件）：

```json
{
"registry-mirrors": [
	"https://hub-mirror.c.163.com",
	
	"https://mirror.baidubce.com"
	]
}
```

重新启动服务

```shell
sudo systemctl daemon-reload
sudo systemctl restart docker
```

检查加速器是否生效

```shell
docker info
```

# 5. Docker 架构

## 5.1. 客户端

通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。

## 5.2. 服务端

Docker守护进程， 负责处理Docker指令，管理镜像、容器等

# 6. Docker 镜像操作

Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像

## 6.1. 获取镜像

访问DockerHub搜索镜像，https://hub.docker.com/

Docker 镜像仓库地址：地址的格式一般是 `<域名/IP>[:端口号]`。默认地址是 `docker.io`

```shell
docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]
```

## 6.2. 运行

```shell
docker run
```

通过 `exit` 退出容器

## 6.3. 列出镜像

查看本地镜像

```shell
docker image ls
```

查看镜像、容器、数据卷所占用的空间

```shell
docker system df
```

同时显示依赖的中间层镜像

```shell
docker image ls -a
```

## 6.4. 导出导入

导出镜像到本地

```
docker save -o <保存的文件名>.tar <镜像名称>
```

导入

```
docker load -i /path/to/myimage.tar
```

这将在另一台机器上导入名为`myimage`的镜像

## 6.5. 删除镜像

`<镜像>` 可以是 `镜像短 ID`、`镜像长 ID`、`镜像名` 或者 `镜像摘要`

```shell
docker image rm [选项] <镜像1> [<镜像2> ...]
```

**Untagged 和 Deleted**

删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 `Untagged` 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 `Delete` 行为就不会发生。所以并非所有的 `docker image rm` 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已

当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层

除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像

## 6.6. Dockerfile定制镜像（重点）

所谓定制镜像，是以一个镜像为基础，在其上进行定制

镜像的定制实际上就是定制每一层所添加的配置、文件。我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile

禁止使用 docker commit定制镜像，使用 docker commit 意味着除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知

Dockerfile 是一个文本文件，其内包含了一条条的指令（Instruction），**每一条指令构建一层**，因此每一条指令的内容，就是描述该层应当如何构建

建立一个文本文件，并命名为 Dockerfile

```shell
touch Dockerfile
```

### 6.6.1. Dockerfile指令

[Dockerfile最佳实践](https://yeasy.gitbook.io/docker_practice/appendix/best_practices)

```txt
FROM python:3.8.10
ENV PYTHONUNBUFFERED 1
RUN mkdir /code
WORKDIR /code
COPY requirements.txt /code/
RUN pip install -r requirements.txt
COPY . /code/
```

**FROM 命令**

**指定基础镜像，因此一个 `Dockerfile` 中 `FROM` 是必备的指令，并且必须是第一条指令**

除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 `scratch`。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。如果以 `scratch` 为基础镜像的话，意味着不以任何镜像为基础

**RUN 命令**

`RUN` 指令用来执行命令行的命令，其格式有两种：

- shell 格式：`RUN <命令>`，就像直接在命令行中输入的命令一样
- exec 格式：`RUN ["可执行文件", "参数1", "参数2"]`，这更像是函数调用中的格式

**Dockerfile 支持 Shell 类的行尾添加 `\` 的命令换行方式，以及行首 `#` 进行注释的格式**

此外，通常要在一组命令的最后添加清理工作的命令 `apt-get purge -y --auto-remove $buildDeps`，删除为了编译构建所需要的软件，清理所有下载、展开的文件，并且清理 `apt` 缓存文件。这是很重要的一步，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉

**COPY**

将从构建上下文目录中 `<源路径>` 的文件或目录复制到新的一层的镜像内的 `<目标路径>` 位置。`COPY <源路径> <目标路径>`

`<目标路径>` 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 `WORKDIR` 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。

需要注意，使用 `COPY` 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用

如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径

**COPY 命令的源路径是相对于构建上下文（即通过 `docker build` 命令传递给 Docker 的目录或文件）**

**ADD**

与COPY类似，但还支持从URL中下载文件，并且可以自动解压压缩文件。

Dockerfile **最佳实践**中要求，所有的文件复制均使用 `COPY` 指令，仅在需要自动解压缩的场合使用 `ADD`。

**WORKDIR**

设置工作目录，改变以后各层的工作目录的位置。`WORKDIR <工作目录路径>`

如该目录不存在，`WORKDIR` 会帮你建立目录。

**工作目录就是容器运行时所用的根目录**

**EXPOSE**

声明容器运行时需要开放的端口。`EXPOSE <端口>`

要将 `EXPOSE` 和在运行时使用 `-p <宿主端口>:<容器端口>` 区分开来。`-p`，是映射宿主端口和容器端口，也就是将容器的对应端口服务公开给外界访问，而 `EXPOSE` 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。

在 Dockerfile 中使用 EXPOSE 声明的好处是在容器运行时，使用随机端口映射时，也就是 `docker run -P` 时，会自动随机映射 `EXPOSE` 的端口。

**ENV**

设置环境变量。

定义了环境变量，无论是后面的其它指令，还是运行时的应用，都可以直接使用定义的环境变量。

通过环境变量，可以让一份 `Dockerfile` 制作更多的镜像，只需使用不同的环境变量即可。

**CMD**

设置容器启动后默认执行的命令。

**ENTRYPOINT**

设置容器启动后默认执行的命令，与CMD不同的是，ENTRYPOINT指定的命令不会被覆盖。

**USER**

设置容器中执行命令的用户。

**VOLUME**

声明持久化数据的目录，可以在容器中挂载主机的目录。`VOLUME <路径>`

容器运行时应该尽量保持容器存储层不发生写操作，在 `Dockerfile` 中，可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据

**ARG**

构建参数和 `ENV` 的效果一样，都是设置环境变量。所不同的是，`ARG` 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。

### 6.6.2. 构建镜像

```shell
docker build [选项] <上下文路径/URL/->
```

### 6.6.3. 镜像构建上下文（重点）

`docker build` 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，`docker build` 命令构建镜像，并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？

这就引入了上下文的概念。**当构建的时候，用户会指定构建镜像上下文的路径**，`docker build` 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。

**一般大家习惯性的会使用默认的文件名 `Dockerfile`，以及会将其置于镜像构建上下文目录中。**

### 6.6.4. 多阶段构建



# 7. Docker 容器操作

容器是独立运行的一个或一组应用，以及它们的运行态环境

## 7.1. 启动

启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（`exited`）的容器重新启动。

### 7.1.1. 新建并启动

命令主要为 `docker run`

当利用 `docker run` 来创建容器时，Docker 在后台运行的标准操作包括：

-   检查本地是否存在指定的镜像，不存在就从仓库下载

-   利用镜像创建并启动一个容器

-   分配一个文件系统，并在只读的镜像层外面挂载一层可读写层

-   从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去

-   从地址池配置一个 ip 地址给容器

-   执行用户指定的应用程序

-   执行完毕后容器被终止

### 7.1.2. 启动已终止容器

利用 `docker container start` 命令，直接将一个已经终止（`exited`）的容器启动运行。

## 7.2. 守护态运行

更多的时候，需要**让 Docker 在后台运行**而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 `-d` 参数来实现

命令主要为 `docker run -d`

**注：** 容器是否会长久运行，是和 `docker run` 指定的命令有关，和 `-d` 参数无关

要获取容器的输出信息，可以通过 `docker container logs` 命令

使用 `-d` 参数启动后会返回一个唯一的 id，也可以通过 `docker container ls` 命令来查看容器信息

## 7.3. 终止

使用 `docker container stop` 来终止一个运行中的容器

**注：** 当 Docker 容器中指定的应用终结时，容器也自动终止

## 7.4. 进入容器

推荐使用 `docker exec` 命令

只用 `-i` 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。

当 `-i` `-t` 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符

## 7.5. 导出导入

导出容器快照到本地 `tar`文件，可以使用 `docker export` 命令
```
docker export [CONTAINER ID] > ubuntu.tar
```

导入。可以使用`docker load` 来导入镜像存储文件到本地镜像库，也可以使用`docker import` 来导入一个容器快照到本地镜像库。

**镜像与容器快照的区别**

容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息

## 7.6. 删除

使用 `docker container rm` 来删除一个处于终止状态的容器

要删除一个运行中的容器，可以添加 `-f` 参数

清理掉所有处于终止状态的容器`docker container prune`

# 8. Docker 仓库

仓库（`Repository`）是集中存放镜像的地方

## 8.1. Docker Hub

https://hub.docker.com/

## 8.2. 私有仓库

一个本地仓库供私人使用

docker-registry 是官方提供的工具，可以用于构建私有的镜像仓库


# 9. Docker 数据管理

在容器中管理数据主要有两种方式：

-   数据卷（Volumes）
-   挂载主机目录 (Bind mounts)

## 9.1. 数据卷

### 9.1.1. 数据卷特点

数据卷可以在容器之间共享和重用，容器间传递数据将变得高效与方便

对数据卷内数据的修改会立马生效，无论是容器内操作还是本地操作

对数据卷的更新不会影响镜像，解耦开应用和数据

数据卷默认会一直存在，即使容器被删除

### 9.1.2. 数据卷操作命令

数据卷操作的基本语法为：`docker volume [COMMAND]`，其中COMMAND是某个具体的命令

**创建一个数据卷**

`docker volume create my-vol`

**列出所有的数据卷**

`docker volume ls`

**查看指定数据卷的信息** 

`docker volume inspect my-vol`

**启动一个挂载数据卷的容器**

在用 `docker run` 命令的时候，使用 `--mount` 标记来将数据卷挂载到容器里。在一次 `docker run` 中可以挂载多个数据卷（在linux的docker主机中创建一个卷时， 其在宿主机对应的目录或挂载点路径为`/var/lib/docker/volumes/卷名/_ data`）

**删除指定的数据卷** 

`docker volume rm my-vol`

**在删除容器的同时移除数据卷**

数据卷是用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 `docker rm -v` 这个命令。

**删除未使用的数据卷**

`docker volume prune`

## 9.2. 挂载主机目录

**挂载一个主机目录或文件作为数据卷**

在用 `docker run` 命令的时候，使用 `--mount` 标记可以指定挂载一个本地主机的目录或文件到容器中去

Docker 挂载主机目录的默认权限是 `读写`，用户也可以通过增加 `readonly` 指定为 `只读`

# 10. Docker 网络通信

Docker 允许通过外部访问容器、容器互联的方式来提供网络服务

## 10.1. 外部访问容器

使用 `-P` 标记时，Docker 会随机映射一个本地端口到内部容器的端口。让外部也可以访问容器应用

`-P` 标记支持的格式 `ip:hostPort:containerPort` 、`ip::containerPort` 、 `hostPort:containerPort

**注：** 在一个指定端口上只可以绑定一个容器

容器有自己的内部网络和 ip 地址（使用 `docker inspect` 查看，Docker 还可以有一个可变的网络配置。）

 `-p` 标记可以多次使用来绑定多个端口
 
```
$ docker run -d \
-p 80:80 \
-p 443:443 \
nginx:alpine
```

## 10.2. 容器互联

强烈建议将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 `--link` 参数。如：要想从 Web 容器访问 Redis 容器，我们只需要把他们放到同个网络中就可以了

**新建网络**

`docker network create -d bridge my-net`，`-d` 参数指定 Docker 网络类型，有 `bridge` 、`overlay`

**连接容器**

运行一个容器并连接到新建的 `my-net` 网络，打开新的终端，再运行一个容器并加入到 `my-net` 网络。通过 `ping` 来证明容器与容器间建立了互联关系

**查看网络列表**

`docker network ls` 

## 10.3. 配置 DNS

配置全部容器的 DNS ，也可以在 `/etc/docker/daemon.json` 文件中增加以下内容来设置。
```json
{
  "dns" : [
    "114.114.114.114",
    "8.8.8.8"
  ]
}
```

这样每次启动的容器 DNS 自动配置为 `114.114.114.114` 和 `8.8.8.8`

# 11. Docker Compose（重点）

## 11.1. 简介

Docker Compose 负责实现对 Docker 容器集群的快速编排，可以把项目的多个服务集合到一起，一键运行。

如：要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。

Docker Compose 恰好满足了这样的需求。它允许用户通过一个单独的 `docker-compose.yml` 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）

Docker Compose 中有两个重要的概念：

-   服务 (`service`)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。

-   项目 (`project`)：由一组关联的应用容器组成的一个完整业务单元，在 `docker-compose.yml` 文件中定义。

Docker Compose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。

目前 Docker 官方用 GO 语言重写了 Docker Compose，并将其作为了 docker cli 的子命令，称为 `Compose V2`。

## 11.2. 安装与卸载

在 Linux 64 位系统上直接下载对应的二进制包

```
$ sudo curl -L https://github.com/docker/compose/releases/download/1.27.4/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose

# 国内用户可以使用以下方式加快下载
$ sudo curl -L https://download.fastgit.org/docker/compose/releases/download/1.27.4/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose

$ sudo chmod +x /usr/local/bin/docker-compose
```

运行`docker-compose --version`检查是否安装成功

卸载：如果是二进制包方式安装的，删除二进制文件即可。

```
$ sudo rm /usr/local/bin/docker-compose
```

## 11.3. 使用

**术语**

-   服务 (`service`)：一个应用容器，实际上可以运行多个相同镜像的实例。

-   项目 (`project`)：由一组关联的应用容器组成的一个完整业务单元。

**场景**

最常见的项目是 web 网站

## 11.4. 命令说明

对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响

## 11.5. Compose 模板文件

默认的模板文件名称为 `docker-compose.yml`，格式为 YAML 格式

参考文档：https://docs.docker.com/compose/

```
version: "3.7"

services:
  app:
    build: ./
    ports:
      - 80:8080
    volumes:
      - ./:/app
    environment:
      - TZ=Asia/Shanghai
  redis:
    image: redis:5.0.13
    volumes:
      - redis:/data
    environment:
      - TZ=Asia/Shanghai

volumes:
  redis:
```

> 容器默认时间不是北京时间，增加 TZ=Asia/Shanghai 可以改为北京时间

## 11.6. 跑起来

在`docker-compose.yml` 文件所在目录，执行：`docker-compose up`就可以跑起来了。
命令参考：https://docs.docker.com/compose/reference/up/

在后台运行只需要加一个 -d 参数`docker-compose up -d`
查看运行状态：`docker-compose ps`
停止运行：`docker-compose stop`
重启：`docker-compose restart`
重启单个服务：`docker-compose restart service-name`
进入容器命令行：`docker-compose exec service-name sh`
查看容器运行log：`docker-compose logs [service-name]`

# 12. Kubernetes - 开源容器编排引擎

让用户透过 `Kubernetes` 集群来进行云端容器集群的管理，而无需用户进行复杂的设置工作。系统会自动选取合适的工作节点来执行具体的容器集群调度处理工作。

# 13. Docker、Docker Compose和Kubernetes


Docker是容器技术的基础，Docker Compose是用于管理多个Docker容器的工具，而Kubernetes是用于管理大规模容器集群的容器编排平台。Kubernetes可以自动化地管理容器的生命周期、水平扩展、服务发现和负载均衡等，提供了更强大的容器编排和管理能力。

在实际应用中，通常会使用Docker来创建和运行容器，使用Docker Compose来管理多个相关的容器，而使用Kubernetes来管理大规模的容器集群，实现容器的自动化部署和管理。


# 14. 实战

## 14.1. 部署flask

只涉及一个容器不需要使用Docker Compose

在服务器中创建一个code目录

从GitHub上克隆项目到code目录

打开项目文件夹，在该目录下创建文本文件 dockerfile，内容如下
```txt
# 指定基础镜像
FROM python:3.8.10
# 设置工作目录
WORKDIR /app
# 将项目下的requirements.txt文件复制到 /app目录
COPY ./requirements.txt .
# 执行命令pip install --no-cache-dir -r requirements.txt 安装项目依赖
RUN pip install --no-cache-dir -r requirements.txt
# 将Flask 项目复制到容器中的 /app 目录
COPY . .
# 容器向外暴露5000端口
EXPOSE 5000
# 在容器启动时运行 app.py 脚本
CMD [ "python", "app.py" ]
```

在dockerfile所在目录下，使用命令`docker build -t webshell_ids .`构建镜像

到此镜像定制完毕，之后运行该镜像即可启动项目

## 14.2. 部署vue/SpringBoot/MySQL

要在Ubuntu 18上部署Vue.js、Spring Boot和MySQL，可以使用Docker来容器化这些应用程序，并使用Docker Compose来管理它们

打包后端jar包
构建后端镜像

打包前端vue
构建前端镜像

下载MySQL镜像
构建MySQL容器

下载nginx镜像
构建nginx容器