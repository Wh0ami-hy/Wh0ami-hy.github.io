---
layout: post   	
catalog: true 	
tags:
    - Spring
---

# Spring

## 简介

Spring 的设计思路，**永远都是作为 Bean 的容器，去管理好 Bean** ，这是它永恒不变的地方。

官网：https://spring.io/projects/spring-framework#overview

## 两大特性

**IOC 控制反转**

**AOP**

## 事务

支持事务的处理，对框架整合的支持

# IOC思想

从前对象的创建与对象间的依赖关系完全写死在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方使用者

测试代码的逻辑：

1. UserServiceImpl调用 UserMapper（接口）

2. UserMapper（接口）有两种实现UserMapperMysqlImpl()和UserMapperOracleImpl()

即在service层使用了set注入后，程序不再具有主动性，而是变成了被动的接受对象

```java
public class UserServiceImpl implements UserService {

    private UserMapper userMapper;

    //利川set进行动态实现值的注入!
    public void setUserMapper(UserMapper userMapper) {
        this.userMapper = userMapper;
    }

    public void getUser() {
        userMapper.getUser();
    }
}
```

在main方法中调用时，由使用者决定传入的对象

```java
    public static void main(String[] args) {
        UserServiceImpl userService = new UserServiceImpl();
        // 实现反转
        userService.setUserMapper(new UserMapperOracleImpl());
        或
        userService.setUserMapper(new UserMapperMysqlImpl());
        //
        userService.getUser();
    }
```

# 搭建Spring

用IDEA创建Spring项目

在src/main/resources目录下新建 applicationContext.xml 配置文件

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-4.3.xsd">
    <!--相当于new了一个 UserMapperMysqlImpl -->
    <bean id="mysqlImpl" class="com.hy.mapper.UserMapperMysqlImpl"/>
    <bean id="oracle" class="com.hy.mapper.UserMapperOracleImpl"/>
    <!--
    ref：引用类型数据的注入
    value：基本数据类型数据的注入
    -->
    <bean id="UserServiceImpl" class="com.hy.service.UserServiceImpl">
        <property name="userMapper" ref="mysqlImpl"/>
    </bean>
</beans>
```

在main方法中，使用 ClassPathXmlApplicationContext("applicationContext.xml")获取Spring容器

```java
    public static void main(String[] args) {
        // 获取ApplicationContext，拿到Spring的容器
        ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");

        UserServiceImpl userServiceImpl = (UserServiceImpl) context.getBean("UserServiceImpl");

        userServiceImpl.getUser();
    }
```

## Spring中IOC的实现

控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式

在Spring中实现控制反转的是IOC容器，其实现方法是依赖注入（Dependency Injection，DI）

从代码上讲：一个Spring容器就是某个实现了ApplicationContext接口的类的实例

控制：使用Spring后，对象是由Spring来创建的

反转：程序本身不创建对象，而变成被动的接收对象

依赖注入：就是利用set方法来进行注入的

IOC是一种编程思想，由主动的编程变成被动的接收

可以通过new ClassPathXmlApplicationContext去浏览一下底层源码

要实现不同的操作，只需要在xmI配置文件中进行修改

## Spring配置说明

```xml
<import resource="引入其他bean xml配置文件" />
<bean id="bean标识" class="类型名称"/>
    id : bean的唯一标识符，也就是相当于对象名
    class : bean 对象所对应的全限定名，即包名+类型
    name :是别名，而且name可以同时取多个别名
    <property name="userMapper" ref="mysqlImpl"/>
        ref：引用类型数据的注入
        value：基本数据类型数据的注入
<alias name="bean标识" alias="别名" />
```

可以有多个xml文件，但是只能有一个被命名为applicationContext.xml，可以在applicationContext.xml中import导入其他xml文件

# IOC创建对象方式

默认使用无参构造

有参构造

1. 下标赋值

```xml
<bean id="user" class="com.hy.entity.User">
    <constructor-arg index="0" value="我是参数1"/>
    <constructor-arg index="1" value="我是参数2"/>
</bean>
```

2. 通过类型创建

```xml
<!--不建议使用-->
<bean id="user" class="com.hy.entity.User">
    <constructor-arg type="int" value="7500000"/>
    <constructor-arg type="java.lang.String" value="42"/>
</bean>
```

3. 直接使用参数名设置

```xml
<!--推荐使用-->
<bean id="user" class="com.hy.entity.User">
    <constructor-arg name="name" value="我是名字"/>
    <constructor-arg name="age" value="42"/>
</bean>
```

注意：在 xml中配置Bean的时候，容器中管理的对象就已经初始化了

# 依赖注入

依赖：bean对象的创建依赖于容器（IOC容器）

注入：就是让属性有值

## 构造器注入

通过无参、有参构造方法实现注入

## Set方式注入（重点）

由容器来注入

```xml
    <!--
    ref：引用类型数据的注入
    value：基本数据类型数据的注入
    -->
<bean id="user" class="com.hy.entity.User">
    <!--基本数据类型的注入-->
    <property name="name" value="我是名字"/>
    <!--引用数据类型的注入-->
    <property name="student" ref="student"/>
    <!--数组的注入-->
    <property name="books">
        <array>
            <value>三国演义</value>
            <value>红楼梦</value>
        </array>
    </property>
    <!--List的注入-->
    <property name="friends">
        <list>
            <value>张三</value>
            <value>赵四</value>
        </list>
    </property>
    <!--Map的注入-->
    <property name="card">
        <map>
            <entry key="身份证" value="213654456" />
            <entry key="学生证" value="2454545454" />
        </map>
    </property>
    <!--Set的注入-->
    <property name="games">
        <set>
            <value>LOL</value>
            <value>CF</value>
            <value>PUBG</value>
        </set>
    </property>
    <!--null的注入-->
    <property name="couple">
        <null/>
    </property>
    <!--Properties的注入-->
    <property name="info">
        <props>
            <prop key="username">admin</prop>
            <prop key="password">123456</prop>
        </props>
    </property>
</bean>    
```

## 拓展方式注入

c命名和p命名空间注入

```xml
beans中需要引入xml约束
<beans 
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:c="http://www.springframework.org/schema/c"
       >
```

c（constructor）命名，原理是通过构造器注入

```xml
<bean id="user" class="com.hy.entity.User" c:age="18" c:name="名字">
```

p（property）命名，原理是通过set注入

```xml
<bean id="user" class="com.hy.entity.User" p:age="18" c:name="名字">
```

## Bean的作用域

单例模式：Spring默认机制，每次从容器中get的时候，共享同一个对象

```xml
<!--scope-->
<bean id="UserServiceImpl" class="com.hy.service.UserServiceImpl" scope="singleton">
```

原型模式：每次从容器中get的时候，都会产生一个新对象

```xml
<!--scope-->
<bean id="UserServiceImpl" class="com.hy.service.UserServiceImpl" scope="prototype">
```

其余的request、session、application这些作用域只能在web开发中使用

# Bean的自动装配

Spring会在上下文中自动寻找，并自动给bean装配属性

在Spring中有三种装配的方式

1. 在xml中显式配置
2. 在java中显式配置
3. 隐式的自动装配bean（重要）

## autowire 隐式的自动装配bean

```xml
<!--
autowire="byType"  会自动在容器上下文中查找和自己对象属性类型相同的bean
autowire="byName"  会自动在容器上下文中查找和自己对象set方法后面的值对应的bean id
-->
<bean id="user" class="com.hy.entity.User" autowire="byName">
```

总结：

byName的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致

byType的时候，需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致

## @Autowired 注解实现自动装配

导入约束

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>

</beans>
```

直接在属性上使用即可，也可以在set方法上使用

使用 @Autowired 后可以不用编写Set方法了，前提是你这个自动装配的属性在IOC容器中存在，且名字符合byName的规范

补充：

如果显式定义了Autowired的required属性为false，说明这个对象可以为null，否则不允许为空

```java
@Autowired(required = false)
```

如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解@Autowired完成的时候，我们可以使用@Qualifier(value="xx" )来配合@Autowired的使用

```java
@Autowired()
@Qualifier(value="student1")
private Student student;
```

Java自带 @Resource注解也可实现自动装配

@Resource和@ Autowired的区别：

1. 都是用来自动装配的，都可以放在属性字段上
2. @Autowired通过byName的方式实现
3. @Resource默认通过byName的方式实现，如果找不到名字，则通过byType实现

# 使用注解开发

一般在注入内容较为简单时，可使用注解直接进行开发，当注入内容比较复杂，如map、list等时，仍然使用xml配置文件开发

在xml配置文件中开启自动扫描注解

```xml
<!--指定要扫描的包，这个包下的注解就会生效-->
<context:component-scan base-package="com.hy.entity"/>
<!--开启注解功能-->
<context:annotation-config/>
```

## @Component

注册该组件到Spring IOC容器中

```java
@Component
public class Student {
    ...
        ...
}
```

相当于

```xml
<bean id="student" class="com.hy.entity.Student">
</bean>
```

属性注入 @Value

```java
@Component
public class Student {
    @Value("我是学生")
    private name;
        ...
}
```

相当于property

```xml
<bean id="student" class="com.hy.entity.Student">
    <property name="name" value="我是学生"/>
</bean>
```

**@Component衍生的注解**

以下注解功能一致，只是命名不同

在web开发中，按照MVC三层架构分层

1. DAO（Mapper）@Repository
2. service  @Service
3. controller  @Controller

## @Scope

作用域，相当于

```xml
<bean id="user" class="com.hy.service.User" scope="prototype">
```



**xml与注解最佳实践**

xml用来管理bean

注解只负责完成属性的注入

# JavaConfig 实现配置

不使用xml来配置，由Java全权实现配置功能即配置类

在配置类中

```java
@Configuration	// @Configuration代表这是一个配置类
@ComponentScan("com.hy.entity")	// 扫描包下的注解
public class UserConfig {
    @Bean	// 注册一个bean，相当于 xml文件中的bean标签
    public Student student(){	//方法名相当于bean标签中的id属性
        return new Student();	//方法的返回值相当于bean标签中的class属性
    }
}
```

在main方法中使用  AnnotationConfig 获取容器，通过配置类的class对象加载

```java
    public static void main(String[] args) {
        // 获取ApplicationContext，拿到Spring的容器
        ApplicationContext context = new AnnotationConfigApplicationContext(UserConfig.class);

        Student student = (Student) context.getBean("student");
        System.out.println(student.getName());
    }
```































