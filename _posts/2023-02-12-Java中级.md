---
layout: post   	
catalog: true 	
tags:
    - Java
---



## 异常类

### 异常分类

```
编译时异常(受检异常)，必须显示处理

运行时异常(非受检异常)，所有的RuntimeException类及其子类被称为运行时异常，无须显示处理，修改错误代码即可

错误ERROR，错误不是异常, 而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了,它们在编译也检查不到的。
```

### 异常体系结构

Java把异常当作对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类

```mermaid
graph LR
Throwable--> A(Error)
A-->VirtulMachineError
A-->AWTError
Throwable--> B(Exception)
B-->IOException
B-->RuntimeException

```

**Error**

```
Error类对象由Java,虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关，如栈溢出

Error通常是灾难性的致命的错误，是程序无法控制和处理的，Java虚拟机(JVM) 一般会选择终止线程
```

**Exception**

```
RuntimeException
在编译期是不检测的，需要修改代码

非RuntimeException
编译器就必须处理，否则编译不能通过
```

**Throwable的成员方法**

| 方法名                        | 说明                            |
| ----------------------------- | ------------------------------- |
| public String getMessage()    | 返回此throwable的详细消息字符串 |
| public String toString()      | 返回此可抛出的简短描述          |
| public void printStackTrace() | 把异常的错误信息输出在控制台    |

```java
try{
      test(1,2,5);
      System.out.println("end");
    }catch( AnswerWrongException e){
        e.printStackTrace();
    }
```

### 异常处理

```java
class Family{
    int a = 1;
    int b = 0;
}
public  class demo {
    public static void main(String[] args) {
        Family f1 = new Family();
        // try监控区
        try {
            System.out.println(f1.a / f1.b);
        }catch (ArithmeticException e){ // catch捕获异常
            System.out.println(e);
        }finally { //处理善后工作
            System.out.println("family");
        }
    }
}
```

**捕获异常**

**try-catch**

程序从try中执行代码，出现异常，自动生成一个异常类对象，该异常对象将被提交给Java运行时的系统

当Java运行时系统接收到异常对象时，会到catch中去找匹配的异常类，找到后进行异常的处理

执行完毕后，程序会继续往下执行

```java
try{
    可能出现异常的程序
}catch(异常类型   异常对象){	//指定可能出现的异常类型
    异常处理的代码
}
```

如果要捕获多个异常，则异常类型 要从小到大

```java
try{
    可能出现异常的程序
}catch(Exception e1){
    异常处理的代码
}catch(Throwable e2){
    异常处理的代码
}
```

**finally语句**

可省略，不管是否会出现异常，finally都会执行，通常用于进行资源清除、关闭打开的文件等最后进行的处理

```java
try{ 
    java语句
}catch(异常类型1   异常对象1){    
    异常处理                       
}finally{ 
}
```

**抛出异常**

**throw**

由程序本身主动抛出类异常对象，并对此异常进行处理

```java
throw 异常类对象 (必须为Throwable子类对象)
```

例

```java
public class work {
    public static void main(String[] args) {
        int a=5,b=0;
        try{
        	if(b==0)
        	    throw new ArithmeticException();		//
        	else
        	    System.out.println(a/b);
        }
        catch(ArithmeticException e){
        	System.out.println("除数不能为零！");
        	e.printStackTrace();   //显示异常信息
        }
    }
}
```

**throws**

写在可能出现异常的方法声明之后，throws可以列出多个可能出现的系统异常，用逗号分隔。声明该方法可能会出现异常

```java
throws 异常类名;
```

例子

```java
public class TestThrows{
	public static void main(String[] args){
		try{
			test();
		}
		catch(Exception e)
		{
			System.out.println(e.getMessage());	
		}		
	}
	static void test() throws ArithmeticException{		//
		System.out.println(6/0);
	}
}
```

**throw和throws区别**

| throws                                           | throw                              |
| ------------------------------------------------ | ---------------------------------- |
| 用在方法声明后面，跟的是异常类名                 | 用在方法体内，跟的是异常对象名     |
| 表示抛出异常，由该方法的调用者来处理             | 表示抛出异常，由方法体内的语句处理 |
| 表示出现异常的一种可能性，并不一定会发生这些异常 | 执行throw一定抛出了某种异常        |

注意

```
编译时异常必须进行处理，可用try-catch或throws，若使用throws，将来谁调用谁处理
运行时异常可以不处理，出问题后修改代码 
```

### 自定义异常

自定义异常类只需要继承Exception类即可，并规定哪些方法产生这样异常

使用自定义的异常类创建对象，并抛出所创建的异常对象

```Java
public class 异常类名 extends Exception{
    无参构造
    带参构造
}
```

例

```java
import java.util.Scanner;

class ScoreException extends Exception{
    public ScoreException(){}

    public ScoreException(String message){
        super(message);
    }
}


class Check {
    public void checkScore(int score) throws ScoreException{
        if(score<0 || score>100){
            //throw new ScoreException();
            throw new ScoreException("分数异常，分数超范围");

        }else {
            System.out.println("分数正常");
        }
    }
}

class ScanScore{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入分数");
        int score = sc.nextInt();

        Check t = new Check();
        try {
            t.checkScore(score);
        } catch (ScoreException e) {
            e.printStackTrace();
        }
    }
}
```

### 常见异常类

```
IOException：输入输出异常
ArithmeticException：数学异常
NullPointerException：空指针异常
ArrayIndexOutOfBoundsException：下标越界异常
ClassCastException：类型转换异常:
```

## 泛型

避免项目之中出现“ClassCastException”

```
本质是将所操作的数据类型指定为一个参数

这种参数可用在类、方法、接口中，分别被称为泛型类、泛型方法、泛型接口

<类型1,类型2> ：可指定多种类型的格式，多种类型之间用逗号隔开，这里的类型可以看作是形参

调用的时候，给定的类型可以看作实参，并且实参的类型只能是引用数据类型，如果要操作基本类型必须使用相应的包装类，如果不设置泛型类型时，自动将使用Object
```

**优点**

把运行时期的问题提前到了编译期间

避免了强制类型转换

同时也避免了对象的向下转型处理（可以避免安全隐患）

### 泛型类

```Java
修饰符 class 类名<参数>{ //此处参数可以随便写为任意标识，常见如T、E、K、V等形式的参数常用于表示泛型
    
}
例
public class Demo<T>{
    private T param;
    public void show(T t){
    }
}
// 实例化时，传入具体数据类型
Demo<String> s1 = new Demo<String>();
```

### 泛型方法

注意：如果一个类上没有定义泛型，那么也可以使用泛型方法

```java
修饰符 <参数> 返回值类型 方法名(参数 变量名){//此处参数可以随便写为任意标识，常见如T、E、K、V等形式的参数常用于表示泛型
}
例
public <T> void show(T t){}
```

例

```java
class Generic{
    public <T> void show(T t){
        System.out.println(t);
    }
}
public class test {
    public static void main(String[] args) {
        Generic g1 = new Generic();		//
        g1.show(2);
        Generic g2 = new Generic();		//
        g2.show("字符串");
    }
}
```



### 泛型接口

直接在接口之中进行使用

```java
interface Generic<T>{
    void show(T t);
}
```

对于泛型接口的子类而言现在就有两种实现方式

方法一：在子类之中继续设置泛型定义

```java
class GenericImpl<S>implements Generic<S> {
    @Override
    public void show(S s){
        System.out.println(s);
    }
}
```

方法二：在子类实现父接口的时候直接定义出具体泛型类型

```java
class GenericImpl implements Generic<String> {
    @Override
    public void show(String s){
        System.out.println(s);
    }
}
```

### 泛型通配符

**泛型上限**

`<?extends 类>`

```java
?extends Number: 表示该泛型类型只允许设置Number或Number的子类
```

**泛型下限**

`<?super 类>`

```java
<?super Number>：它表示的类型是Number或其父类型
```

## Lambda表达式

替换只有一个抽象方法的匿名内部类

对于Lambda表达式而言，提供有如下几种格式

```
方法没有参数: ()->{}
方法有参数: (参数,参数)->{}
如果现在只有一行语句返回: (参数,参数)->语句
```

## File类文件操作 

File类是唯一与文件本身操作（创建、删除、重命名等）有关的类

File类是Comparable接口的子类，所以File类的对象可以进行排序

如果想进行File 类的操作，必须提供完整的路径，主要通过File类的构造方法处理

### 构造方法

以下三种方法，效果一样，推荐用第一种

| 方法名                           | 说明                                             |
| -------------------------------- | ------------------------------------------------ |
| File(String pathname)            | 创建新的File实例                                 |
| File(String parent,String child) | 从父路径名字符串和子路径名字符串创建新的File实例 |
| File(File parent,String child )  | 从父抽象路径名和子路径名字符串创建新的File实例   |

### 创建功能

进行文件创建的时候有一个重要的前提：文件的父路径必须首先存在

| 方法名                         | 说明                              |
| ------------------------------ | --------------------------------- |
| public boolean createNewFile() | 创建新空文件。若文件存在返回false |
| public boolean mkdir()         | 创建单级目录。若目录存在返回false |
| public boolean mkdirs()        | 创建多级目录。若目录存在返回false |

### 删除功能

| 方法名                  | 说明           |
| ----------------------- | -------------- |
| public boolean delete() | 删除文件或目录 |

注意：如果一个目录中有内容（子目录或文件），则不能直接删除该目录，需要先删除目录中的内容，才能删除该目录

### 获取文件信息

| 方法名                          | 说明                           |
| ------------------------------- | ------------------------------ |
| renameTo(File)                  | 文件重命名                     |
| public boolean isDirectory()    | 是否为目录                     |
| public boolean isFile()         | 是否为文件                     |
| public boolean exists()         | 是否存在文件、目录             |
| public boolean canRead()        | 文件是否可读                   |
| public boolean canWrite()       | 文件是否可写                   |
| public long length()            | 获取文件长度，返回字节长度     |
| public long lastModified()      | 获取最后一次修改日期时间       |
| public String getAbsolutePath() | 获取绝对路径                   |
| public String getPath()         | 获取相对路径                   |
| public String getName()         | 获取文件或目录的名称           |
| public File getParentFile()     | 获取父路径                     |
| public File[] listFiles()       | 列出目录内容，返回File对象数组 |
| public String[] list()          | 列出目录内容，返回字符串数组   |

```java
public  class demo {
    public static void main(String[] args) throws Exception{
        	// 创建一个File实例
        File f1 = new File("d://test//test1//demo1.txt");
        //父路径是否存在
        if (!f1.getParentFile().exists()){  
            // 创建父路径
            f1.getParentFile().mkdirs();  
            //创建文件
            f1.createNewFile();     
        }
        if (f1.exists()){
            // 删除文件
            f1.delete();
        }
    }
}
```

### 文件遍历

最好的做法就是利用递归的形式来完成

```java
public static void listDir(File file){
    // 判断是否为目录
    if (file.isDirectory()){
        File[] files = file.listFiles();
        for(int x=0;x<files.length;x++){
            //递归调用
            listDir(files[x]);  
        }
    }
    System.out.println(file);
}
```

## IO流

流的本质是数据传输。

常见的流：文件复制、文件上传、文件下载

### 分类

默认按数据类型来分类

**按数据流向**

输入流

输出流

**按数据类型**

字节流

字符流

### 使用

要读写的内容，可直接使用记事本打开，则使用字符流

否则使用字节流

## 字节流

### 字节流抽象基类

InputStream

这个抽象类是表示字节输入流的所有类的超类

OutputStream

这个抽象类是表示字节输出流的所有类的超类

子类名特点

子类名都是以其父类名作为子类名的后缀

### 写数据

创建字节输出流对象

```java
FileOutputStream fos = new FileOutputStream(String pathname)
    
/*说明

调用系统功能创建了文件
创建了字节输出流对象
让字节输出流对像指向创建好的文件
*/
```

写入数据

| 方法                                 | 说明                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| void write(int b)                    | 将指定的字节写入此文件输出流，一次写入一个字节               |
| void write(byte[] b)                 | 将多个字节从指定的字节数组写入此文件输出流，一次写入一个字节数组 |
| void write(byte[] b,int off,int len) | 将len字节从指定的字节数组开始，从偏移量off开始写入，一次写入一个字节数组的部分数据 |

```java
fos.write()			// 用write方法写入数据
```

关闭资源

```java
fos.close()			//关闭文件资源
```

获取字符串的字节数组

```java
String str = "abcdfsdf";
str.getBytes();
```

实现换行

```java
fos.write("\r\n".getBytes())	//Windows下
```

追加写入

```java
FileOutputStream fos = new FileOutputStream(String pathname,true)		//增加一个Boolean类型的参数
```



例子

```java
import java.io.*;
import java.nio.charset.StandardCharsets;


public class test {


    public static void main(String[] args) throws IOException {

        String str = "dtfwsdfasdfas";

        byte[] bys = {98,55,66,88,89};

        FileOutputStream fos = new FileOutputStream("C:\\Users\\houyi\\Desktop\\test\\1.txt",true);

        fos.write(bys);
        fos.write("\r\n".getBytes());
        fos.write(98);
        fos.close();
    }

}
```

### finally释放资源

被finally控制的语句一定会执行

```java
        try {
            fos.write(98);
        }catch (IOException e){
            e.printStackTrace();
        }finally {
            fos.close();
        }
```

### 读数据

创建字节输入流对象

```java
FileInputStream fos1 = new FileInputStream(String pathname);
```

读取数据

| 方法                | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| void read(byte b)   | 读取指定的字节，一次读取一个字节，如果文件读取到末尾，返回 -1，否则返回读取的字节的个数 |
| void read(byte[] b) | 读取指定的字节，放到一个字节数组中，如果文件读取到末尾，返回 -1，否则返回读取的字节的个数 |

```java
import java.io.*;
import java.nio.charset.StandardCharsets;


public class test {


    public static void main(String[] args) throws IOException {
        FileInputStream fos1 = new FileInputStream("C:\\Users\\houyi\\Desktop\\test\\1.txt");

        byte[] bys = new byte[1024];            //一般是1024及其整数倍
        int len;
        while ((len = fos1.read(bys)) != -1){
            System.out.print((new String(bys,0,len)));
        }

        fos1.close();
    }

}
```

关闭资源

```java
fos.close()
```



## 字符流

字符流 = 字节流 + 编码表

### 汉字的处理

因为汉字的存储是有编码的，GBK或UTF-8等，而GBK编码占2个字节，UTF-8编码占3个字节，所以直接使用字节流读取，会导致无法读取到完整的汉字。

在用字节流复制文本文件时，文本文件中有中文，那么是如何识别中文的？

```
汉字在存储时，无论何种编码方式，第一个字节都是负数，所以可以识别汉字
```

### 编码和解码

**编码**

```
byte[] getBytes() 使用平台默认的字符集将该String编码为一系列字节，结果存储到新的字节数组中

byte[] getByte(String charsetName) 使用指定的字符集将该String编码为一系列字节，结果存储到新的字节数组中

```

例

```java
public class test {


    public static void main(String[] args) throws IOException {

        String s = "中国";

        byte[] bys1 = s.getBytes("GBK");
        byte[] bys2 = s.getBytes("UTF-8");

        System.out.println(Arrays.toString(bys1));
        System.out.println(Arrays.toString(bys2));
    }

}
```

**解码**

```
String(byte[] bytes) 使用平台默认的字符集将字节数组解码为String
String(byte[] bytes,String charsetName) 使用指定的字符集将字节数组解码为String
```

例

```java
public class test {


    public static void main(String[] args) throws IOException {

        String s = "中国";

        byte[] bys1 = s.getBytes("GBK");
        byte[] bys2 = s.getBytes("UTF-8");

        System.out.println(Arrays.toString(bys1));
        System.out.println(Arrays.toString(bys2));

        String ss1 = new String(bys1,"GBK");
        System.out.println(ss1);

        String ss2 = new String(bys2,"UTF-8");
        System.out.println(ss2);

    }

}
```

### 字符流抽象基类

Reader

字符输入流的抽象类

Writer

字符输出流的抽象类

FileWriter是Writer的子类

FileReader是Reader的子类

InputStreamReader

读取字节，使用指定的编码将其解码为字符

```java
public class test {

    public static void main(String[] args) throws IOException {

        InputStreamReader isr = new InputStreamReader(new FileInputStream("C:\\Users\\houyi\\Desktop\\test\\2.txt"),"UTF-8");

        int ch;
        while((ch = isr.read()) != -1){
            System.out.print((char)ch);;
        }

        isr.close();
    }
}
```



OutputStreamWriter

使用指定的编码将写入的字符编码为字节

```java
public class test {


    public static void main(String[] args) throws IOException {

        String s = "中国";
        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("C:\\Users\\houyi\\Desktop\\test\\2.txt"),"UTF-8");

        osw.write("中国");

        osw.close();
        
    }

}
```

### 写数据

| 方法名                                  | 说明                                           |
| --------------------------------------- | ---------------------------------------------- |
| void write(int c)                       | 写一个字符                                     |
| void write(char[] cbuf)                 | 写入一个字符数组                               |
| void write(char[] cbuf,int off,int len) | 写入字符数组的一部分                           |
| void write(String str)                  | 写一个字符串                                   |
| void write(String str,int off,int len)  | 写一个字符串的一部分                           |
| void flush()                            | 刷新流的缓冲，写入一个字符，必须刷新，才能写入 |
| void close()                            | 关闭资源并刷新流                               |

例

```java
public class test {

    public static void main(String[] args) throws IOException {

        String s = "中国";
        char[] ch = {'a','d','c'};
        
        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("C:\\Users\\houyi\\Desktop\\test\\2.txt"));

        osw.write(98);
        osw.write(s);
        osw.write(ch);
        osw.flush();
        osw.close();
    }
}
```

### 读数据

| 方法名                | 说明                   |
| --------------------- | ---------------------- |
| int read()            | 一次读一个字符数据     |
| int read(char[] cbuf) | 一次读一个字符数组数据 |

例

```java
public class test {

    public static void main(String[] args) throws IOException {


        InputStreamReader isr = new InputStreamReader(new FileInputStream("C:\\Users\\houyi\\Desktop\\test\\2.txt"));
        int ch;

        char[] chs = new char[1024];
        int len;
        
       while((ch = isr.read()) != -1){		//
           System.out.print((char)ch);
        }

        while((len = isr.read(chs)) != -1){		//
            System.out.print(new String(chs,0,len));
        }
        isr.close();
    }
}
```



## 缓冲流

### 字节缓冲流

字节缓冲流仅仅提供缓冲区，真正的读写数据还得依靠基本的字节流对象操作

BufferedInputStream(OutputStream out)

创建一个内部缓冲区数组，当从流中读取或跳过字节时，内部缓冲区将根据需要从所包含的输入流中重新填充，一次很多字节

BufferedOutputStream(InputStream in)

程序可向底层输出流写入字节，不必为写入的每个字节导致底层系统的调用

例

```java
public class test {

    public static void main(String[] args) throws IOException {

        BufferedInputStream bos = new BufferedInputStream(new FileInputStream("C:\\Users\\houyi\\Desktop\\test\\2.txt"));

        int b;
        while ((b=bos.read()) != -1){
            System.out.print((char)b);
        }
    }
}
```



### 字符缓冲流

BufferedReader(Writer out)

从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可指定缓冲区大小，或使用默认大小，默认值足够大

BufferedWriter(Reader in)

将文本写入字符输出流，缓冲字符，以提供单个字符，数组和行的高效读取，可指定缓冲区大小，或使用默认大小，默认值足够大

例

```java
public class test {


    public static void main(String[] args) throws IOException {

        BufferedReader ss = new BufferedReader(new FileReader("C:\\Users\\houyi\\Desktop\\test\\2.txt"));

       int len;
       while((len = ss.read()) != -1){
           System.out.print((char)len);
       }
    }
}
```

字符缓冲流的特有功能

添加换行

```
BufferedWriter: void newLine() 
写一个行分隔符，行分隔符字符串由系统属性定义，如Windows中是\r\n，Linux是 \n
如
```

如

```java
class work {
    public static void main(String[] args) throws IOException {

        BufferedWriter   bw = new BufferedWriter(new FileWriter("C:\\Users\\houyi\\Desktop\\test\\1.txt"));

        for(int i = 0;i<10;i++){
            bw.write("hello" + i);
            bw.newLine();
        }
        bw.close();
    }
}
```



读取行字符

```
BufferedReader: public String readLine() 
读一行文字，结果包含行的内容的字符串，不包括任何终止字符(即不包含换行符)，如果流的结尾已经到达，则为null
```

如

```java
class work {
    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new FileReader("C:\\Users\\houyi\\Desktop\\test\\1.txt"));

        String line;
        while ((line = br.readLine()) != null) {
            System.out.println(line + "\n");
        }

        br.close();
    }
}
```



## IO流总结

字节流可以复制任意文件数据，有4种方式，一般采用字节缓冲流一次读写一个字节数组的方式

字符流只能复制文本数据，共5种方式，一般采用字符缓冲流的特有功能



## 特殊操作流

### 标准输入、输出流

是System类中的静态成员变量

对应于键盘输入或其他指定的输入源

```java
public static final InputStream in
    
    
如
class work {
    public static void main(String[] args) throws IOException {
        InputStream is = System.in;

        int by;
        while ((by=is.read())!=-1){
            System.out.print((char)by);
        }
    }
}
```

对应于显示输出或其他指定的输出源

```java
public static final PrintStream out
    
如
class work {
    public static void main(String[] args) throws IOException {
        PrintStream pr = System.out;
        pr.println();
        pr.print("abc");

    }

}

```



### 打印流

只负责输出数据，不读取数据

**字节打印流**

构造方法

```java
PrintStream ps = new PrintStream("路径");
```

使用继承父类的方法`write()`写数据，会转码。使用自己特有的方法`print() println()`写数据，不转码

```java
class work {
    public static void main(String[] args) throws IOException {
        PrintStream pr = new PrintStream("C:\\Users\\houyi\\Desktop\\test\\1.txt");
        pr.println(97);     //不转码
        pr.write(97);       //转码 为 a
        

    }
}
```



**字符打印流**

构造方法

| 方法名                                    | 说明                                                         |
| ----------------------------------------- | ------------------------------------------------------------ |
| PrintWriter(String filename)              | 使用指定的文件名创建一个新的PrintWriter，而不需要自动执行刷新 |
| PrintWriter(Writer out,boolean autoFlush) | 创建一个新的PrintWriter。out：字符输出流。autoFlush：一个布尔值，如果为真，则print、println或format方法将刷新输出缓冲区 |

第一个构造方法

```java
class work {
    public static void main(String[] args) throws IOException {
        PrintWriter pw = new PrintWriter("C:\\Users\\houyi\\Desktop\\test\\1.txt");

        pw.write("asd");
        pw.println("123")
        pw.flush();

    }
}
```

第二个构造方法

```java
class work {
    public static void main(String[] args) throws IOException {
        PrintWriter pw = new PrintWriter(new FileWriter("C:\\Users\\houyi\\Desktop\\test\\1.txt"),true);

        pw.write("asd");
        pw.println("123");

    }
}
```



### 对象序列化流

对象序列化：就是将对象保存到磁盘中,或者在网络中传输对象

这种机制就是使用一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据和对象中存储的属性等信息

字节序列写到文件之后，相当于文件中持久保存了一个对象的信息

反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化

**对象序列化流**： ObjectOutputStream

构造方法

```java
ObjectOutputStream(OutputStream out): 创建一 个写入指定的OutputStream的ObjectOutputStream
```

序列化对象的方法

```java
void writeObject(Object obj):将指定的对象写入ObjectOutputStream
```

注意

```
一个对象要想被序列化，该对象所属的类必须实现Serializable 接口

Serializable是一个标记接口，实现该接口，不需要重写任何方法

```

**对象反序列化流**：ObjectInputStream

## 集合体系

一种存储空间可变的存储模型

### Collection(单列)

**List(可重复)**

```
ArrayList
底层用数组实现

LinkedList
底层用链表实现
```

**Set(不可重复)**

```
HashSet
底层数据结构是哈希表

TreeSet
```

### Map(双列)

HashMap

## Collection

是单列集合的顶层接口，它表示一组对象

### 创建Collection对象

多态的方式

具体的实现类ArrayList

```java
Collection<String> c = new ArrayList<String>();
```

### 方法

| 常用方法                   | 说明                             |
| -------------------------- | -------------------------------- |
| boolean add(E e)           | 添加元素                         |
| boolean remove(Object o)   | 移除指定元素                     |
| void clear()               | 清空集合中的元素                 |
| boolean contains(Object o) | 判断集合中是否存在指定的元素     |
| boolean isEmpty()          | 判断集合是否为空                 |
| int size()                 | 集合的长度，也是集合中元素的个数 |



### 遍历Collection

Iterator迭代器，集合专用的遍历方式

```
Iterator<E> iterator()返回此集合中元素的迭代器，通过集合的iterator()方法得到的
```



```java
Collection<String> c = new ArrayList<String>();
Iterator<String> it = c.iterator();
```

Iterator的常用方法

```
E next()  返回迭代中的下一个元素
boolean hasNext()  如果迭代时，还有元素未被迭代，则返回true
```



```java
class work{
    public static void main(String[] args) {

        Collection<String> c = new ArrayList<String>();
        c.add("hello");
        c.add("java");
        c.add("ja");
        
        Iterator<String> it = c.iterator();
        while (it.hasNext()){
            String s= it.next();
            System.out.println(s);
        }
    }
}
```



## List

有序集合，用户可以通过索引来增删改查元素

与Set集合不同，列表通常允许重复元素

### 创建List对象

```java
 List<String> c = new ArrayList<String>();
```

### 常用方法

Collection中的方法，List也可使用

| 特有方法                      | 说明 |
| ----------------------------- | ---- |
| void add(int index,E element) | 插入 |
| E remove(int index)           | 删除 |
| E set(int index,E element)    | 修改 |
| E get(int index)              | 查找 |

### 遍历

```java
class work{
    public static void main(String[] args) {

        List<String> c = new ArrayList<String>();
        c.add("hello");
        c.add("java");
        c.add("hello");

        for (int i = 0;i<c.size();i++ ){
            System.out.println(c.get(i));
        }
```

### 列表迭代器

ListIterator

```
通过List集合的listIterator()方法得到
允许向任一方向遍历、在迭代期间修改列表，并获取列表中迭代器的当前位置
```

方法

```
E next()  返回迭代中的下一个元素
boolean hasNext()  如果迭代时，还有元素未被迭代，则返回true
E previous() 返回列表中的上一个元素
boolean hasPrevious() 如果列表在反方向遍历时，还有元素未被迭代，则返回true
void add(E e)  插入元素
```

## LinkedList

### 创建

```java
LinkedList<String> LinkList = new LinkedList<String>();
```

### 特有功能

| 方法名                    | 说明                         |
| ------------------------- | ---------------------------- |
| public void addFirst(E e) | 在列表开头插入指定元素       |
| public void addLast(E e)  |                              |
| public E getFirst()       | 返回列表中的第一个元素       |
| public E getLast()        |                              |
| public E removeFirst()    | 从列表中删除并返回第一个元素 |
| public E removeLast()     |                              |



## ArrayList

集合，存储容量可变的存储模型

### `ArrayList<E>`

可调整大小的数组实现，使用时将E替换为集合中的数据类型即可

```java
ArrayList<String> array = new ArrayList<String>();
```



### 构造方法

| 方法                                 | 说明                       |
| ------------------------------------ | -------------------------- |
| public ArrayList()                   | 创建一个空集合对象         |
| public boolean add(E e)              | 将指定元素追加到集合的末尾 |
| public void add(int index,E element) | 在集合指定位置插入元素     |

 例

```java
public class test{
    public static void main(String[] args) {
        ArrayList<String> array = new ArrayList<String>();
        array.add("woaini");
        array.add("huake");
        array.add(1,"123");

        System.out.println(array);
    }
}
```

### 常用方法

| 方法名                            | 说明                                   |
| --------------------------------- | -------------------------------------- |
| public boolean remove(Object o)   | 删除指定元素，返回删除是否成功         |
| public E remove(int index)        | 删除指定索引处的元素，返回被删除的元素 |
| public E set(int index,E element) | 修改指定索引处的元素，返回被修改的元素 |
| public E get(int index)           | 返回指定索引处的元素                   |
| public int size()                 | 返回集合中元素的个数                   |

```java
public class test{
    public static void main(String[] args) {
        ArrayList<String> array = new ArrayList<String>();
        array.add("woaini");
        array.add("huake");
        array.add(1,"123");

        System.out.println(array);
        System.out.println(array.size());
        System.out.println(array.set(1,"test"));
        System.out.println(array.get(2));
        System.out.println(array.remove("123"));
        System.out.println(array.remove(0));
    }
}
```

### 例子

用集合存储学生对象并遍历

```java
class Student{
    // 成员变量
    private String name;
    private int age;
    //无参构造方法
    public Student(){};
    //有参构造方法
    public Student(String name,int age){
        this.name = name;
        this.age = age;
    }

    //成员方法
    public void setName(String name){
        this.name = name;
    }
    public String getName(){
        return name;
    }
    public void setAge(int age){
        this.age = age;
    }
    public int getAge(){
        return age;
    }
    public void show(){
        System.out.println(name + "," + age);
    }
}

public class test{
    public static void main(String[] args) {
        ArrayList<Student> array = new ArrayList<Student>();


        Student s1 = new Student("hou",12);
        Student s2 = new Student("den",13);
        Student s3 = new Student("zhao",14);
        array.add(s1);
        array.add(s2);
        array.add(s3);


        for(int i=0;i<array.size();i++){
            System.out.println(array.get(i));
        }
    }
}
```



## Set

方法和Collection一样

不包含重复元素

没有带索引的方法，所以不能使用for循环遍历，但可使用增强for遍历

```java
class work{
    public static void main(String[] args) {
        Set<String> ss = new HashSet<String>();
        ss.add("asd");
        ss.add("123");

        System.out.println(ss.size());
        for (String s:ss){
            System.out.println(s);
        }

    }
}
```



## 哈希值

JDK根据对象的地址或字符或数字计算出的int类型的数值

Object类的一个方法可获取哈希值

```java
public int hashCode()
```

同一对象多次调用hashCode()，返回的值相同

## HashSet

```
对集合的迭代顺序不作任何保证
没带索引的方法，不能使用for循环，只能使用增强for、迭代器进行遍历
没有重复元素
```

### 创建

```java
HashSet<String> hs = new HashSet<String>();
```

## TreeSet

元素根据构造方法排序

```
TreeSet() 根据元素的自然排序，进行排序

TreeSet(Comparator comparator) 根据指定的比较器进行排序
```

没有带索引的方法

没重复数据

### 创建

```java
TreeSet<String> ts = new TreeSet<String>();
```



### 自然排序Comparable

```
使用TreeSet集合存储自定义对象
无参构造方法使用的是自然排序，即让元素所属的类实现Comparable接口，重写compareTo(To)方法
重写方法时，需要按照排序条件的主次来写
```



```java
package Test;

import java.util.*;

class student implements Comparable<student> {
    private int age;
    private String name;
    student(){}
    student(String name,int age){
        this.age = age;
        this.name = name;
    }
    String getName(){
        return name;
    }
    int getAge(){
        return age;
    }
    public int compareTo(student s){		//按照年龄排序
        int num = this.age - s.age;
        return num;
    }
}

class work{
    public static void main(String[] args) {
     TreeSet<student> ts = new TreeSet<student>();


     student s1 = new student("xixi",50);
     student s2 = new student("zhao",12);
     student s3 = new student("dalao",60);

     ts.add(s1);
     ts.add(s2);
     ts.add(s3);

     for (student s:ts){
         System.out.println("name:" + s.getName() + "age:" + s.getAge());
        }
    }
}
```

### 比较器排序Comparable

```
使用TreeSet集合存储自定义对象
带参构造方法使用的是比较器排序，即让集合构造方法接收Comparable的实现类对象，重写compareTo(To1,To2)方法
重写方法时，需要按照排序条件的主次来写
```

## Map

```
Interface Map<K,V>  K为键的类型，V为值的类型
将键映射到值的对象
不包含重复的键，每个键最多可对应一个值
当键重复值，键的值会覆盖
```



### 创建

多态的方式

具体的实现类HashMap

```java
Map<String,String> map = new HashMap<String,String>();
```

### 方法

| 常用方法                            | 说明                             |
| ----------------------------------- | -------------------------------- |
| V put(K key,V value)                | 添加元素                         |
| V remove(Object key)                | 根据键删除键值元素               |
| void clear()                        | 移除所有键值对元素               |
| boolean containsKey(Object key)     | 判断集合是否包含指定的键         |
| boolean containsValue(Object value) | 判断集合是否包含指定的值         |
| boolean isEmpty()                   | 判断集合是否为空                 |
| int size()                          | 集合的长度，即集合中键值对的个数 |

```java
class work{
    public static void main(String[] args) {
        Map<String,String> map = new HashMap<String,String>();

        map.put("zhao","123");
        map.put("hou","456");
        System.out.println(map);     
    }
}
```

### 获取功能

| 方法名                           | 说明                   |
| -------------------------------- | ---------------------- |
| V get(Object key)                | 根据键获取值           |
| `Set<K> keySet()`                | 获取所有键的集合       |
| `Collection<V> values()`         | 获取所有集合           |
| `Set<Map.Entry<K,V>> entrySet()` | 获取所有键值对象的集合 |

### 遍历

先获取所有键的集合(使用keySet())，再遍历键的集合获取每个对应的值(使用增强for)

```java
class work{
    public static void main(String[] args) {

        Map<String,String> map = new HashMap<String,String>();

        map.put("zhao","123");
        map.put("hou","456");

        Set<String> keySet = map.keySet();
        for(String key: keySet){
            String value = map.get(key);
            System.out.println(key + "," + value);
        }
    }
}
```

获取所有键值对对象的集合(`Set<Map.Entry<K,V>> entrySet()`)，再遍历键值对对象的集合，得到每一个键值对对象(用增强for)`Map.Entry`，最后根据键值对对象获取键(getKey())和值(getValue())

```java
class work{
    public static void main(String[] args) {

        Map<String,String> map = new HashMap<String,String>();

        map.put("zhao","123");
        map.put("hou","456");

        Set<Map.Entry<String,String>> entrySet = map.entrySet();
        for(Map.Entry<String,String> m: entrySet){
            String key = m.getKey();
            String value = m.getValue();
            System.out.println(key + "," + value);
        }
    }
}
```

## Stack

栈是Vector的一个子类，它实现了一个标准的后进先出的栈

### 创建

```java
Stack<Integer> st = new Stack<Integer>();
```

### 方法

| 方法名                      | 说明                                             |
| :-------------------------- | :----------------------------------------------- |
| boolean empty()             | 测试堆栈是否为空                                 |
| Object peek( )              | 查看堆栈顶部的对象，但不从堆栈中移除它。         |
| Object pop( )               | 移除堆栈顶部的对象，并作为此函数的值返回该对象。 |
| Object push(Object element) | 把项压入堆栈顶部。                               |
| int search(Object element)  | 返回对象在堆栈中的位置，以 1 为基数。            |
